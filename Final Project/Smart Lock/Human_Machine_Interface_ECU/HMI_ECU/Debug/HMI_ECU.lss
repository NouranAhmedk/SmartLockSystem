
HMI_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003f12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00800060  00003f12  00003fa6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800128  00800128  0000406e  2**0
                  ALLOC
  3 .stab         00003cb4  00000000  00000000  00004070  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003f55  00000000  00000000  00007d24  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000bc79  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000bdb9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000bf29  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000db72  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000ea5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000f80c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000f96c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000fbf9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000103c7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 00 	jmp	0x14e	; 0x14e <__ctors_end>
       4:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
       8:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
       c:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      10:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      14:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      18:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      1c:	0c 94 66 07 	jmp	0xecc	; 0xecc <__vector_7>
      20:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      24:	0c 94 33 07 	jmp	0xe66	; 0xe66 <__vector_9>
      28:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      2c:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      30:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      34:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      38:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      3c:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      40:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      44:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      48:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      4c:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      50:	0c 94 c4 00 	jmp	0x188	; 0x188 <__bad_interrupt>
      54:	00 40       	sbci	r16, 0x00	; 0
      56:	7a 10       	cpse	r7, r10
      58:	f3 5a       	subi	r31, 0xA3	; 163
      5a:	00 a0       	ldd	r0, Z+32	; 0x20
      5c:	72 4e       	sbci	r23, 0xE2	; 226
      5e:	18 09       	sbc	r17, r8
      60:	00 10       	cpse	r0, r0
      62:	a5 d4       	rcall	.+2378   	; 0x9ae <__pack_f+0xba>
      64:	e8 00       	.word	0x00e8	; ????
      66:	00 e8       	ldi	r16, 0x80	; 128
      68:	76 48       	sbci	r23, 0x86	; 134
      6a:	17 00       	.word	0x0017	; ????
      6c:	00 e4       	ldi	r16, 0x40	; 64
      6e:	0b 54       	subi	r16, 0x4B	; 75
      70:	02 00       	.word	0x0002	; ????
      72:	00 ca       	rjmp	.-3072   	; 0xfffff474 <__eeprom_end+0xff7ef474>
      74:	9a 3b       	cpi	r25, 0xBA	; 186
      76:	00 00       	nop
      78:	00 e1       	ldi	r16, 0x10	; 16
      7a:	f5 05       	cpc	r31, r5
      7c:	00 00       	nop
      7e:	80 96       	adiw	r24, 0x20	; 32
      80:	98 00       	.word	0x0098	; ????
      82:	00 00       	nop
      84:	40 42       	sbci	r20, 0x20	; 32
      86:	0f 00       	.word	0x000f	; ????
      88:	00 00       	nop
      8a:	a0 86       	std	Z+8, r10	; 0x08
      8c:	01 00       	.word	0x0001	; ????
      8e:	00 00       	nop
      90:	10 27       	eor	r17, r16
      92:	00 00       	nop
      94:	00 00       	nop
      96:	e8 03       	fmulsu	r22, r16
      98:	00 00       	nop
      9a:	00 00       	nop
      9c:	64 00       	.word	0x0064	; ????
      9e:	00 00       	nop
      a0:	00 00       	nop
      a2:	0a 00       	.word	0x000a	; ????
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	01 00       	.word	0x0001	; ????
      aa:	00 00       	nop
      ac:	00 00       	nop
      ae:	2c 76       	andi	r18, 0x6C	; 108
      b0:	d8 88       	ldd	r13, Y+16	; 0x10
      b2:	dc 67       	ori	r29, 0x7C	; 124
      b4:	4f 08       	sbc	r4, r15
      b6:	23 df       	rcall	.-442    	; 0xfffffefe <__eeprom_end+0xff7efefe>
      b8:	c1 df       	rcall	.-126    	; 0x3c <__CCP__+0x8>
      ba:	ae 59       	subi	r26, 0x9E	; 158
      bc:	e1 b1       	in	r30, 0x01	; 1
      be:	b7 96       	adiw	r30, 0x27	; 39
      c0:	e5 e3       	ldi	r30, 0x35	; 53
      c2:	e4 53       	subi	r30, 0x34	; 52
      c4:	c6 3a       	cpi	r28, 0xA6	; 166
      c6:	e6 51       	subi	r30, 0x16	; 22
      c8:	99 76       	andi	r25, 0x69	; 105
      ca:	96 e8       	ldi	r25, 0x86	; 134
      cc:	e6 c2       	rjmp	.+1484   	; 0x69a <__mulsf3+0x162>
      ce:	84 26       	eor	r8, r20
      d0:	eb 89       	ldd	r30, Y+19	; 0x13
      d2:	8c 9b       	sbis	0x11, 4	; 17
      d4:	62 ed       	ldi	r22, 0xD2	; 210
      d6:	40 7c       	andi	r20, 0xC0	; 192
      d8:	6f fc       	.word	0xfc6f	; ????
      da:	ef bc       	out	0x2f, r14	; 47
      dc:	9c 9f       	mul	r25, r28
      de:	40 f2       	brcs	.-112    	; 0x70 <__SREG__+0x31>
      e0:	ba a5       	ldd	r27, Y+42	; 0x2a
      e2:	6f a5       	ldd	r22, Y+47	; 0x2f
      e4:	f4 90       	lpm	r15, Z+
      e6:	05 5a       	subi	r16, 0xA5	; 165
      e8:	2a f7       	brpl	.-54     	; 0xb4 <__SREG__+0x75>
      ea:	5c 93       	st	X, r21
      ec:	6b 6c       	ori	r22, 0xCB	; 203
      ee:	f9 67       	ori	r31, 0x79	; 121
      f0:	6d c1       	rjmp	.+730    	; 0x3cc <_fpadd_parts+0x1e8>
      f2:	1b fc       	.word	0xfc1b	; ????
      f4:	e0 e4       	ldi	r30, 0x40	; 64
      f6:	0d 47       	sbci	r16, 0x7D	; 125
      f8:	fe f5       	brtc	.+126    	; 0x178 <.do_clear_bss_loop>
      fa:	20 e6       	ldi	r18, 0x60	; 96
      fc:	b5 00       	.word	0x00b5	; ????
      fe:	d0 ed       	ldi	r29, 0xD0	; 208
     100:	90 2e       	mov	r9, r16
     102:	03 00       	.word	0x0003	; ????
     104:	94 35       	cpi	r25, 0x54	; 84
     106:	77 05       	cpc	r23, r7
     108:	00 80       	ld	r0, Z
     10a:	84 1e       	adc	r8, r20
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 20       	and	r0, r0
     110:	4e 0a       	sbc	r4, r30
     112:	00 00       	nop
     114:	00 c8       	rjmp	.-4096   	; 0xfffff116 <__eeprom_end+0xff7ef116>
     116:	0c 33       	cpi	r16, 0x3C	; 60
     118:	33 33       	cpi	r19, 0x33	; 51
     11a:	33 0f       	add	r19, r19
     11c:	98 6e       	ori	r25, 0xE8	; 232
     11e:	12 83       	std	Z+2, r17	; 0x02
     120:	11 41       	sbci	r17, 0x11	; 17
     122:	ef 8d       	ldd	r30, Y+31	; 0x1f
     124:	21 14       	cp	r2, r1
     126:	89 3b       	cpi	r24, 0xB9	; 185
     128:	e6 55       	subi	r30, 0x56	; 86
     12a:	16 cf       	rjmp	.-468    	; 0xffffff58 <__eeprom_end+0xff7eff58>
     12c:	fe e6       	ldi	r31, 0x6E	; 110
     12e:	db 18       	sub	r13, r11
     130:	d1 84       	ldd	r13, Z+9	; 0x09
     132:	4b 38       	cpi	r20, 0x8B	; 139
     134:	1b f7       	brvc	.-58     	; 0xfc <__SREG__+0xbd>
     136:	7c 1d       	adc	r23, r12
     138:	90 1d       	adc	r25, r0
     13a:	a4 bb       	out	0x14, r26	; 20
     13c:	e4 24       	eor	r14, r4
     13e:	20 32       	cpi	r18, 0x20	; 32
     140:	84 72       	andi	r24, 0x24	; 36
     142:	5e 22       	and	r5, r30
     144:	81 00       	.word	0x0081	; ????
     146:	c9 f1       	breq	.+114    	; 0x1ba <__fixunssfsi+0x2e>
     148:	24 ec       	ldi	r18, 0xC4	; 196
     14a:	a1 e5       	ldi	r26, 0x51	; 81
     14c:	3d 27       	eor	r19, r29

0000014e <__ctors_end>:
     14e:	11 24       	eor	r1, r1
     150:	1f be       	out	0x3f, r1	; 63
     152:	cf e5       	ldi	r28, 0x5F	; 95
     154:	d8 e0       	ldi	r29, 0x08	; 8
     156:	de bf       	out	0x3e, r29	; 62
     158:	cd bf       	out	0x3d, r28	; 61

0000015a <__do_copy_data>:
     15a:	11 e0       	ldi	r17, 0x01	; 1
     15c:	a0 e6       	ldi	r26, 0x60	; 96
     15e:	b0 e0       	ldi	r27, 0x00	; 0
     160:	e2 e1       	ldi	r30, 0x12	; 18
     162:	ff e3       	ldi	r31, 0x3F	; 63
     164:	02 c0       	rjmp	.+4      	; 0x16a <.do_copy_data_start>

00000166 <.do_copy_data_loop>:
     166:	05 90       	lpm	r0, Z+
     168:	0d 92       	st	X+, r0

0000016a <.do_copy_data_start>:
     16a:	a8 32       	cpi	r26, 0x28	; 40
     16c:	b1 07       	cpc	r27, r17
     16e:	d9 f7       	brne	.-10     	; 0x166 <.do_copy_data_loop>

00000170 <__do_clear_bss>:
     170:	11 e0       	ldi	r17, 0x01	; 1
     172:	a8 e2       	ldi	r26, 0x28	; 40
     174:	b1 e0       	ldi	r27, 0x01	; 1
     176:	01 c0       	rjmp	.+2      	; 0x17a <.do_clear_bss_start>

00000178 <.do_clear_bss_loop>:
     178:	1d 92       	st	X+, r1

0000017a <.do_clear_bss_start>:
     17a:	ab 32       	cpi	r26, 0x2B	; 43
     17c:	b1 07       	cpc	r27, r17
     17e:	e1 f7       	brne	.-8      	; 0x178 <.do_clear_bss_loop>
     180:	0e 94 35 12 	call	0x246a	; 0x246a <main>
     184:	0c 94 87 1f 	jmp	0x3f0e	; 0x3f0e <_exit>

00000188 <__bad_interrupt>:
     188:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000018c <__fixunssfsi>:
     18c:	ef 92       	push	r14
     18e:	ff 92       	push	r15
     190:	0f 93       	push	r16
     192:	1f 93       	push	r17
     194:	7b 01       	movw	r14, r22
     196:	8c 01       	movw	r16, r24
     198:	20 e0       	ldi	r18, 0x00	; 0
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	40 e0       	ldi	r20, 0x00	; 0
     19e:	5f e4       	ldi	r21, 0x4F	; 79
     1a0:	0e 94 c6 03 	call	0x78c	; 0x78c <__gesf2>
     1a4:	88 23       	and	r24, r24
     1a6:	8c f0       	brlt	.+34     	; 0x1ca <__fixunssfsi+0x3e>
     1a8:	c8 01       	movw	r24, r16
     1aa:	b7 01       	movw	r22, r14
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	40 e0       	ldi	r20, 0x00	; 0
     1b2:	5f e4       	ldi	r21, 0x4F	; 79
     1b4:	0e 94 3e 02 	call	0x47c	; 0x47c <__subsf3>
     1b8:	0e 94 26 04 	call	0x84c	; 0x84c <__fixsfsi>
     1bc:	9b 01       	movw	r18, r22
     1be:	ac 01       	movw	r20, r24
     1c0:	20 50       	subi	r18, 0x00	; 0
     1c2:	30 40       	sbci	r19, 0x00	; 0
     1c4:	40 40       	sbci	r20, 0x00	; 0
     1c6:	50 48       	sbci	r21, 0x80	; 128
     1c8:	06 c0       	rjmp	.+12     	; 0x1d6 <__fixunssfsi+0x4a>
     1ca:	c8 01       	movw	r24, r16
     1cc:	b7 01       	movw	r22, r14
     1ce:	0e 94 26 04 	call	0x84c	; 0x84c <__fixsfsi>
     1d2:	9b 01       	movw	r18, r22
     1d4:	ac 01       	movw	r20, r24
     1d6:	b9 01       	movw	r22, r18
     1d8:	ca 01       	movw	r24, r20
     1da:	1f 91       	pop	r17
     1dc:	0f 91       	pop	r16
     1de:	ff 90       	pop	r15
     1e0:	ef 90       	pop	r14
     1e2:	08 95       	ret

000001e4 <_fpadd_parts>:
     1e4:	a0 e0       	ldi	r26, 0x00	; 0
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	e8 ef       	ldi	r30, 0xF8	; 248
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
     1ec:	0c 94 b0 1c 	jmp	0x3960	; 0x3960 <__prologue_saves__>
     1f0:	dc 01       	movw	r26, r24
     1f2:	2b 01       	movw	r4, r22
     1f4:	fa 01       	movw	r30, r20
     1f6:	9c 91       	ld	r25, X
     1f8:	92 30       	cpi	r25, 0x02	; 2
     1fa:	08 f4       	brcc	.+2      	; 0x1fe <_fpadd_parts+0x1a>
     1fc:	39 c1       	rjmp	.+626    	; 0x470 <_fpadd_parts+0x28c>
     1fe:	eb 01       	movw	r28, r22
     200:	88 81       	ld	r24, Y
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	08 f4       	brcc	.+2      	; 0x208 <_fpadd_parts+0x24>
     206:	33 c1       	rjmp	.+614    	; 0x46e <_fpadd_parts+0x28a>
     208:	94 30       	cpi	r25, 0x04	; 4
     20a:	69 f4       	brne	.+26     	; 0x226 <_fpadd_parts+0x42>
     20c:	84 30       	cpi	r24, 0x04	; 4
     20e:	09 f0       	breq	.+2      	; 0x212 <_fpadd_parts+0x2e>
     210:	2f c1       	rjmp	.+606    	; 0x470 <_fpadd_parts+0x28c>
     212:	11 96       	adiw	r26, 0x01	; 1
     214:	9c 91       	ld	r25, X
     216:	11 97       	sbiw	r26, 0x01	; 1
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	98 17       	cp	r25, r24
     21c:	09 f4       	brne	.+2      	; 0x220 <_fpadd_parts+0x3c>
     21e:	28 c1       	rjmp	.+592    	; 0x470 <_fpadd_parts+0x28c>
     220:	a2 e1       	ldi	r26, 0x12	; 18
     222:	b1 e0       	ldi	r27, 0x01	; 1
     224:	25 c1       	rjmp	.+586    	; 0x470 <_fpadd_parts+0x28c>
     226:	84 30       	cpi	r24, 0x04	; 4
     228:	09 f4       	brne	.+2      	; 0x22c <_fpadd_parts+0x48>
     22a:	21 c1       	rjmp	.+578    	; 0x46e <_fpadd_parts+0x28a>
     22c:	82 30       	cpi	r24, 0x02	; 2
     22e:	a9 f4       	brne	.+42     	; 0x25a <_fpadd_parts+0x76>
     230:	92 30       	cpi	r25, 0x02	; 2
     232:	09 f0       	breq	.+2      	; 0x236 <_fpadd_parts+0x52>
     234:	1d c1       	rjmp	.+570    	; 0x470 <_fpadd_parts+0x28c>
     236:	9a 01       	movw	r18, r20
     238:	ad 01       	movw	r20, r26
     23a:	88 e0       	ldi	r24, 0x08	; 8
     23c:	ea 01       	movw	r28, r20
     23e:	09 90       	ld	r0, Y+
     240:	ae 01       	movw	r20, r28
     242:	e9 01       	movw	r28, r18
     244:	09 92       	st	Y+, r0
     246:	9e 01       	movw	r18, r28
     248:	81 50       	subi	r24, 0x01	; 1
     24a:	c1 f7       	brne	.-16     	; 0x23c <_fpadd_parts+0x58>
     24c:	e2 01       	movw	r28, r4
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	11 96       	adiw	r26, 0x01	; 1
     252:	9c 91       	ld	r25, X
     254:	89 23       	and	r24, r25
     256:	81 83       	std	Z+1, r24	; 0x01
     258:	08 c1       	rjmp	.+528    	; 0x46a <_fpadd_parts+0x286>
     25a:	92 30       	cpi	r25, 0x02	; 2
     25c:	09 f4       	brne	.+2      	; 0x260 <_fpadd_parts+0x7c>
     25e:	07 c1       	rjmp	.+526    	; 0x46e <_fpadd_parts+0x28a>
     260:	12 96       	adiw	r26, 0x02	; 2
     262:	2d 90       	ld	r2, X+
     264:	3c 90       	ld	r3, X
     266:	13 97       	sbiw	r26, 0x03	; 3
     268:	eb 01       	movw	r28, r22
     26a:	8a 81       	ldd	r24, Y+2	; 0x02
     26c:	9b 81       	ldd	r25, Y+3	; 0x03
     26e:	14 96       	adiw	r26, 0x04	; 4
     270:	ad 90       	ld	r10, X+
     272:	bd 90       	ld	r11, X+
     274:	cd 90       	ld	r12, X+
     276:	dc 90       	ld	r13, X
     278:	17 97       	sbiw	r26, 0x07	; 7
     27a:	ec 80       	ldd	r14, Y+4	; 0x04
     27c:	fd 80       	ldd	r15, Y+5	; 0x05
     27e:	0e 81       	ldd	r16, Y+6	; 0x06
     280:	1f 81       	ldd	r17, Y+7	; 0x07
     282:	91 01       	movw	r18, r2
     284:	28 1b       	sub	r18, r24
     286:	39 0b       	sbc	r19, r25
     288:	b9 01       	movw	r22, r18
     28a:	37 ff       	sbrs	r19, 7
     28c:	04 c0       	rjmp	.+8      	; 0x296 <_fpadd_parts+0xb2>
     28e:	66 27       	eor	r22, r22
     290:	77 27       	eor	r23, r23
     292:	62 1b       	sub	r22, r18
     294:	73 0b       	sbc	r23, r19
     296:	60 32       	cpi	r22, 0x20	; 32
     298:	71 05       	cpc	r23, r1
     29a:	0c f0       	brlt	.+2      	; 0x29e <_fpadd_parts+0xba>
     29c:	61 c0       	rjmp	.+194    	; 0x360 <_fpadd_parts+0x17c>
     29e:	12 16       	cp	r1, r18
     2a0:	13 06       	cpc	r1, r19
     2a2:	6c f5       	brge	.+90     	; 0x2fe <_fpadd_parts+0x11a>
     2a4:	37 01       	movw	r6, r14
     2a6:	48 01       	movw	r8, r16
     2a8:	06 2e       	mov	r0, r22
     2aa:	04 c0       	rjmp	.+8      	; 0x2b4 <_fpadd_parts+0xd0>
     2ac:	96 94       	lsr	r9
     2ae:	87 94       	ror	r8
     2b0:	77 94       	ror	r7
     2b2:	67 94       	ror	r6
     2b4:	0a 94       	dec	r0
     2b6:	d2 f7       	brpl	.-12     	; 0x2ac <_fpadd_parts+0xc8>
     2b8:	21 e0       	ldi	r18, 0x01	; 1
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	40 e0       	ldi	r20, 0x00	; 0
     2be:	50 e0       	ldi	r21, 0x00	; 0
     2c0:	04 c0       	rjmp	.+8      	; 0x2ca <_fpadd_parts+0xe6>
     2c2:	22 0f       	add	r18, r18
     2c4:	33 1f       	adc	r19, r19
     2c6:	44 1f       	adc	r20, r20
     2c8:	55 1f       	adc	r21, r21
     2ca:	6a 95       	dec	r22
     2cc:	d2 f7       	brpl	.-12     	; 0x2c2 <_fpadd_parts+0xde>
     2ce:	21 50       	subi	r18, 0x01	; 1
     2d0:	30 40       	sbci	r19, 0x00	; 0
     2d2:	40 40       	sbci	r20, 0x00	; 0
     2d4:	50 40       	sbci	r21, 0x00	; 0
     2d6:	2e 21       	and	r18, r14
     2d8:	3f 21       	and	r19, r15
     2da:	40 23       	and	r20, r16
     2dc:	51 23       	and	r21, r17
     2de:	21 15       	cp	r18, r1
     2e0:	31 05       	cpc	r19, r1
     2e2:	41 05       	cpc	r20, r1
     2e4:	51 05       	cpc	r21, r1
     2e6:	21 f0       	breq	.+8      	; 0x2f0 <_fpadd_parts+0x10c>
     2e8:	21 e0       	ldi	r18, 0x01	; 1
     2ea:	30 e0       	ldi	r19, 0x00	; 0
     2ec:	40 e0       	ldi	r20, 0x00	; 0
     2ee:	50 e0       	ldi	r21, 0x00	; 0
     2f0:	79 01       	movw	r14, r18
     2f2:	8a 01       	movw	r16, r20
     2f4:	e6 28       	or	r14, r6
     2f6:	f7 28       	or	r15, r7
     2f8:	08 29       	or	r16, r8
     2fa:	19 29       	or	r17, r9
     2fc:	3c c0       	rjmp	.+120    	; 0x376 <_fpadd_parts+0x192>
     2fe:	23 2b       	or	r18, r19
     300:	d1 f1       	breq	.+116    	; 0x376 <_fpadd_parts+0x192>
     302:	26 0e       	add	r2, r22
     304:	37 1e       	adc	r3, r23
     306:	35 01       	movw	r6, r10
     308:	46 01       	movw	r8, r12
     30a:	06 2e       	mov	r0, r22
     30c:	04 c0       	rjmp	.+8      	; 0x316 <_fpadd_parts+0x132>
     30e:	96 94       	lsr	r9
     310:	87 94       	ror	r8
     312:	77 94       	ror	r7
     314:	67 94       	ror	r6
     316:	0a 94       	dec	r0
     318:	d2 f7       	brpl	.-12     	; 0x30e <_fpadd_parts+0x12a>
     31a:	21 e0       	ldi	r18, 0x01	; 1
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	40 e0       	ldi	r20, 0x00	; 0
     320:	50 e0       	ldi	r21, 0x00	; 0
     322:	04 c0       	rjmp	.+8      	; 0x32c <_fpadd_parts+0x148>
     324:	22 0f       	add	r18, r18
     326:	33 1f       	adc	r19, r19
     328:	44 1f       	adc	r20, r20
     32a:	55 1f       	adc	r21, r21
     32c:	6a 95       	dec	r22
     32e:	d2 f7       	brpl	.-12     	; 0x324 <_fpadd_parts+0x140>
     330:	21 50       	subi	r18, 0x01	; 1
     332:	30 40       	sbci	r19, 0x00	; 0
     334:	40 40       	sbci	r20, 0x00	; 0
     336:	50 40       	sbci	r21, 0x00	; 0
     338:	2a 21       	and	r18, r10
     33a:	3b 21       	and	r19, r11
     33c:	4c 21       	and	r20, r12
     33e:	5d 21       	and	r21, r13
     340:	21 15       	cp	r18, r1
     342:	31 05       	cpc	r19, r1
     344:	41 05       	cpc	r20, r1
     346:	51 05       	cpc	r21, r1
     348:	21 f0       	breq	.+8      	; 0x352 <_fpadd_parts+0x16e>
     34a:	21 e0       	ldi	r18, 0x01	; 1
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	40 e0       	ldi	r20, 0x00	; 0
     350:	50 e0       	ldi	r21, 0x00	; 0
     352:	59 01       	movw	r10, r18
     354:	6a 01       	movw	r12, r20
     356:	a6 28       	or	r10, r6
     358:	b7 28       	or	r11, r7
     35a:	c8 28       	or	r12, r8
     35c:	d9 28       	or	r13, r9
     35e:	0b c0       	rjmp	.+22     	; 0x376 <_fpadd_parts+0x192>
     360:	82 15       	cp	r24, r2
     362:	93 05       	cpc	r25, r3
     364:	2c f0       	brlt	.+10     	; 0x370 <_fpadd_parts+0x18c>
     366:	1c 01       	movw	r2, r24
     368:	aa 24       	eor	r10, r10
     36a:	bb 24       	eor	r11, r11
     36c:	65 01       	movw	r12, r10
     36e:	03 c0       	rjmp	.+6      	; 0x376 <_fpadd_parts+0x192>
     370:	ee 24       	eor	r14, r14
     372:	ff 24       	eor	r15, r15
     374:	87 01       	movw	r16, r14
     376:	11 96       	adiw	r26, 0x01	; 1
     378:	9c 91       	ld	r25, X
     37a:	d2 01       	movw	r26, r4
     37c:	11 96       	adiw	r26, 0x01	; 1
     37e:	8c 91       	ld	r24, X
     380:	98 17       	cp	r25, r24
     382:	09 f4       	brne	.+2      	; 0x386 <_fpadd_parts+0x1a2>
     384:	45 c0       	rjmp	.+138    	; 0x410 <_fpadd_parts+0x22c>
     386:	99 23       	and	r25, r25
     388:	39 f0       	breq	.+14     	; 0x398 <_fpadd_parts+0x1b4>
     38a:	a8 01       	movw	r20, r16
     38c:	97 01       	movw	r18, r14
     38e:	2a 19       	sub	r18, r10
     390:	3b 09       	sbc	r19, r11
     392:	4c 09       	sbc	r20, r12
     394:	5d 09       	sbc	r21, r13
     396:	06 c0       	rjmp	.+12     	; 0x3a4 <_fpadd_parts+0x1c0>
     398:	a6 01       	movw	r20, r12
     39a:	95 01       	movw	r18, r10
     39c:	2e 19       	sub	r18, r14
     39e:	3f 09       	sbc	r19, r15
     3a0:	40 0b       	sbc	r20, r16
     3a2:	51 0b       	sbc	r21, r17
     3a4:	57 fd       	sbrc	r21, 7
     3a6:	08 c0       	rjmp	.+16     	; 0x3b8 <_fpadd_parts+0x1d4>
     3a8:	11 82       	std	Z+1, r1	; 0x01
     3aa:	33 82       	std	Z+3, r3	; 0x03
     3ac:	22 82       	std	Z+2, r2	; 0x02
     3ae:	24 83       	std	Z+4, r18	; 0x04
     3b0:	35 83       	std	Z+5, r19	; 0x05
     3b2:	46 83       	std	Z+6, r20	; 0x06
     3b4:	57 83       	std	Z+7, r21	; 0x07
     3b6:	1d c0       	rjmp	.+58     	; 0x3f2 <_fpadd_parts+0x20e>
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	81 83       	std	Z+1, r24	; 0x01
     3bc:	33 82       	std	Z+3, r3	; 0x03
     3be:	22 82       	std	Z+2, r2	; 0x02
     3c0:	88 27       	eor	r24, r24
     3c2:	99 27       	eor	r25, r25
     3c4:	dc 01       	movw	r26, r24
     3c6:	82 1b       	sub	r24, r18
     3c8:	93 0b       	sbc	r25, r19
     3ca:	a4 0b       	sbc	r26, r20
     3cc:	b5 0b       	sbc	r27, r21
     3ce:	84 83       	std	Z+4, r24	; 0x04
     3d0:	95 83       	std	Z+5, r25	; 0x05
     3d2:	a6 83       	std	Z+6, r26	; 0x06
     3d4:	b7 83       	std	Z+7, r27	; 0x07
     3d6:	0d c0       	rjmp	.+26     	; 0x3f2 <_fpadd_parts+0x20e>
     3d8:	22 0f       	add	r18, r18
     3da:	33 1f       	adc	r19, r19
     3dc:	44 1f       	adc	r20, r20
     3de:	55 1f       	adc	r21, r21
     3e0:	24 83       	std	Z+4, r18	; 0x04
     3e2:	35 83       	std	Z+5, r19	; 0x05
     3e4:	46 83       	std	Z+6, r20	; 0x06
     3e6:	57 83       	std	Z+7, r21	; 0x07
     3e8:	82 81       	ldd	r24, Z+2	; 0x02
     3ea:	93 81       	ldd	r25, Z+3	; 0x03
     3ec:	01 97       	sbiw	r24, 0x01	; 1
     3ee:	93 83       	std	Z+3, r25	; 0x03
     3f0:	82 83       	std	Z+2, r24	; 0x02
     3f2:	24 81       	ldd	r18, Z+4	; 0x04
     3f4:	35 81       	ldd	r19, Z+5	; 0x05
     3f6:	46 81       	ldd	r20, Z+6	; 0x06
     3f8:	57 81       	ldd	r21, Z+7	; 0x07
     3fa:	da 01       	movw	r26, r20
     3fc:	c9 01       	movw	r24, r18
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	a1 09       	sbc	r26, r1
     402:	b1 09       	sbc	r27, r1
     404:	8f 5f       	subi	r24, 0xFF	; 255
     406:	9f 4f       	sbci	r25, 0xFF	; 255
     408:	af 4f       	sbci	r26, 0xFF	; 255
     40a:	bf 43       	sbci	r27, 0x3F	; 63
     40c:	28 f3       	brcs	.-54     	; 0x3d8 <_fpadd_parts+0x1f4>
     40e:	0b c0       	rjmp	.+22     	; 0x426 <_fpadd_parts+0x242>
     410:	91 83       	std	Z+1, r25	; 0x01
     412:	33 82       	std	Z+3, r3	; 0x03
     414:	22 82       	std	Z+2, r2	; 0x02
     416:	ea 0c       	add	r14, r10
     418:	fb 1c       	adc	r15, r11
     41a:	0c 1d       	adc	r16, r12
     41c:	1d 1d       	adc	r17, r13
     41e:	e4 82       	std	Z+4, r14	; 0x04
     420:	f5 82       	std	Z+5, r15	; 0x05
     422:	06 83       	std	Z+6, r16	; 0x06
     424:	17 83       	std	Z+7, r17	; 0x07
     426:	83 e0       	ldi	r24, 0x03	; 3
     428:	80 83       	st	Z, r24
     42a:	24 81       	ldd	r18, Z+4	; 0x04
     42c:	35 81       	ldd	r19, Z+5	; 0x05
     42e:	46 81       	ldd	r20, Z+6	; 0x06
     430:	57 81       	ldd	r21, Z+7	; 0x07
     432:	57 ff       	sbrs	r21, 7
     434:	1a c0       	rjmp	.+52     	; 0x46a <_fpadd_parts+0x286>
     436:	c9 01       	movw	r24, r18
     438:	aa 27       	eor	r26, r26
     43a:	97 fd       	sbrc	r25, 7
     43c:	a0 95       	com	r26
     43e:	ba 2f       	mov	r27, r26
     440:	81 70       	andi	r24, 0x01	; 1
     442:	90 70       	andi	r25, 0x00	; 0
     444:	a0 70       	andi	r26, 0x00	; 0
     446:	b0 70       	andi	r27, 0x00	; 0
     448:	56 95       	lsr	r21
     44a:	47 95       	ror	r20
     44c:	37 95       	ror	r19
     44e:	27 95       	ror	r18
     450:	82 2b       	or	r24, r18
     452:	93 2b       	or	r25, r19
     454:	a4 2b       	or	r26, r20
     456:	b5 2b       	or	r27, r21
     458:	84 83       	std	Z+4, r24	; 0x04
     45a:	95 83       	std	Z+5, r25	; 0x05
     45c:	a6 83       	std	Z+6, r26	; 0x06
     45e:	b7 83       	std	Z+7, r27	; 0x07
     460:	82 81       	ldd	r24, Z+2	; 0x02
     462:	93 81       	ldd	r25, Z+3	; 0x03
     464:	01 96       	adiw	r24, 0x01	; 1
     466:	93 83       	std	Z+3, r25	; 0x03
     468:	82 83       	std	Z+2, r24	; 0x02
     46a:	df 01       	movw	r26, r30
     46c:	01 c0       	rjmp	.+2      	; 0x470 <_fpadd_parts+0x28c>
     46e:	d2 01       	movw	r26, r4
     470:	cd 01       	movw	r24, r26
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
     476:	e2 e1       	ldi	r30, 0x12	; 18
     478:	0c 94 cc 1c 	jmp	0x3998	; 0x3998 <__epilogue_restores__>

0000047c <__subsf3>:
     47c:	a0 e2       	ldi	r26, 0x20	; 32
     47e:	b0 e0       	ldi	r27, 0x00	; 0
     480:	e4 e4       	ldi	r30, 0x44	; 68
     482:	f2 e0       	ldi	r31, 0x02	; 2
     484:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <__prologue_saves__+0x18>
     488:	69 83       	std	Y+1, r22	; 0x01
     48a:	7a 83       	std	Y+2, r23	; 0x02
     48c:	8b 83       	std	Y+3, r24	; 0x03
     48e:	9c 83       	std	Y+4, r25	; 0x04
     490:	2d 83       	std	Y+5, r18	; 0x05
     492:	3e 83       	std	Y+6, r19	; 0x06
     494:	4f 83       	std	Y+7, r20	; 0x07
     496:	58 87       	std	Y+8, r21	; 0x08
     498:	e9 e0       	ldi	r30, 0x09	; 9
     49a:	ee 2e       	mov	r14, r30
     49c:	f1 2c       	mov	r15, r1
     49e:	ec 0e       	add	r14, r28
     4a0:	fd 1e       	adc	r15, r29
     4a2:	ce 01       	movw	r24, r28
     4a4:	01 96       	adiw	r24, 0x01	; 1
     4a6:	b7 01       	movw	r22, r14
     4a8:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     4ac:	8e 01       	movw	r16, r28
     4ae:	0f 5e       	subi	r16, 0xEF	; 239
     4b0:	1f 4f       	sbci	r17, 0xFF	; 255
     4b2:	ce 01       	movw	r24, r28
     4b4:	05 96       	adiw	r24, 0x05	; 5
     4b6:	b8 01       	movw	r22, r16
     4b8:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     4bc:	8a 89       	ldd	r24, Y+18	; 0x12
     4be:	91 e0       	ldi	r25, 0x01	; 1
     4c0:	89 27       	eor	r24, r25
     4c2:	8a 8b       	std	Y+18, r24	; 0x12
     4c4:	c7 01       	movw	r24, r14
     4c6:	b8 01       	movw	r22, r16
     4c8:	ae 01       	movw	r20, r28
     4ca:	47 5e       	subi	r20, 0xE7	; 231
     4cc:	5f 4f       	sbci	r21, 0xFF	; 255
     4ce:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <_fpadd_parts>
     4d2:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <__pack_f>
     4d6:	a0 96       	adiw	r28, 0x20	; 32
     4d8:	e6 e0       	ldi	r30, 0x06	; 6
     4da:	0c 94 d8 1c 	jmp	0x39b0	; 0x39b0 <__epilogue_restores__+0x18>

000004de <__addsf3>:
     4de:	a0 e2       	ldi	r26, 0x20	; 32
     4e0:	b0 e0       	ldi	r27, 0x00	; 0
     4e2:	e5 e7       	ldi	r30, 0x75	; 117
     4e4:	f2 e0       	ldi	r31, 0x02	; 2
     4e6:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <__prologue_saves__+0x18>
     4ea:	69 83       	std	Y+1, r22	; 0x01
     4ec:	7a 83       	std	Y+2, r23	; 0x02
     4ee:	8b 83       	std	Y+3, r24	; 0x03
     4f0:	9c 83       	std	Y+4, r25	; 0x04
     4f2:	2d 83       	std	Y+5, r18	; 0x05
     4f4:	3e 83       	std	Y+6, r19	; 0x06
     4f6:	4f 83       	std	Y+7, r20	; 0x07
     4f8:	58 87       	std	Y+8, r21	; 0x08
     4fa:	f9 e0       	ldi	r31, 0x09	; 9
     4fc:	ef 2e       	mov	r14, r31
     4fe:	f1 2c       	mov	r15, r1
     500:	ec 0e       	add	r14, r28
     502:	fd 1e       	adc	r15, r29
     504:	ce 01       	movw	r24, r28
     506:	01 96       	adiw	r24, 0x01	; 1
     508:	b7 01       	movw	r22, r14
     50a:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     50e:	8e 01       	movw	r16, r28
     510:	0f 5e       	subi	r16, 0xEF	; 239
     512:	1f 4f       	sbci	r17, 0xFF	; 255
     514:	ce 01       	movw	r24, r28
     516:	05 96       	adiw	r24, 0x05	; 5
     518:	b8 01       	movw	r22, r16
     51a:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     51e:	c7 01       	movw	r24, r14
     520:	b8 01       	movw	r22, r16
     522:	ae 01       	movw	r20, r28
     524:	47 5e       	subi	r20, 0xE7	; 231
     526:	5f 4f       	sbci	r21, 0xFF	; 255
     528:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <_fpadd_parts>
     52c:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <__pack_f>
     530:	a0 96       	adiw	r28, 0x20	; 32
     532:	e6 e0       	ldi	r30, 0x06	; 6
     534:	0c 94 d8 1c 	jmp	0x39b0	; 0x39b0 <__epilogue_restores__+0x18>

00000538 <__mulsf3>:
     538:	a0 e2       	ldi	r26, 0x20	; 32
     53a:	b0 e0       	ldi	r27, 0x00	; 0
     53c:	e2 ea       	ldi	r30, 0xA2	; 162
     53e:	f2 e0       	ldi	r31, 0x02	; 2
     540:	0c 94 b0 1c 	jmp	0x3960	; 0x3960 <__prologue_saves__>
     544:	69 83       	std	Y+1, r22	; 0x01
     546:	7a 83       	std	Y+2, r23	; 0x02
     548:	8b 83       	std	Y+3, r24	; 0x03
     54a:	9c 83       	std	Y+4, r25	; 0x04
     54c:	2d 83       	std	Y+5, r18	; 0x05
     54e:	3e 83       	std	Y+6, r19	; 0x06
     550:	4f 83       	std	Y+7, r20	; 0x07
     552:	58 87       	std	Y+8, r21	; 0x08
     554:	ce 01       	movw	r24, r28
     556:	01 96       	adiw	r24, 0x01	; 1
     558:	be 01       	movw	r22, r28
     55a:	67 5f       	subi	r22, 0xF7	; 247
     55c:	7f 4f       	sbci	r23, 0xFF	; 255
     55e:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     562:	ce 01       	movw	r24, r28
     564:	05 96       	adiw	r24, 0x05	; 5
     566:	be 01       	movw	r22, r28
     568:	6f 5e       	subi	r22, 0xEF	; 239
     56a:	7f 4f       	sbci	r23, 0xFF	; 255
     56c:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     570:	99 85       	ldd	r25, Y+9	; 0x09
     572:	92 30       	cpi	r25, 0x02	; 2
     574:	88 f0       	brcs	.+34     	; 0x598 <__mulsf3+0x60>
     576:	89 89       	ldd	r24, Y+17	; 0x11
     578:	82 30       	cpi	r24, 0x02	; 2
     57a:	c8 f0       	brcs	.+50     	; 0x5ae <__mulsf3+0x76>
     57c:	94 30       	cpi	r25, 0x04	; 4
     57e:	19 f4       	brne	.+6      	; 0x586 <__mulsf3+0x4e>
     580:	82 30       	cpi	r24, 0x02	; 2
     582:	51 f4       	brne	.+20     	; 0x598 <__mulsf3+0x60>
     584:	04 c0       	rjmp	.+8      	; 0x58e <__mulsf3+0x56>
     586:	84 30       	cpi	r24, 0x04	; 4
     588:	29 f4       	brne	.+10     	; 0x594 <__mulsf3+0x5c>
     58a:	92 30       	cpi	r25, 0x02	; 2
     58c:	81 f4       	brne	.+32     	; 0x5ae <__mulsf3+0x76>
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	91 e0       	ldi	r25, 0x01	; 1
     592:	c6 c0       	rjmp	.+396    	; 0x720 <__mulsf3+0x1e8>
     594:	92 30       	cpi	r25, 0x02	; 2
     596:	49 f4       	brne	.+18     	; 0x5aa <__mulsf3+0x72>
     598:	20 e0       	ldi	r18, 0x00	; 0
     59a:	9a 85       	ldd	r25, Y+10	; 0x0a
     59c:	8a 89       	ldd	r24, Y+18	; 0x12
     59e:	98 13       	cpse	r25, r24
     5a0:	21 e0       	ldi	r18, 0x01	; 1
     5a2:	2a 87       	std	Y+10, r18	; 0x0a
     5a4:	ce 01       	movw	r24, r28
     5a6:	09 96       	adiw	r24, 0x09	; 9
     5a8:	bb c0       	rjmp	.+374    	; 0x720 <__mulsf3+0x1e8>
     5aa:	82 30       	cpi	r24, 0x02	; 2
     5ac:	49 f4       	brne	.+18     	; 0x5c0 <__mulsf3+0x88>
     5ae:	20 e0       	ldi	r18, 0x00	; 0
     5b0:	9a 85       	ldd	r25, Y+10	; 0x0a
     5b2:	8a 89       	ldd	r24, Y+18	; 0x12
     5b4:	98 13       	cpse	r25, r24
     5b6:	21 e0       	ldi	r18, 0x01	; 1
     5b8:	2a 8b       	std	Y+18, r18	; 0x12
     5ba:	ce 01       	movw	r24, r28
     5bc:	41 96       	adiw	r24, 0x11	; 17
     5be:	b0 c0       	rjmp	.+352    	; 0x720 <__mulsf3+0x1e8>
     5c0:	2d 84       	ldd	r2, Y+13	; 0x0d
     5c2:	3e 84       	ldd	r3, Y+14	; 0x0e
     5c4:	4f 84       	ldd	r4, Y+15	; 0x0f
     5c6:	58 88       	ldd	r5, Y+16	; 0x10
     5c8:	6d 88       	ldd	r6, Y+21	; 0x15
     5ca:	7e 88       	ldd	r7, Y+22	; 0x16
     5cc:	8f 88       	ldd	r8, Y+23	; 0x17
     5ce:	98 8c       	ldd	r9, Y+24	; 0x18
     5d0:	ee 24       	eor	r14, r14
     5d2:	ff 24       	eor	r15, r15
     5d4:	87 01       	movw	r16, r14
     5d6:	aa 24       	eor	r10, r10
     5d8:	bb 24       	eor	r11, r11
     5da:	65 01       	movw	r12, r10
     5dc:	40 e0       	ldi	r20, 0x00	; 0
     5de:	50 e0       	ldi	r21, 0x00	; 0
     5e0:	60 e0       	ldi	r22, 0x00	; 0
     5e2:	70 e0       	ldi	r23, 0x00	; 0
     5e4:	e0 e0       	ldi	r30, 0x00	; 0
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	c1 01       	movw	r24, r2
     5ea:	81 70       	andi	r24, 0x01	; 1
     5ec:	90 70       	andi	r25, 0x00	; 0
     5ee:	89 2b       	or	r24, r25
     5f0:	e9 f0       	breq	.+58     	; 0x62c <__mulsf3+0xf4>
     5f2:	e6 0c       	add	r14, r6
     5f4:	f7 1c       	adc	r15, r7
     5f6:	08 1d       	adc	r16, r8
     5f8:	19 1d       	adc	r17, r9
     5fa:	9a 01       	movw	r18, r20
     5fc:	ab 01       	movw	r20, r22
     5fe:	2a 0d       	add	r18, r10
     600:	3b 1d       	adc	r19, r11
     602:	4c 1d       	adc	r20, r12
     604:	5d 1d       	adc	r21, r13
     606:	80 e0       	ldi	r24, 0x00	; 0
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	a0 e0       	ldi	r26, 0x00	; 0
     60c:	b0 e0       	ldi	r27, 0x00	; 0
     60e:	e6 14       	cp	r14, r6
     610:	f7 04       	cpc	r15, r7
     612:	08 05       	cpc	r16, r8
     614:	19 05       	cpc	r17, r9
     616:	20 f4       	brcc	.+8      	; 0x620 <__mulsf3+0xe8>
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	a0 e0       	ldi	r26, 0x00	; 0
     61e:	b0 e0       	ldi	r27, 0x00	; 0
     620:	ba 01       	movw	r22, r20
     622:	a9 01       	movw	r20, r18
     624:	48 0f       	add	r20, r24
     626:	59 1f       	adc	r21, r25
     628:	6a 1f       	adc	r22, r26
     62a:	7b 1f       	adc	r23, r27
     62c:	aa 0c       	add	r10, r10
     62e:	bb 1c       	adc	r11, r11
     630:	cc 1c       	adc	r12, r12
     632:	dd 1c       	adc	r13, r13
     634:	97 fe       	sbrs	r9, 7
     636:	08 c0       	rjmp	.+16     	; 0x648 <__mulsf3+0x110>
     638:	81 e0       	ldi	r24, 0x01	; 1
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	a0 e0       	ldi	r26, 0x00	; 0
     63e:	b0 e0       	ldi	r27, 0x00	; 0
     640:	a8 2a       	or	r10, r24
     642:	b9 2a       	or	r11, r25
     644:	ca 2a       	or	r12, r26
     646:	db 2a       	or	r13, r27
     648:	31 96       	adiw	r30, 0x01	; 1
     64a:	e0 32       	cpi	r30, 0x20	; 32
     64c:	f1 05       	cpc	r31, r1
     64e:	49 f0       	breq	.+18     	; 0x662 <__mulsf3+0x12a>
     650:	66 0c       	add	r6, r6
     652:	77 1c       	adc	r7, r7
     654:	88 1c       	adc	r8, r8
     656:	99 1c       	adc	r9, r9
     658:	56 94       	lsr	r5
     65a:	47 94       	ror	r4
     65c:	37 94       	ror	r3
     65e:	27 94       	ror	r2
     660:	c3 cf       	rjmp	.-122    	; 0x5e8 <__mulsf3+0xb0>
     662:	fa 85       	ldd	r31, Y+10	; 0x0a
     664:	ea 89       	ldd	r30, Y+18	; 0x12
     666:	2b 89       	ldd	r18, Y+19	; 0x13
     668:	3c 89       	ldd	r19, Y+20	; 0x14
     66a:	8b 85       	ldd	r24, Y+11	; 0x0b
     66c:	9c 85       	ldd	r25, Y+12	; 0x0c
     66e:	28 0f       	add	r18, r24
     670:	39 1f       	adc	r19, r25
     672:	2e 5f       	subi	r18, 0xFE	; 254
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	17 c0       	rjmp	.+46     	; 0x6a6 <__mulsf3+0x16e>
     678:	ca 01       	movw	r24, r20
     67a:	81 70       	andi	r24, 0x01	; 1
     67c:	90 70       	andi	r25, 0x00	; 0
     67e:	89 2b       	or	r24, r25
     680:	61 f0       	breq	.+24     	; 0x69a <__mulsf3+0x162>
     682:	16 95       	lsr	r17
     684:	07 95       	ror	r16
     686:	f7 94       	ror	r15
     688:	e7 94       	ror	r14
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e8       	ldi	r27, 0x80	; 128
     692:	e8 2a       	or	r14, r24
     694:	f9 2a       	or	r15, r25
     696:	0a 2b       	or	r16, r26
     698:	1b 2b       	or	r17, r27
     69a:	76 95       	lsr	r23
     69c:	67 95       	ror	r22
     69e:	57 95       	ror	r21
     6a0:	47 95       	ror	r20
     6a2:	2f 5f       	subi	r18, 0xFF	; 255
     6a4:	3f 4f       	sbci	r19, 0xFF	; 255
     6a6:	77 fd       	sbrc	r23, 7
     6a8:	e7 cf       	rjmp	.-50     	; 0x678 <__mulsf3+0x140>
     6aa:	0c c0       	rjmp	.+24     	; 0x6c4 <__mulsf3+0x18c>
     6ac:	44 0f       	add	r20, r20
     6ae:	55 1f       	adc	r21, r21
     6b0:	66 1f       	adc	r22, r22
     6b2:	77 1f       	adc	r23, r23
     6b4:	17 fd       	sbrc	r17, 7
     6b6:	41 60       	ori	r20, 0x01	; 1
     6b8:	ee 0c       	add	r14, r14
     6ba:	ff 1c       	adc	r15, r15
     6bc:	00 1f       	adc	r16, r16
     6be:	11 1f       	adc	r17, r17
     6c0:	21 50       	subi	r18, 0x01	; 1
     6c2:	30 40       	sbci	r19, 0x00	; 0
     6c4:	40 30       	cpi	r20, 0x00	; 0
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	59 07       	cpc	r21, r25
     6ca:	90 e0       	ldi	r25, 0x00	; 0
     6cc:	69 07       	cpc	r22, r25
     6ce:	90 e4       	ldi	r25, 0x40	; 64
     6d0:	79 07       	cpc	r23, r25
     6d2:	60 f3       	brcs	.-40     	; 0x6ac <__mulsf3+0x174>
     6d4:	2b 8f       	std	Y+27, r18	; 0x1b
     6d6:	3c 8f       	std	Y+28, r19	; 0x1c
     6d8:	db 01       	movw	r26, r22
     6da:	ca 01       	movw	r24, r20
     6dc:	8f 77       	andi	r24, 0x7F	; 127
     6de:	90 70       	andi	r25, 0x00	; 0
     6e0:	a0 70       	andi	r26, 0x00	; 0
     6e2:	b0 70       	andi	r27, 0x00	; 0
     6e4:	80 34       	cpi	r24, 0x40	; 64
     6e6:	91 05       	cpc	r25, r1
     6e8:	a1 05       	cpc	r26, r1
     6ea:	b1 05       	cpc	r27, r1
     6ec:	61 f4       	brne	.+24     	; 0x706 <__mulsf3+0x1ce>
     6ee:	47 fd       	sbrc	r20, 7
     6f0:	0a c0       	rjmp	.+20     	; 0x706 <__mulsf3+0x1ce>
     6f2:	e1 14       	cp	r14, r1
     6f4:	f1 04       	cpc	r15, r1
     6f6:	01 05       	cpc	r16, r1
     6f8:	11 05       	cpc	r17, r1
     6fa:	29 f0       	breq	.+10     	; 0x706 <__mulsf3+0x1ce>
     6fc:	40 5c       	subi	r20, 0xC0	; 192
     6fe:	5f 4f       	sbci	r21, 0xFF	; 255
     700:	6f 4f       	sbci	r22, 0xFF	; 255
     702:	7f 4f       	sbci	r23, 0xFF	; 255
     704:	40 78       	andi	r20, 0x80	; 128
     706:	1a 8e       	std	Y+26, r1	; 0x1a
     708:	fe 17       	cp	r31, r30
     70a:	11 f0       	breq	.+4      	; 0x710 <__mulsf3+0x1d8>
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	8a 8f       	std	Y+26, r24	; 0x1a
     710:	4d 8f       	std	Y+29, r20	; 0x1d
     712:	5e 8f       	std	Y+30, r21	; 0x1e
     714:	6f 8f       	std	Y+31, r22	; 0x1f
     716:	78 a3       	std	Y+32, r23	; 0x20
     718:	83 e0       	ldi	r24, 0x03	; 3
     71a:	89 8f       	std	Y+25, r24	; 0x19
     71c:	ce 01       	movw	r24, r28
     71e:	49 96       	adiw	r24, 0x19	; 25
     720:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <__pack_f>
     724:	a0 96       	adiw	r28, 0x20	; 32
     726:	e2 e1       	ldi	r30, 0x12	; 18
     728:	0c 94 cc 1c 	jmp	0x3998	; 0x3998 <__epilogue_restores__>

0000072c <__gtsf2>:
     72c:	a8 e1       	ldi	r26, 0x18	; 24
     72e:	b0 e0       	ldi	r27, 0x00	; 0
     730:	ec e9       	ldi	r30, 0x9C	; 156
     732:	f3 e0       	ldi	r31, 0x03	; 3
     734:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <__prologue_saves__+0x18>
     738:	69 83       	std	Y+1, r22	; 0x01
     73a:	7a 83       	std	Y+2, r23	; 0x02
     73c:	8b 83       	std	Y+3, r24	; 0x03
     73e:	9c 83       	std	Y+4, r25	; 0x04
     740:	2d 83       	std	Y+5, r18	; 0x05
     742:	3e 83       	std	Y+6, r19	; 0x06
     744:	4f 83       	std	Y+7, r20	; 0x07
     746:	58 87       	std	Y+8, r21	; 0x08
     748:	89 e0       	ldi	r24, 0x09	; 9
     74a:	e8 2e       	mov	r14, r24
     74c:	f1 2c       	mov	r15, r1
     74e:	ec 0e       	add	r14, r28
     750:	fd 1e       	adc	r15, r29
     752:	ce 01       	movw	r24, r28
     754:	01 96       	adiw	r24, 0x01	; 1
     756:	b7 01       	movw	r22, r14
     758:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     75c:	8e 01       	movw	r16, r28
     75e:	0f 5e       	subi	r16, 0xEF	; 239
     760:	1f 4f       	sbci	r17, 0xFF	; 255
     762:	ce 01       	movw	r24, r28
     764:	05 96       	adiw	r24, 0x05	; 5
     766:	b8 01       	movw	r22, r16
     768:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     76c:	89 85       	ldd	r24, Y+9	; 0x09
     76e:	82 30       	cpi	r24, 0x02	; 2
     770:	40 f0       	brcs	.+16     	; 0x782 <__gtsf2+0x56>
     772:	89 89       	ldd	r24, Y+17	; 0x11
     774:	82 30       	cpi	r24, 0x02	; 2
     776:	28 f0       	brcs	.+10     	; 0x782 <__gtsf2+0x56>
     778:	c7 01       	movw	r24, r14
     77a:	b8 01       	movw	r22, r16
     77c:	0e 94 c7 05 	call	0xb8e	; 0xb8e <__fpcmp_parts_f>
     780:	01 c0       	rjmp	.+2      	; 0x784 <__gtsf2+0x58>
     782:	8f ef       	ldi	r24, 0xFF	; 255
     784:	68 96       	adiw	r28, 0x18	; 24
     786:	e6 e0       	ldi	r30, 0x06	; 6
     788:	0c 94 d8 1c 	jmp	0x39b0	; 0x39b0 <__epilogue_restores__+0x18>

0000078c <__gesf2>:
     78c:	a8 e1       	ldi	r26, 0x18	; 24
     78e:	b0 e0       	ldi	r27, 0x00	; 0
     790:	ec ec       	ldi	r30, 0xCC	; 204
     792:	f3 e0       	ldi	r31, 0x03	; 3
     794:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <__prologue_saves__+0x18>
     798:	69 83       	std	Y+1, r22	; 0x01
     79a:	7a 83       	std	Y+2, r23	; 0x02
     79c:	8b 83       	std	Y+3, r24	; 0x03
     79e:	9c 83       	std	Y+4, r25	; 0x04
     7a0:	2d 83       	std	Y+5, r18	; 0x05
     7a2:	3e 83       	std	Y+6, r19	; 0x06
     7a4:	4f 83       	std	Y+7, r20	; 0x07
     7a6:	58 87       	std	Y+8, r21	; 0x08
     7a8:	89 e0       	ldi	r24, 0x09	; 9
     7aa:	e8 2e       	mov	r14, r24
     7ac:	f1 2c       	mov	r15, r1
     7ae:	ec 0e       	add	r14, r28
     7b0:	fd 1e       	adc	r15, r29
     7b2:	ce 01       	movw	r24, r28
     7b4:	01 96       	adiw	r24, 0x01	; 1
     7b6:	b7 01       	movw	r22, r14
     7b8:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     7bc:	8e 01       	movw	r16, r28
     7be:	0f 5e       	subi	r16, 0xEF	; 239
     7c0:	1f 4f       	sbci	r17, 0xFF	; 255
     7c2:	ce 01       	movw	r24, r28
     7c4:	05 96       	adiw	r24, 0x05	; 5
     7c6:	b8 01       	movw	r22, r16
     7c8:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     7cc:	89 85       	ldd	r24, Y+9	; 0x09
     7ce:	82 30       	cpi	r24, 0x02	; 2
     7d0:	40 f0       	brcs	.+16     	; 0x7e2 <__gesf2+0x56>
     7d2:	89 89       	ldd	r24, Y+17	; 0x11
     7d4:	82 30       	cpi	r24, 0x02	; 2
     7d6:	28 f0       	brcs	.+10     	; 0x7e2 <__gesf2+0x56>
     7d8:	c7 01       	movw	r24, r14
     7da:	b8 01       	movw	r22, r16
     7dc:	0e 94 c7 05 	call	0xb8e	; 0xb8e <__fpcmp_parts_f>
     7e0:	01 c0       	rjmp	.+2      	; 0x7e4 <__gesf2+0x58>
     7e2:	8f ef       	ldi	r24, 0xFF	; 255
     7e4:	68 96       	adiw	r28, 0x18	; 24
     7e6:	e6 e0       	ldi	r30, 0x06	; 6
     7e8:	0c 94 d8 1c 	jmp	0x39b0	; 0x39b0 <__epilogue_restores__+0x18>

000007ec <__ltsf2>:
     7ec:	a8 e1       	ldi	r26, 0x18	; 24
     7ee:	b0 e0       	ldi	r27, 0x00	; 0
     7f0:	ec ef       	ldi	r30, 0xFC	; 252
     7f2:	f3 e0       	ldi	r31, 0x03	; 3
     7f4:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <__prologue_saves__+0x18>
     7f8:	69 83       	std	Y+1, r22	; 0x01
     7fa:	7a 83       	std	Y+2, r23	; 0x02
     7fc:	8b 83       	std	Y+3, r24	; 0x03
     7fe:	9c 83       	std	Y+4, r25	; 0x04
     800:	2d 83       	std	Y+5, r18	; 0x05
     802:	3e 83       	std	Y+6, r19	; 0x06
     804:	4f 83       	std	Y+7, r20	; 0x07
     806:	58 87       	std	Y+8, r21	; 0x08
     808:	89 e0       	ldi	r24, 0x09	; 9
     80a:	e8 2e       	mov	r14, r24
     80c:	f1 2c       	mov	r15, r1
     80e:	ec 0e       	add	r14, r28
     810:	fd 1e       	adc	r15, r29
     812:	ce 01       	movw	r24, r28
     814:	01 96       	adiw	r24, 0x01	; 1
     816:	b7 01       	movw	r22, r14
     818:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     81c:	8e 01       	movw	r16, r28
     81e:	0f 5e       	subi	r16, 0xEF	; 239
     820:	1f 4f       	sbci	r17, 0xFF	; 255
     822:	ce 01       	movw	r24, r28
     824:	05 96       	adiw	r24, 0x05	; 5
     826:	b8 01       	movw	r22, r16
     828:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     82c:	89 85       	ldd	r24, Y+9	; 0x09
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	40 f0       	brcs	.+16     	; 0x842 <__ltsf2+0x56>
     832:	89 89       	ldd	r24, Y+17	; 0x11
     834:	82 30       	cpi	r24, 0x02	; 2
     836:	28 f0       	brcs	.+10     	; 0x842 <__ltsf2+0x56>
     838:	c7 01       	movw	r24, r14
     83a:	b8 01       	movw	r22, r16
     83c:	0e 94 c7 05 	call	0xb8e	; 0xb8e <__fpcmp_parts_f>
     840:	01 c0       	rjmp	.+2      	; 0x844 <__ltsf2+0x58>
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	68 96       	adiw	r28, 0x18	; 24
     846:	e6 e0       	ldi	r30, 0x06	; 6
     848:	0c 94 d8 1c 	jmp	0x39b0	; 0x39b0 <__epilogue_restores__+0x18>

0000084c <__fixsfsi>:
     84c:	ac e0       	ldi	r26, 0x0C	; 12
     84e:	b0 e0       	ldi	r27, 0x00	; 0
     850:	ec e2       	ldi	r30, 0x2C	; 44
     852:	f4 e0       	ldi	r31, 0x04	; 4
     854:	0c 94 c0 1c 	jmp	0x3980	; 0x3980 <__prologue_saves__+0x20>
     858:	69 83       	std	Y+1, r22	; 0x01
     85a:	7a 83       	std	Y+2, r23	; 0x02
     85c:	8b 83       	std	Y+3, r24	; 0x03
     85e:	9c 83       	std	Y+4, r25	; 0x04
     860:	ce 01       	movw	r24, r28
     862:	01 96       	adiw	r24, 0x01	; 1
     864:	be 01       	movw	r22, r28
     866:	6b 5f       	subi	r22, 0xFB	; 251
     868:	7f 4f       	sbci	r23, 0xFF	; 255
     86a:	0e 94 4f 05 	call	0xa9e	; 0xa9e <__unpack_f>
     86e:	8d 81       	ldd	r24, Y+5	; 0x05
     870:	82 30       	cpi	r24, 0x02	; 2
     872:	61 f1       	breq	.+88     	; 0x8cc <__stack+0x6d>
     874:	82 30       	cpi	r24, 0x02	; 2
     876:	50 f1       	brcs	.+84     	; 0x8cc <__stack+0x6d>
     878:	84 30       	cpi	r24, 0x04	; 4
     87a:	21 f4       	brne	.+8      	; 0x884 <__stack+0x25>
     87c:	8e 81       	ldd	r24, Y+6	; 0x06
     87e:	88 23       	and	r24, r24
     880:	51 f1       	breq	.+84     	; 0x8d6 <__stack+0x77>
     882:	2e c0       	rjmp	.+92     	; 0x8e0 <__stack+0x81>
     884:	2f 81       	ldd	r18, Y+7	; 0x07
     886:	38 85       	ldd	r19, Y+8	; 0x08
     888:	37 fd       	sbrc	r19, 7
     88a:	20 c0       	rjmp	.+64     	; 0x8cc <__stack+0x6d>
     88c:	6e 81       	ldd	r22, Y+6	; 0x06
     88e:	2f 31       	cpi	r18, 0x1F	; 31
     890:	31 05       	cpc	r19, r1
     892:	1c f0       	brlt	.+6      	; 0x89a <__stack+0x3b>
     894:	66 23       	and	r22, r22
     896:	f9 f0       	breq	.+62     	; 0x8d6 <__stack+0x77>
     898:	23 c0       	rjmp	.+70     	; 0x8e0 <__stack+0x81>
     89a:	8e e1       	ldi	r24, 0x1E	; 30
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	82 1b       	sub	r24, r18
     8a0:	93 0b       	sbc	r25, r19
     8a2:	29 85       	ldd	r18, Y+9	; 0x09
     8a4:	3a 85       	ldd	r19, Y+10	; 0x0a
     8a6:	4b 85       	ldd	r20, Y+11	; 0x0b
     8a8:	5c 85       	ldd	r21, Y+12	; 0x0c
     8aa:	04 c0       	rjmp	.+8      	; 0x8b4 <__stack+0x55>
     8ac:	56 95       	lsr	r21
     8ae:	47 95       	ror	r20
     8b0:	37 95       	ror	r19
     8b2:	27 95       	ror	r18
     8b4:	8a 95       	dec	r24
     8b6:	d2 f7       	brpl	.-12     	; 0x8ac <__stack+0x4d>
     8b8:	66 23       	and	r22, r22
     8ba:	b1 f0       	breq	.+44     	; 0x8e8 <__stack+0x89>
     8bc:	50 95       	com	r21
     8be:	40 95       	com	r20
     8c0:	30 95       	com	r19
     8c2:	21 95       	neg	r18
     8c4:	3f 4f       	sbci	r19, 0xFF	; 255
     8c6:	4f 4f       	sbci	r20, 0xFF	; 255
     8c8:	5f 4f       	sbci	r21, 0xFF	; 255
     8ca:	0e c0       	rjmp	.+28     	; 0x8e8 <__stack+0x89>
     8cc:	20 e0       	ldi	r18, 0x00	; 0
     8ce:	30 e0       	ldi	r19, 0x00	; 0
     8d0:	40 e0       	ldi	r20, 0x00	; 0
     8d2:	50 e0       	ldi	r21, 0x00	; 0
     8d4:	09 c0       	rjmp	.+18     	; 0x8e8 <__stack+0x89>
     8d6:	2f ef       	ldi	r18, 0xFF	; 255
     8d8:	3f ef       	ldi	r19, 0xFF	; 255
     8da:	4f ef       	ldi	r20, 0xFF	; 255
     8dc:	5f e7       	ldi	r21, 0x7F	; 127
     8de:	04 c0       	rjmp	.+8      	; 0x8e8 <__stack+0x89>
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	30 e0       	ldi	r19, 0x00	; 0
     8e4:	40 e0       	ldi	r20, 0x00	; 0
     8e6:	50 e8       	ldi	r21, 0x80	; 128
     8e8:	b9 01       	movw	r22, r18
     8ea:	ca 01       	movw	r24, r20
     8ec:	2c 96       	adiw	r28, 0x0c	; 12
     8ee:	e2 e0       	ldi	r30, 0x02	; 2
     8f0:	0c 94 dc 1c 	jmp	0x39b8	; 0x39b8 <__epilogue_restores__+0x20>

000008f4 <__pack_f>:
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	fc 01       	movw	r30, r24
     900:	e4 80       	ldd	r14, Z+4	; 0x04
     902:	f5 80       	ldd	r15, Z+5	; 0x05
     904:	06 81       	ldd	r16, Z+6	; 0x06
     906:	17 81       	ldd	r17, Z+7	; 0x07
     908:	d1 80       	ldd	r13, Z+1	; 0x01
     90a:	80 81       	ld	r24, Z
     90c:	82 30       	cpi	r24, 0x02	; 2
     90e:	48 f4       	brcc	.+18     	; 0x922 <__pack_f+0x2e>
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	a0 e1       	ldi	r26, 0x10	; 16
     916:	b0 e0       	ldi	r27, 0x00	; 0
     918:	e8 2a       	or	r14, r24
     91a:	f9 2a       	or	r15, r25
     91c:	0a 2b       	or	r16, r26
     91e:	1b 2b       	or	r17, r27
     920:	a5 c0       	rjmp	.+330    	; 0xa6c <__pack_f+0x178>
     922:	84 30       	cpi	r24, 0x04	; 4
     924:	09 f4       	brne	.+2      	; 0x928 <__pack_f+0x34>
     926:	9f c0       	rjmp	.+318    	; 0xa66 <__pack_f+0x172>
     928:	82 30       	cpi	r24, 0x02	; 2
     92a:	21 f4       	brne	.+8      	; 0x934 <__pack_f+0x40>
     92c:	ee 24       	eor	r14, r14
     92e:	ff 24       	eor	r15, r15
     930:	87 01       	movw	r16, r14
     932:	05 c0       	rjmp	.+10     	; 0x93e <__pack_f+0x4a>
     934:	e1 14       	cp	r14, r1
     936:	f1 04       	cpc	r15, r1
     938:	01 05       	cpc	r16, r1
     93a:	11 05       	cpc	r17, r1
     93c:	19 f4       	brne	.+6      	; 0x944 <__pack_f+0x50>
     93e:	e0 e0       	ldi	r30, 0x00	; 0
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	96 c0       	rjmp	.+300    	; 0xa70 <__pack_f+0x17c>
     944:	62 81       	ldd	r22, Z+2	; 0x02
     946:	73 81       	ldd	r23, Z+3	; 0x03
     948:	9f ef       	ldi	r25, 0xFF	; 255
     94a:	62 38       	cpi	r22, 0x82	; 130
     94c:	79 07       	cpc	r23, r25
     94e:	0c f0       	brlt	.+2      	; 0x952 <__pack_f+0x5e>
     950:	5b c0       	rjmp	.+182    	; 0xa08 <__pack_f+0x114>
     952:	22 e8       	ldi	r18, 0x82	; 130
     954:	3f ef       	ldi	r19, 0xFF	; 255
     956:	26 1b       	sub	r18, r22
     958:	37 0b       	sbc	r19, r23
     95a:	2a 31       	cpi	r18, 0x1A	; 26
     95c:	31 05       	cpc	r19, r1
     95e:	2c f0       	brlt	.+10     	; 0x96a <__pack_f+0x76>
     960:	20 e0       	ldi	r18, 0x00	; 0
     962:	30 e0       	ldi	r19, 0x00	; 0
     964:	40 e0       	ldi	r20, 0x00	; 0
     966:	50 e0       	ldi	r21, 0x00	; 0
     968:	2a c0       	rjmp	.+84     	; 0x9be <__pack_f+0xca>
     96a:	b8 01       	movw	r22, r16
     96c:	a7 01       	movw	r20, r14
     96e:	02 2e       	mov	r0, r18
     970:	04 c0       	rjmp	.+8      	; 0x97a <__pack_f+0x86>
     972:	76 95       	lsr	r23
     974:	67 95       	ror	r22
     976:	57 95       	ror	r21
     978:	47 95       	ror	r20
     97a:	0a 94       	dec	r0
     97c:	d2 f7       	brpl	.-12     	; 0x972 <__pack_f+0x7e>
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	a0 e0       	ldi	r26, 0x00	; 0
     984:	b0 e0       	ldi	r27, 0x00	; 0
     986:	04 c0       	rjmp	.+8      	; 0x990 <__pack_f+0x9c>
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	aa 1f       	adc	r26, r26
     98e:	bb 1f       	adc	r27, r27
     990:	2a 95       	dec	r18
     992:	d2 f7       	brpl	.-12     	; 0x988 <__pack_f+0x94>
     994:	01 97       	sbiw	r24, 0x01	; 1
     996:	a1 09       	sbc	r26, r1
     998:	b1 09       	sbc	r27, r1
     99a:	8e 21       	and	r24, r14
     99c:	9f 21       	and	r25, r15
     99e:	a0 23       	and	r26, r16
     9a0:	b1 23       	and	r27, r17
     9a2:	00 97       	sbiw	r24, 0x00	; 0
     9a4:	a1 05       	cpc	r26, r1
     9a6:	b1 05       	cpc	r27, r1
     9a8:	21 f0       	breq	.+8      	; 0x9b2 <__pack_f+0xbe>
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	a0 e0       	ldi	r26, 0x00	; 0
     9b0:	b0 e0       	ldi	r27, 0x00	; 0
     9b2:	9a 01       	movw	r18, r20
     9b4:	ab 01       	movw	r20, r22
     9b6:	28 2b       	or	r18, r24
     9b8:	39 2b       	or	r19, r25
     9ba:	4a 2b       	or	r20, r26
     9bc:	5b 2b       	or	r21, r27
     9be:	da 01       	movw	r26, r20
     9c0:	c9 01       	movw	r24, r18
     9c2:	8f 77       	andi	r24, 0x7F	; 127
     9c4:	90 70       	andi	r25, 0x00	; 0
     9c6:	a0 70       	andi	r26, 0x00	; 0
     9c8:	b0 70       	andi	r27, 0x00	; 0
     9ca:	80 34       	cpi	r24, 0x40	; 64
     9cc:	91 05       	cpc	r25, r1
     9ce:	a1 05       	cpc	r26, r1
     9d0:	b1 05       	cpc	r27, r1
     9d2:	39 f4       	brne	.+14     	; 0x9e2 <__pack_f+0xee>
     9d4:	27 ff       	sbrs	r18, 7
     9d6:	09 c0       	rjmp	.+18     	; 0x9ea <__pack_f+0xf6>
     9d8:	20 5c       	subi	r18, 0xC0	; 192
     9da:	3f 4f       	sbci	r19, 0xFF	; 255
     9dc:	4f 4f       	sbci	r20, 0xFF	; 255
     9de:	5f 4f       	sbci	r21, 0xFF	; 255
     9e0:	04 c0       	rjmp	.+8      	; 0x9ea <__pack_f+0xf6>
     9e2:	21 5c       	subi	r18, 0xC1	; 193
     9e4:	3f 4f       	sbci	r19, 0xFF	; 255
     9e6:	4f 4f       	sbci	r20, 0xFF	; 255
     9e8:	5f 4f       	sbci	r21, 0xFF	; 255
     9ea:	e0 e0       	ldi	r30, 0x00	; 0
     9ec:	f0 e0       	ldi	r31, 0x00	; 0
     9ee:	20 30       	cpi	r18, 0x00	; 0
     9f0:	a0 e0       	ldi	r26, 0x00	; 0
     9f2:	3a 07       	cpc	r19, r26
     9f4:	a0 e0       	ldi	r26, 0x00	; 0
     9f6:	4a 07       	cpc	r20, r26
     9f8:	a0 e4       	ldi	r26, 0x40	; 64
     9fa:	5a 07       	cpc	r21, r26
     9fc:	10 f0       	brcs	.+4      	; 0xa02 <__pack_f+0x10e>
     9fe:	e1 e0       	ldi	r30, 0x01	; 1
     a00:	f0 e0       	ldi	r31, 0x00	; 0
     a02:	79 01       	movw	r14, r18
     a04:	8a 01       	movw	r16, r20
     a06:	27 c0       	rjmp	.+78     	; 0xa56 <__pack_f+0x162>
     a08:	60 38       	cpi	r22, 0x80	; 128
     a0a:	71 05       	cpc	r23, r1
     a0c:	64 f5       	brge	.+88     	; 0xa66 <__pack_f+0x172>
     a0e:	fb 01       	movw	r30, r22
     a10:	e1 58       	subi	r30, 0x81	; 129
     a12:	ff 4f       	sbci	r31, 0xFF	; 255
     a14:	d8 01       	movw	r26, r16
     a16:	c7 01       	movw	r24, r14
     a18:	8f 77       	andi	r24, 0x7F	; 127
     a1a:	90 70       	andi	r25, 0x00	; 0
     a1c:	a0 70       	andi	r26, 0x00	; 0
     a1e:	b0 70       	andi	r27, 0x00	; 0
     a20:	80 34       	cpi	r24, 0x40	; 64
     a22:	91 05       	cpc	r25, r1
     a24:	a1 05       	cpc	r26, r1
     a26:	b1 05       	cpc	r27, r1
     a28:	39 f4       	brne	.+14     	; 0xa38 <__pack_f+0x144>
     a2a:	e7 fe       	sbrs	r14, 7
     a2c:	0d c0       	rjmp	.+26     	; 0xa48 <__pack_f+0x154>
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	a0 e0       	ldi	r26, 0x00	; 0
     a34:	b0 e0       	ldi	r27, 0x00	; 0
     a36:	04 c0       	rjmp	.+8      	; 0xa40 <__pack_f+0x14c>
     a38:	8f e3       	ldi	r24, 0x3F	; 63
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	a0 e0       	ldi	r26, 0x00	; 0
     a3e:	b0 e0       	ldi	r27, 0x00	; 0
     a40:	e8 0e       	add	r14, r24
     a42:	f9 1e       	adc	r15, r25
     a44:	0a 1f       	adc	r16, r26
     a46:	1b 1f       	adc	r17, r27
     a48:	17 ff       	sbrs	r17, 7
     a4a:	05 c0       	rjmp	.+10     	; 0xa56 <__pack_f+0x162>
     a4c:	16 95       	lsr	r17
     a4e:	07 95       	ror	r16
     a50:	f7 94       	ror	r15
     a52:	e7 94       	ror	r14
     a54:	31 96       	adiw	r30, 0x01	; 1
     a56:	87 e0       	ldi	r24, 0x07	; 7
     a58:	16 95       	lsr	r17
     a5a:	07 95       	ror	r16
     a5c:	f7 94       	ror	r15
     a5e:	e7 94       	ror	r14
     a60:	8a 95       	dec	r24
     a62:	d1 f7       	brne	.-12     	; 0xa58 <__pack_f+0x164>
     a64:	05 c0       	rjmp	.+10     	; 0xa70 <__pack_f+0x17c>
     a66:	ee 24       	eor	r14, r14
     a68:	ff 24       	eor	r15, r15
     a6a:	87 01       	movw	r16, r14
     a6c:	ef ef       	ldi	r30, 0xFF	; 255
     a6e:	f0 e0       	ldi	r31, 0x00	; 0
     a70:	6e 2f       	mov	r22, r30
     a72:	67 95       	ror	r22
     a74:	66 27       	eor	r22, r22
     a76:	67 95       	ror	r22
     a78:	90 2f       	mov	r25, r16
     a7a:	9f 77       	andi	r25, 0x7F	; 127
     a7c:	d7 94       	ror	r13
     a7e:	dd 24       	eor	r13, r13
     a80:	d7 94       	ror	r13
     a82:	8e 2f       	mov	r24, r30
     a84:	86 95       	lsr	r24
     a86:	49 2f       	mov	r20, r25
     a88:	46 2b       	or	r20, r22
     a8a:	58 2f       	mov	r21, r24
     a8c:	5d 29       	or	r21, r13
     a8e:	b7 01       	movw	r22, r14
     a90:	ca 01       	movw	r24, r20
     a92:	1f 91       	pop	r17
     a94:	0f 91       	pop	r16
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	df 90       	pop	r13
     a9c:	08 95       	ret

00000a9e <__unpack_f>:
     a9e:	fc 01       	movw	r30, r24
     aa0:	db 01       	movw	r26, r22
     aa2:	40 81       	ld	r20, Z
     aa4:	51 81       	ldd	r21, Z+1	; 0x01
     aa6:	22 81       	ldd	r18, Z+2	; 0x02
     aa8:	62 2f       	mov	r22, r18
     aaa:	6f 77       	andi	r22, 0x7F	; 127
     aac:	70 e0       	ldi	r23, 0x00	; 0
     aae:	22 1f       	adc	r18, r18
     ab0:	22 27       	eor	r18, r18
     ab2:	22 1f       	adc	r18, r18
     ab4:	93 81       	ldd	r25, Z+3	; 0x03
     ab6:	89 2f       	mov	r24, r25
     ab8:	88 0f       	add	r24, r24
     aba:	82 2b       	or	r24, r18
     abc:	28 2f       	mov	r18, r24
     abe:	30 e0       	ldi	r19, 0x00	; 0
     ac0:	99 1f       	adc	r25, r25
     ac2:	99 27       	eor	r25, r25
     ac4:	99 1f       	adc	r25, r25
     ac6:	11 96       	adiw	r26, 0x01	; 1
     ac8:	9c 93       	st	X, r25
     aca:	11 97       	sbiw	r26, 0x01	; 1
     acc:	21 15       	cp	r18, r1
     ace:	31 05       	cpc	r19, r1
     ad0:	a9 f5       	brne	.+106    	; 0xb3c <__unpack_f+0x9e>
     ad2:	41 15       	cp	r20, r1
     ad4:	51 05       	cpc	r21, r1
     ad6:	61 05       	cpc	r22, r1
     ad8:	71 05       	cpc	r23, r1
     ada:	11 f4       	brne	.+4      	; 0xae0 <__unpack_f+0x42>
     adc:	82 e0       	ldi	r24, 0x02	; 2
     ade:	37 c0       	rjmp	.+110    	; 0xb4e <__unpack_f+0xb0>
     ae0:	82 e8       	ldi	r24, 0x82	; 130
     ae2:	9f ef       	ldi	r25, 0xFF	; 255
     ae4:	13 96       	adiw	r26, 0x03	; 3
     ae6:	9c 93       	st	X, r25
     ae8:	8e 93       	st	-X, r24
     aea:	12 97       	sbiw	r26, 0x02	; 2
     aec:	9a 01       	movw	r18, r20
     aee:	ab 01       	movw	r20, r22
     af0:	67 e0       	ldi	r22, 0x07	; 7
     af2:	22 0f       	add	r18, r18
     af4:	33 1f       	adc	r19, r19
     af6:	44 1f       	adc	r20, r20
     af8:	55 1f       	adc	r21, r21
     afa:	6a 95       	dec	r22
     afc:	d1 f7       	brne	.-12     	; 0xaf2 <__unpack_f+0x54>
     afe:	83 e0       	ldi	r24, 0x03	; 3
     b00:	8c 93       	st	X, r24
     b02:	0d c0       	rjmp	.+26     	; 0xb1e <__unpack_f+0x80>
     b04:	22 0f       	add	r18, r18
     b06:	33 1f       	adc	r19, r19
     b08:	44 1f       	adc	r20, r20
     b0a:	55 1f       	adc	r21, r21
     b0c:	12 96       	adiw	r26, 0x02	; 2
     b0e:	8d 91       	ld	r24, X+
     b10:	9c 91       	ld	r25, X
     b12:	13 97       	sbiw	r26, 0x03	; 3
     b14:	01 97       	sbiw	r24, 0x01	; 1
     b16:	13 96       	adiw	r26, 0x03	; 3
     b18:	9c 93       	st	X, r25
     b1a:	8e 93       	st	-X, r24
     b1c:	12 97       	sbiw	r26, 0x02	; 2
     b1e:	20 30       	cpi	r18, 0x00	; 0
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	38 07       	cpc	r19, r24
     b24:	80 e0       	ldi	r24, 0x00	; 0
     b26:	48 07       	cpc	r20, r24
     b28:	80 e4       	ldi	r24, 0x40	; 64
     b2a:	58 07       	cpc	r21, r24
     b2c:	58 f3       	brcs	.-42     	; 0xb04 <__unpack_f+0x66>
     b2e:	14 96       	adiw	r26, 0x04	; 4
     b30:	2d 93       	st	X+, r18
     b32:	3d 93       	st	X+, r19
     b34:	4d 93       	st	X+, r20
     b36:	5c 93       	st	X, r21
     b38:	17 97       	sbiw	r26, 0x07	; 7
     b3a:	08 95       	ret
     b3c:	2f 3f       	cpi	r18, 0xFF	; 255
     b3e:	31 05       	cpc	r19, r1
     b40:	79 f4       	brne	.+30     	; 0xb60 <__unpack_f+0xc2>
     b42:	41 15       	cp	r20, r1
     b44:	51 05       	cpc	r21, r1
     b46:	61 05       	cpc	r22, r1
     b48:	71 05       	cpc	r23, r1
     b4a:	19 f4       	brne	.+6      	; 0xb52 <__unpack_f+0xb4>
     b4c:	84 e0       	ldi	r24, 0x04	; 4
     b4e:	8c 93       	st	X, r24
     b50:	08 95       	ret
     b52:	64 ff       	sbrs	r22, 4
     b54:	03 c0       	rjmp	.+6      	; 0xb5c <__unpack_f+0xbe>
     b56:	81 e0       	ldi	r24, 0x01	; 1
     b58:	8c 93       	st	X, r24
     b5a:	12 c0       	rjmp	.+36     	; 0xb80 <__unpack_f+0xe2>
     b5c:	1c 92       	st	X, r1
     b5e:	10 c0       	rjmp	.+32     	; 0xb80 <__unpack_f+0xe2>
     b60:	2f 57       	subi	r18, 0x7F	; 127
     b62:	30 40       	sbci	r19, 0x00	; 0
     b64:	13 96       	adiw	r26, 0x03	; 3
     b66:	3c 93       	st	X, r19
     b68:	2e 93       	st	-X, r18
     b6a:	12 97       	sbiw	r26, 0x02	; 2
     b6c:	83 e0       	ldi	r24, 0x03	; 3
     b6e:	8c 93       	st	X, r24
     b70:	87 e0       	ldi	r24, 0x07	; 7
     b72:	44 0f       	add	r20, r20
     b74:	55 1f       	adc	r21, r21
     b76:	66 1f       	adc	r22, r22
     b78:	77 1f       	adc	r23, r23
     b7a:	8a 95       	dec	r24
     b7c:	d1 f7       	brne	.-12     	; 0xb72 <__unpack_f+0xd4>
     b7e:	70 64       	ori	r23, 0x40	; 64
     b80:	14 96       	adiw	r26, 0x04	; 4
     b82:	4d 93       	st	X+, r20
     b84:	5d 93       	st	X+, r21
     b86:	6d 93       	st	X+, r22
     b88:	7c 93       	st	X, r23
     b8a:	17 97       	sbiw	r26, 0x07	; 7
     b8c:	08 95       	ret

00000b8e <__fpcmp_parts_f>:
     b8e:	1f 93       	push	r17
     b90:	dc 01       	movw	r26, r24
     b92:	fb 01       	movw	r30, r22
     b94:	9c 91       	ld	r25, X
     b96:	92 30       	cpi	r25, 0x02	; 2
     b98:	08 f4       	brcc	.+2      	; 0xb9c <__fpcmp_parts_f+0xe>
     b9a:	47 c0       	rjmp	.+142    	; 0xc2a <__fpcmp_parts_f+0x9c>
     b9c:	80 81       	ld	r24, Z
     b9e:	82 30       	cpi	r24, 0x02	; 2
     ba0:	08 f4       	brcc	.+2      	; 0xba4 <__fpcmp_parts_f+0x16>
     ba2:	43 c0       	rjmp	.+134    	; 0xc2a <__fpcmp_parts_f+0x9c>
     ba4:	94 30       	cpi	r25, 0x04	; 4
     ba6:	51 f4       	brne	.+20     	; 0xbbc <__fpcmp_parts_f+0x2e>
     ba8:	11 96       	adiw	r26, 0x01	; 1
     baa:	1c 91       	ld	r17, X
     bac:	84 30       	cpi	r24, 0x04	; 4
     bae:	99 f5       	brne	.+102    	; 0xc16 <__fpcmp_parts_f+0x88>
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	68 2f       	mov	r22, r24
     bb4:	70 e0       	ldi	r23, 0x00	; 0
     bb6:	61 1b       	sub	r22, r17
     bb8:	71 09       	sbc	r23, r1
     bba:	3f c0       	rjmp	.+126    	; 0xc3a <__fpcmp_parts_f+0xac>
     bbc:	84 30       	cpi	r24, 0x04	; 4
     bbe:	21 f0       	breq	.+8      	; 0xbc8 <__fpcmp_parts_f+0x3a>
     bc0:	92 30       	cpi	r25, 0x02	; 2
     bc2:	31 f4       	brne	.+12     	; 0xbd0 <__fpcmp_parts_f+0x42>
     bc4:	82 30       	cpi	r24, 0x02	; 2
     bc6:	b9 f1       	breq	.+110    	; 0xc36 <__fpcmp_parts_f+0xa8>
     bc8:	81 81       	ldd	r24, Z+1	; 0x01
     bca:	88 23       	and	r24, r24
     bcc:	89 f1       	breq	.+98     	; 0xc30 <__fpcmp_parts_f+0xa2>
     bce:	2d c0       	rjmp	.+90     	; 0xc2a <__fpcmp_parts_f+0x9c>
     bd0:	11 96       	adiw	r26, 0x01	; 1
     bd2:	1c 91       	ld	r17, X
     bd4:	11 97       	sbiw	r26, 0x01	; 1
     bd6:	82 30       	cpi	r24, 0x02	; 2
     bd8:	f1 f0       	breq	.+60     	; 0xc16 <__fpcmp_parts_f+0x88>
     bda:	81 81       	ldd	r24, Z+1	; 0x01
     bdc:	18 17       	cp	r17, r24
     bde:	d9 f4       	brne	.+54     	; 0xc16 <__fpcmp_parts_f+0x88>
     be0:	12 96       	adiw	r26, 0x02	; 2
     be2:	2d 91       	ld	r18, X+
     be4:	3c 91       	ld	r19, X
     be6:	13 97       	sbiw	r26, 0x03	; 3
     be8:	82 81       	ldd	r24, Z+2	; 0x02
     bea:	93 81       	ldd	r25, Z+3	; 0x03
     bec:	82 17       	cp	r24, r18
     bee:	93 07       	cpc	r25, r19
     bf0:	94 f0       	brlt	.+36     	; 0xc16 <__fpcmp_parts_f+0x88>
     bf2:	28 17       	cp	r18, r24
     bf4:	39 07       	cpc	r19, r25
     bf6:	bc f0       	brlt	.+46     	; 0xc26 <__fpcmp_parts_f+0x98>
     bf8:	14 96       	adiw	r26, 0x04	; 4
     bfa:	8d 91       	ld	r24, X+
     bfc:	9d 91       	ld	r25, X+
     bfe:	0d 90       	ld	r0, X+
     c00:	bc 91       	ld	r27, X
     c02:	a0 2d       	mov	r26, r0
     c04:	24 81       	ldd	r18, Z+4	; 0x04
     c06:	35 81       	ldd	r19, Z+5	; 0x05
     c08:	46 81       	ldd	r20, Z+6	; 0x06
     c0a:	57 81       	ldd	r21, Z+7	; 0x07
     c0c:	28 17       	cp	r18, r24
     c0e:	39 07       	cpc	r19, r25
     c10:	4a 07       	cpc	r20, r26
     c12:	5b 07       	cpc	r21, r27
     c14:	18 f4       	brcc	.+6      	; 0xc1c <__fpcmp_parts_f+0x8e>
     c16:	11 23       	and	r17, r17
     c18:	41 f0       	breq	.+16     	; 0xc2a <__fpcmp_parts_f+0x9c>
     c1a:	0a c0       	rjmp	.+20     	; 0xc30 <__fpcmp_parts_f+0xa2>
     c1c:	82 17       	cp	r24, r18
     c1e:	93 07       	cpc	r25, r19
     c20:	a4 07       	cpc	r26, r20
     c22:	b5 07       	cpc	r27, r21
     c24:	40 f4       	brcc	.+16     	; 0xc36 <__fpcmp_parts_f+0xa8>
     c26:	11 23       	and	r17, r17
     c28:	19 f0       	breq	.+6      	; 0xc30 <__fpcmp_parts_f+0xa2>
     c2a:	61 e0       	ldi	r22, 0x01	; 1
     c2c:	70 e0       	ldi	r23, 0x00	; 0
     c2e:	05 c0       	rjmp	.+10     	; 0xc3a <__fpcmp_parts_f+0xac>
     c30:	6f ef       	ldi	r22, 0xFF	; 255
     c32:	7f ef       	ldi	r23, 0xFF	; 255
     c34:	02 c0       	rjmp	.+4      	; 0xc3a <__fpcmp_parts_f+0xac>
     c36:	60 e0       	ldi	r22, 0x00	; 0
     c38:	70 e0       	ldi	r23, 0x00	; 0
     c3a:	cb 01       	movw	r24, r22
     c3c:	1f 91       	pop	r17
     c3e:	08 95       	ret

00000c40 <UART_init>:
 * Functional responsible for Initialize the UART device by:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType *Config_Ptr) {
     c40:	df 93       	push	r29
     c42:	cf 93       	push	r28
     c44:	00 d0       	rcall	.+0      	; 0xc46 <UART_init+0x6>
     c46:	00 d0       	rcall	.+0      	; 0xc48 <UART_init+0x8>
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	9c 83       	std	Y+4, r25	; 0x04
     c4e:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
     c50:	1a 82       	std	Y+2, r1	; 0x02
     c52:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	UCSRA = (1 << U2X);
     c54:	eb e2       	ldi	r30, 0x2B	; 43
     c56:	f0 e0       	ldi	r31, 0x00	; 0
     c58:	82 e0       	ldi	r24, 0x02	; 2
     c5a:	80 83       	st	Z, r24
	 * RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 * UCSZ2 = 0 For 8-bit data mode
	 * RXB8 & TXB8 not used for 8-bit data mode
	 ***********************************************************************/
	UCSRB = (1 << RXEN) | (1 << TXEN);
     c5c:	ea e2       	ldi	r30, 0x2A	; 42
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	88 e1       	ldi	r24, 0x18	; 24
     c62:	80 83       	st	Z, r24
	 * UPM1:0  = 00 Disable parity bit
	 * USBS    = 0 One stop bit
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 ***********************************************************************/
	UCSRC = (1 << URSEL);
     c64:	e0 e4       	ldi	r30, 0x40	; 64
     c66:	f0 e0       	ldi	r31, 0x00	; 0
     c68:	80 e8       	ldi	r24, 0x80	; 128
     c6a:	80 83       	st	Z, r24
	UCSRC = (UCSRC & 0xF9) | ((Config_Ptr->bit_data) << UCSZ0);
     c6c:	a0 e4       	ldi	r26, 0x40	; 64
     c6e:	b0 e0       	ldi	r27, 0x00	; 0
     c70:	e0 e4       	ldi	r30, 0x40	; 64
     c72:	f0 e0       	ldi	r31, 0x00	; 0
     c74:	80 81       	ld	r24, Z
     c76:	28 2f       	mov	r18, r24
     c78:	29 7f       	andi	r18, 0xF9	; 249
     c7a:	eb 81       	ldd	r30, Y+3	; 0x03
     c7c:	fc 81       	ldd	r31, Y+4	; 0x04
     c7e:	80 81       	ld	r24, Z
     c80:	88 2f       	mov	r24, r24
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	88 0f       	add	r24, r24
     c86:	99 1f       	adc	r25, r25
     c88:	82 2b       	or	r24, r18
     c8a:	8c 93       	st	X, r24
	UCSRC = (UCSRC & 0xCF) | ((Config_Ptr->parity) << UPM0);
     c8c:	a0 e4       	ldi	r26, 0x40	; 64
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	e0 e4       	ldi	r30, 0x40	; 64
     c92:	f0 e0       	ldi	r31, 0x00	; 0
     c94:	80 81       	ld	r24, Z
     c96:	28 2f       	mov	r18, r24
     c98:	2f 7c       	andi	r18, 0xCF	; 207
     c9a:	eb 81       	ldd	r30, Y+3	; 0x03
     c9c:	fc 81       	ldd	r31, Y+4	; 0x04
     c9e:	81 81       	ldd	r24, Z+1	; 0x01
     ca0:	88 2f       	mov	r24, r24
     ca2:	90 e0       	ldi	r25, 0x00	; 0
     ca4:	82 95       	swap	r24
     ca6:	92 95       	swap	r25
     ca8:	90 7f       	andi	r25, 0xF0	; 240
     caa:	98 27       	eor	r25, r24
     cac:	80 7f       	andi	r24, 0xF0	; 240
     cae:	98 27       	eor	r25, r24
     cb0:	82 2b       	or	r24, r18
     cb2:	8c 93       	st	X, r24
	UCSRC = (UCSRC & 0xF7) | ((Config_Ptr->stop_bit) << USBS);
     cb4:	a0 e4       	ldi	r26, 0x40	; 64
     cb6:	b0 e0       	ldi	r27, 0x00	; 0
     cb8:	e0 e4       	ldi	r30, 0x40	; 64
     cba:	f0 e0       	ldi	r31, 0x00	; 0
     cbc:	80 81       	ld	r24, Z
     cbe:	28 2f       	mov	r18, r24
     cc0:	27 7f       	andi	r18, 0xF7	; 247
     cc2:	eb 81       	ldd	r30, Y+3	; 0x03
     cc4:	fc 81       	ldd	r31, Y+4	; 0x04
     cc6:	82 81       	ldd	r24, Z+2	; 0x02
     cc8:	88 2f       	mov	r24, r24
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	88 0f       	add	r24, r24
     cce:	99 1f       	adc	r25, r25
     cd0:	88 0f       	add	r24, r24
     cd2:	99 1f       	adc	r25, r25
     cd4:	88 0f       	add	r24, r24
     cd6:	99 1f       	adc	r25, r25
     cd8:	82 2b       	or	r24, r18
     cda:	8c 93       	st	X, r24

	/* Calculate the UBRR register value */
	ubrr_value = (uint16) (((F_CPU / (Config_Ptr->baud_rate * 8UL))) - 1);
     cdc:	eb 81       	ldd	r30, Y+3	; 0x03
     cde:	fc 81       	ldd	r31, Y+4	; 0x04
     ce0:	83 81       	ldd	r24, Z+3	; 0x03
     ce2:	94 81       	ldd	r25, Z+4	; 0x04
     ce4:	a5 81       	ldd	r26, Z+5	; 0x05
     ce6:	b6 81       	ldd	r27, Z+6	; 0x06
     ce8:	88 0f       	add	r24, r24
     cea:	99 1f       	adc	r25, r25
     cec:	aa 1f       	adc	r26, r26
     cee:	bb 1f       	adc	r27, r27
     cf0:	88 0f       	add	r24, r24
     cf2:	99 1f       	adc	r25, r25
     cf4:	aa 1f       	adc	r26, r26
     cf6:	bb 1f       	adc	r27, r27
     cf8:	88 0f       	add	r24, r24
     cfa:	99 1f       	adc	r25, r25
     cfc:	aa 1f       	adc	r26, r26
     cfe:	bb 1f       	adc	r27, r27
     d00:	9c 01       	movw	r18, r24
     d02:	ad 01       	movw	r20, r26
     d04:	80 e0       	ldi	r24, 0x00	; 0
     d06:	92 e1       	ldi	r25, 0x12	; 18
     d08:	aa e7       	ldi	r26, 0x7A	; 122
     d0a:	b0 e0       	ldi	r27, 0x00	; 0
     d0c:	bc 01       	movw	r22, r24
     d0e:	cd 01       	movw	r24, r26
     d10:	0e 94 8e 1c 	call	0x391c	; 0x391c <__udivmodsi4>
     d14:	da 01       	movw	r26, r20
     d16:	c9 01       	movw	r24, r18
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	9a 83       	std	Y+2, r25	; 0x02
     d1c:	89 83       	std	Y+1, r24	; 0x01

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value >> 8;
     d1e:	e0 e4       	ldi	r30, 0x40	; 64
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	89 81       	ldd	r24, Y+1	; 0x01
     d24:	9a 81       	ldd	r25, Y+2	; 0x02
     d26:	89 2f       	mov	r24, r25
     d28:	99 27       	eor	r25, r25
     d2a:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
     d2c:	e9 e2       	ldi	r30, 0x29	; 41
     d2e:	f0 e0       	ldi	r31, 0x00	; 0
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	80 83       	st	Z, r24
}
     d34:	0f 90       	pop	r0
     d36:	0f 90       	pop	r0
     d38:	0f 90       	pop	r0
     d3a:	0f 90       	pop	r0
     d3c:	cf 91       	pop	r28
     d3e:	df 91       	pop	r29
     d40:	08 95       	ret

00000d42 <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
     d42:	df 93       	push	r29
     d44:	cf 93       	push	r28
     d46:	0f 92       	push	r0
     d48:	cd b7       	in	r28, 0x3d	; 61
     d4a:	de b7       	in	r29, 0x3e	; 62
     d4c:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
     d4e:	eb e2       	ldi	r30, 0x2B	; 43
     d50:	f0 e0       	ldi	r31, 0x00	; 0
     d52:	80 81       	ld	r24, Z
     d54:	88 2f       	mov	r24, r24
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	80 72       	andi	r24, 0x20	; 32
     d5a:	90 70       	andi	r25, 0x00	; 0
     d5c:	00 97       	sbiw	r24, 0x00	; 0
     d5e:	b9 f3       	breq	.-18     	; 0xd4e <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
     d60:	ec e2       	ldi	r30, 0x2C	; 44
     d62:	f0 e0       	ldi	r31, 0x00	; 0
     d64:	89 81       	ldd	r24, Y+1	; 0x01
     d66:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	*******************************************************************/
}
     d68:	0f 90       	pop	r0
     d6a:	cf 91       	pop	r28
     d6c:	df 91       	pop	r29
     d6e:	08 95       	ret

00000d70 <UART_recieveByte>:
 * Description :
 * Functional responsible for receive byte from another UART device by polling.
 */

uint8 UART_recieveByte(void)
{
     d70:	df 93       	push	r29
     d72:	cf 93       	push	r28
     d74:	cd b7       	in	r28, 0x3d	; 61
     d76:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
     d78:	eb e2       	ldi	r30, 0x2B	; 43
     d7a:	f0 e0       	ldi	r31, 0x00	; 0
     d7c:	80 81       	ld	r24, Z
     d7e:	88 23       	and	r24, r24
     d80:	dc f7       	brge	.-10     	; 0xd78 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
    return UDR;
     d82:	ec e2       	ldi	r30, 0x2C	; 44
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	80 81       	ld	r24, Z
}
     d88:	cf 91       	pop	r28
     d8a:	df 91       	pop	r29
     d8c:	08 95       	ret

00000d8e <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
     d8e:	df 93       	push	r29
     d90:	cf 93       	push	r28
     d92:	00 d0       	rcall	.+0      	; 0xd94 <UART_sendString+0x6>
     d94:	0f 92       	push	r0
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
     d9a:	9b 83       	std	Y+3, r25	; 0x03
     d9c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     d9e:	19 82       	std	Y+1, r1	; 0x01
     da0:	0e c0       	rjmp	.+28     	; 0xdbe <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
     da2:	89 81       	ldd	r24, Y+1	; 0x01
     da4:	28 2f       	mov	r18, r24
     da6:	30 e0       	ldi	r19, 0x00	; 0
     da8:	8a 81       	ldd	r24, Y+2	; 0x02
     daa:	9b 81       	ldd	r25, Y+3	; 0x03
     dac:	fc 01       	movw	r30, r24
     dae:	e2 0f       	add	r30, r18
     db0:	f3 1f       	adc	r31, r19
     db2:	80 81       	ld	r24, Z
     db4:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
		i++;
     db8:	89 81       	ldd	r24, Y+1	; 0x01
     dba:	8f 5f       	subi	r24, 0xFF	; 255
     dbc:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	28 2f       	mov	r18, r24
     dc2:	30 e0       	ldi	r19, 0x00	; 0
     dc4:	8a 81       	ldd	r24, Y+2	; 0x02
     dc6:	9b 81       	ldd	r25, Y+3	; 0x03
     dc8:	fc 01       	movw	r30, r24
     dca:	e2 0f       	add	r30, r18
     dcc:	f3 1f       	adc	r31, r19
     dce:	80 81       	ld	r24, Z
     dd0:	88 23       	and	r24, r24
     dd2:	39 f7       	brne	.-50     	; 0xda2 <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}
	*******************************************************************/
}
     dd4:	0f 90       	pop	r0
     dd6:	0f 90       	pop	r0
     dd8:	0f 90       	pop	r0
     dda:	cf 91       	pop	r28
     ddc:	df 91       	pop	r29
     dde:	08 95       	ret

00000de0 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
     de0:	0f 93       	push	r16
     de2:	1f 93       	push	r17
     de4:	df 93       	push	r29
     de6:	cf 93       	push	r28
     de8:	00 d0       	rcall	.+0      	; 0xdea <UART_receiveString+0xa>
     dea:	0f 92       	push	r0
     dec:	cd b7       	in	r28, 0x3d	; 61
     dee:	de b7       	in	r29, 0x3e	; 62
     df0:	9b 83       	std	Y+3, r25	; 0x03
     df2:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     df4:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
     df6:	89 81       	ldd	r24, Y+1	; 0x01
     df8:	28 2f       	mov	r18, r24
     dfa:	30 e0       	ldi	r19, 0x00	; 0
     dfc:	8a 81       	ldd	r24, Y+2	; 0x02
     dfe:	9b 81       	ldd	r25, Y+3	; 0x03
     e00:	8c 01       	movw	r16, r24
     e02:	02 0f       	add	r16, r18
     e04:	13 1f       	adc	r17, r19
     e06:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
     e0a:	f8 01       	movw	r30, r16
     e0c:	80 83       	st	Z, r24
     e0e:	0f c0       	rjmp	.+30     	; 0xe2e <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
     e10:	89 81       	ldd	r24, Y+1	; 0x01
     e12:	8f 5f       	subi	r24, 0xFF	; 255
     e14:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	28 2f       	mov	r18, r24
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	9b 81       	ldd	r25, Y+3	; 0x03
     e20:	8c 01       	movw	r16, r24
     e22:	02 0f       	add	r16, r18
     e24:	13 1f       	adc	r17, r19
     e26:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
     e2a:	f8 01       	movw	r30, r16
     e2c:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
     e2e:	89 81       	ldd	r24, Y+1	; 0x01
     e30:	28 2f       	mov	r18, r24
     e32:	30 e0       	ldi	r19, 0x00	; 0
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	9b 81       	ldd	r25, Y+3	; 0x03
     e38:	fc 01       	movw	r30, r24
     e3a:	e2 0f       	add	r30, r18
     e3c:	f3 1f       	adc	r31, r19
     e3e:	80 81       	ld	r24, Z
     e40:	83 32       	cpi	r24, 0x23	; 35
     e42:	31 f7       	brne	.-52     	; 0xe10 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
     e44:	89 81       	ldd	r24, Y+1	; 0x01
     e46:	28 2f       	mov	r18, r24
     e48:	30 e0       	ldi	r19, 0x00	; 0
     e4a:	8a 81       	ldd	r24, Y+2	; 0x02
     e4c:	9b 81       	ldd	r25, Y+3	; 0x03
     e4e:	fc 01       	movw	r30, r24
     e50:	e2 0f       	add	r30, r18
     e52:	f3 1f       	adc	r31, r19
     e54:	10 82       	st	Z, r1
}
     e56:	0f 90       	pop	r0
     e58:	0f 90       	pop	r0
     e5a:	0f 90       	pop	r0
     e5c:	cf 91       	pop	r28
     e5e:	df 91       	pop	r29
     e60:	1f 91       	pop	r17
     e62:	0f 91       	pop	r16
     e64:	08 95       	ret

00000e66 <__vector_9>:
static volatile void (*g_callBackPtr)(void) = NULL_PTR;

/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/
ISR(TIMER1_OVF_vect) {
     e66:	1f 92       	push	r1
     e68:	0f 92       	push	r0
     e6a:	0f b6       	in	r0, 0x3f	; 63
     e6c:	0f 92       	push	r0
     e6e:	11 24       	eor	r1, r1
     e70:	2f 93       	push	r18
     e72:	3f 93       	push	r19
     e74:	4f 93       	push	r20
     e76:	5f 93       	push	r21
     e78:	6f 93       	push	r22
     e7a:	7f 93       	push	r23
     e7c:	8f 93       	push	r24
     e7e:	9f 93       	push	r25
     e80:	af 93       	push	r26
     e82:	bf 93       	push	r27
     e84:	ef 93       	push	r30
     e86:	ff 93       	push	r31
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	cd b7       	in	r28, 0x3d	; 61
     e8e:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     e90:	80 91 28 01 	lds	r24, 0x0128
     e94:	90 91 29 01 	lds	r25, 0x0129
     e98:	00 97       	sbiw	r24, 0x00	; 0
     e9a:	29 f0       	breq	.+10     	; 0xea6 <__vector_9+0x40>
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     e9c:	e0 91 28 01 	lds	r30, 0x0128
     ea0:	f0 91 29 01 	lds	r31, 0x0129
     ea4:	09 95       	icall
	}
}
     ea6:	cf 91       	pop	r28
     ea8:	df 91       	pop	r29
     eaa:	ff 91       	pop	r31
     eac:	ef 91       	pop	r30
     eae:	bf 91       	pop	r27
     eb0:	af 91       	pop	r26
     eb2:	9f 91       	pop	r25
     eb4:	8f 91       	pop	r24
     eb6:	7f 91       	pop	r23
     eb8:	6f 91       	pop	r22
     eba:	5f 91       	pop	r21
     ebc:	4f 91       	pop	r20
     ebe:	3f 91       	pop	r19
     ec0:	2f 91       	pop	r18
     ec2:	0f 90       	pop	r0
     ec4:	0f be       	out	0x3f, r0	; 63
     ec6:	0f 90       	pop	r0
     ec8:	1f 90       	pop	r1
     eca:	18 95       	reti

00000ecc <__vector_7>:
ISR(TIMER1_COMPA_vect) {
     ecc:	1f 92       	push	r1
     ece:	0f 92       	push	r0
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	0f 92       	push	r0
     ed4:	11 24       	eor	r1, r1
     ed6:	2f 93       	push	r18
     ed8:	3f 93       	push	r19
     eda:	4f 93       	push	r20
     edc:	5f 93       	push	r21
     ede:	6f 93       	push	r22
     ee0:	7f 93       	push	r23
     ee2:	8f 93       	push	r24
     ee4:	9f 93       	push	r25
     ee6:	af 93       	push	r26
     ee8:	bf 93       	push	r27
     eea:	ef 93       	push	r30
     eec:	ff 93       	push	r31
     eee:	df 93       	push	r29
     ef0:	cf 93       	push	r28
     ef2:	cd b7       	in	r28, 0x3d	; 61
     ef4:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     ef6:	80 91 28 01 	lds	r24, 0x0128
     efa:	90 91 29 01 	lds	r25, 0x0129
     efe:	00 97       	sbiw	r24, 0x00	; 0
     f00:	29 f0       	breq	.+10     	; 0xf0c <__vector_7+0x40>
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     f02:	e0 91 28 01 	lds	r30, 0x0128
     f06:	f0 91 29 01 	lds	r31, 0x0129
     f0a:	09 95       	icall
	}
}
     f0c:	cf 91       	pop	r28
     f0e:	df 91       	pop	r29
     f10:	ff 91       	pop	r31
     f12:	ef 91       	pop	r30
     f14:	bf 91       	pop	r27
     f16:	af 91       	pop	r26
     f18:	9f 91       	pop	r25
     f1a:	8f 91       	pop	r24
     f1c:	7f 91       	pop	r23
     f1e:	6f 91       	pop	r22
     f20:	5f 91       	pop	r21
     f22:	4f 91       	pop	r20
     f24:	3f 91       	pop	r19
     f26:	2f 91       	pop	r18
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	0f 90       	pop	r0
     f2e:	1f 90       	pop	r1
     f30:	18 95       	reti

00000f32 <Timer1_init>:
 * Function to initialize the Timer driver
 * Setup the initial value of counter
 * Setup Normal mode or Compare mode
 * Setup Prescaler
 */
void Timer1_init(const Timer1_ConfigType *Config_Ptr) {
     f32:	df 93       	push	r29
     f34:	cf 93       	push	r28
     f36:	00 d0       	rcall	.+0      	; 0xf38 <Timer1_init+0x6>
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
     f3c:	9a 83       	std	Y+2, r25	; 0x02
     f3e:	89 83       	std	Y+1, r24	; 0x01

	/*
	 * the FOC1A/FOC1B bits are only functional in non-PWM modes.
	 */
	TCCR1A = (1 << FOC1A) | (1 << FOC1B);
     f40:	ef e4       	ldi	r30, 0x4F	; 79
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	8c e0       	ldi	r24, 0x0C	; 12
     f46:	80 83       	st	Z, r24
	/*
	 * insert the required clock value in the first three bits (CS10, CS11 and CS12)
	 * of TCCR1B Register
	 */

	TCCR1B = (TCCR1B & 0xF8) | (Config_Ptr->prescaler);
     f48:	ae e4       	ldi	r26, 0x4E	; 78
     f4a:	b0 e0       	ldi	r27, 0x00	; 0
     f4c:	ee e4       	ldi	r30, 0x4E	; 78
     f4e:	f0 e0       	ldi	r31, 0x00	; 0
     f50:	80 81       	ld	r24, Z
     f52:	98 2f       	mov	r25, r24
     f54:	98 7f       	andi	r25, 0xF8	; 248
     f56:	e9 81       	ldd	r30, Y+1	; 0x01
     f58:	fa 81       	ldd	r31, Y+2	; 0x02
     f5a:	84 81       	ldd	r24, Z+4	; 0x04
     f5c:	89 2b       	or	r24, r25
     f5e:	8c 93       	st	X, r24
	/*
	 * start count from initial value
	 */
	TCNT1 = Config_Ptr->initial_value;
     f60:	ac e4       	ldi	r26, 0x4C	; 76
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	e9 81       	ldd	r30, Y+1	; 0x01
     f66:	fa 81       	ldd	r31, Y+2	; 0x02
     f68:	80 81       	ld	r24, Z
     f6a:	91 81       	ldd	r25, Z+1	; 0x01
     f6c:	11 96       	adiw	r26, 0x01	; 1
     f6e:	9c 93       	st	X, r25
     f70:	8e 93       	st	-X, r24

	/*Compare Mode*/
	if ((Config_Ptr->mode) == Compare_Mode) {
     f72:	e9 81       	ldd	r30, Y+1	; 0x01
     f74:	fa 81       	ldd	r31, Y+2	; 0x02
     f76:	85 81       	ldd	r24, Z+5	; 0x05
     f78:	81 30       	cpi	r24, 0x01	; 1
     f7a:	a9 f4       	brne	.+42     	; 0xfa6 <Timer1_init+0x74>

		OCR1A = Config_Ptr->compare_value; /* Set Compare Value */
     f7c:	aa e4       	ldi	r26, 0x4A	; 74
     f7e:	b0 e0       	ldi	r27, 0x00	; 0
     f80:	e9 81       	ldd	r30, Y+1	; 0x01
     f82:	fa 81       	ldd	r31, Y+2	; 0x02
     f84:	82 81       	ldd	r24, Z+2	; 0x02
     f86:	93 81       	ldd	r25, Z+3	; 0x03
     f88:	11 96       	adiw	r26, 0x01	; 1
     f8a:	9c 93       	st	X, r25
     f8c:	8e 93       	st	-X, r24
		TIMSK = (1 << OCIE1A); /* Enable Timer1 Compare Interrupt */
     f8e:	e9 e5       	ldi	r30, 0x59	; 89
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	80 e1       	ldi	r24, 0x10	; 16
     f94:	80 83       	st	Z, r24
		TCCR1B |= (1 << WGM12); /* Select WGM12 = 1 and WGM11 = 0 and WGM10 = 0  (Mode Number 4) */
     f96:	ae e4       	ldi	r26, 0x4E	; 78
     f98:	b0 e0       	ldi	r27, 0x00	; 0
     f9a:	ee e4       	ldi	r30, 0x4E	; 78
     f9c:	f0 e0       	ldi	r31, 0x00	; 0
     f9e:	80 81       	ld	r24, Z
     fa0:	88 60       	ori	r24, 0x08	; 8
     fa2:	8c 93       	st	X, r24
     fa4:	09 c0       	rjmp	.+18     	; 0xfb8 <Timer1_init+0x86>

	}
	/*Normal Mode*/
	else if ((Config_Ptr->mode) == Normal_Mode) {
     fa6:	e9 81       	ldd	r30, Y+1	; 0x01
     fa8:	fa 81       	ldd	r31, Y+2	; 0x02
     faa:	85 81       	ldd	r24, Z+5	; 0x05
     fac:	88 23       	and	r24, r24
     fae:	21 f4       	brne	.+8      	; 0xfb8 <Timer1_init+0x86>

		TIMSK = (1 << TOIE1); /* Enable Timer1 Overflow Interrupt */
     fb0:	e9 e5       	ldi	r30, 0x59	; 89
     fb2:	f0 e0       	ldi	r31, 0x00	; 0
     fb4:	84 e0       	ldi	r24, 0x04	; 4
     fb6:	80 83       	st	Z, r24
	}
}
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	cf 91       	pop	r28
     fbe:	df 91       	pop	r29
     fc0:	08 95       	ret

00000fc2 <Timer1_deInit>:

/*
 * Description:
 * Functional to disable timer1
 */
void Timer1_deInit(void) {
     fc2:	df 93       	push	r29
     fc4:	cf 93       	push	r28
     fc6:	cd b7       	in	r28, 0x3d	; 61
     fc8:	de b7       	in	r29, 0x3e	; 62
	/*Clear the time registers*/
	TCCR1A = 0;
     fca:	ef e4       	ldi	r30, 0x4F	; 79
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	10 82       	st	Z, r1
	TCCR1B = 0;
     fd0:	ee e4       	ldi	r30, 0x4E	; 78
     fd2:	f0 e0       	ldi	r31, 0x00	; 0
     fd4:	10 82       	st	Z, r1
	TCNT1 = 0;
     fd6:	ec e4       	ldi	r30, 0x4C	; 76
     fd8:	f0 e0       	ldi	r31, 0x00	; 0
     fda:	11 82       	std	Z+1, r1	; 0x01
     fdc:	10 82       	st	Z, r1
	OCR1A = 0;
     fde:	ea e4       	ldi	r30, 0x4A	; 74
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	11 82       	std	Z+1, r1	; 0x01
     fe4:	10 82       	st	Z, r1

	/* Disable the  Overflow interrupt and Compare interrupt at OCIE1A*/
	TIMSK &= 0xEB ; /*(0b11101011)*/
     fe6:	a9 e5       	ldi	r26, 0x59	; 89
     fe8:	b0 e0       	ldi	r27, 0x00	; 0
     fea:	e9 e5       	ldi	r30, 0x59	; 89
     fec:	f0 e0       	ldi	r31, 0x00	; 0
     fee:	80 81       	ld	r24, Z
     ff0:	8b 7e       	andi	r24, 0xEB	; 235
     ff2:	8c 93       	st	X, r24

	/* Reset the global pointer value */
	g_callBackPtr = NULL_PTR;
     ff4:	10 92 29 01 	sts	0x0129, r1
     ff8:	10 92 28 01 	sts	0x0128, r1
}
     ffc:	cf 91       	pop	r28
     ffe:	df 91       	pop	r29
    1000:	08 95       	ret

00001002 <Timer1_setCallBack>:

/*
 * Description: Function to set the Call Back function address.
 */
void Timer1_setCallBack(void (*a_ptr)(void)) {
    1002:	df 93       	push	r29
    1004:	cf 93       	push	r28
    1006:	00 d0       	rcall	.+0      	; 0x1008 <Timer1_setCallBack+0x6>
    1008:	cd b7       	in	r28, 0x3d	; 61
    100a:	de b7       	in	r29, 0x3e	; 62
    100c:	9a 83       	std	Y+2, r25	; 0x02
    100e:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr;
    1010:	89 81       	ldd	r24, Y+1	; 0x01
    1012:	9a 81       	ldd	r25, Y+2	; 0x02
    1014:	90 93 29 01 	sts	0x0129, r25
    1018:	80 93 28 01 	sts	0x0128, r24
}
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    1020:	cf 91       	pop	r28
    1022:	df 91       	pop	r29
    1024:	08 95       	ret

00001026 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num,
		GPIO_PinDirectionType direction) {
    1026:	df 93       	push	r29
    1028:	cf 93       	push	r28
    102a:	00 d0       	rcall	.+0      	; 0x102c <GPIO_setupPinDirection+0x6>
    102c:	00 d0       	rcall	.+0      	; 0x102e <GPIO_setupPinDirection+0x8>
    102e:	0f 92       	push	r0
    1030:	cd b7       	in	r28, 0x3d	; 61
    1032:	de b7       	in	r29, 0x3e	; 62
    1034:	89 83       	std	Y+1, r24	; 0x01
    1036:	6a 83       	std	Y+2, r22	; 0x02
    1038:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    103a:	8a 81       	ldd	r24, Y+2	; 0x02
    103c:	88 30       	cpi	r24, 0x08	; 8
    103e:	08 f0       	brcs	.+2      	; 0x1042 <GPIO_setupPinDirection+0x1c>
    1040:	d5 c0       	rjmp	.+426    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
    1042:	89 81       	ldd	r24, Y+1	; 0x01
    1044:	84 30       	cpi	r24, 0x04	; 4
    1046:	08 f0       	brcs	.+2      	; 0x104a <GPIO_setupPinDirection+0x24>
    1048:	d1 c0       	rjmp	.+418    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	} else {
		/* Setup the pin direction as required */
		switch (port_num) {
    104a:	89 81       	ldd	r24, Y+1	; 0x01
    104c:	28 2f       	mov	r18, r24
    104e:	30 e0       	ldi	r19, 0x00	; 0
    1050:	3d 83       	std	Y+5, r19	; 0x05
    1052:	2c 83       	std	Y+4, r18	; 0x04
    1054:	8c 81       	ldd	r24, Y+4	; 0x04
    1056:	9d 81       	ldd	r25, Y+5	; 0x05
    1058:	81 30       	cpi	r24, 0x01	; 1
    105a:	91 05       	cpc	r25, r1
    105c:	09 f4       	brne	.+2      	; 0x1060 <GPIO_setupPinDirection+0x3a>
    105e:	43 c0       	rjmp	.+134    	; 0x10e6 <GPIO_setupPinDirection+0xc0>
    1060:	2c 81       	ldd	r18, Y+4	; 0x04
    1062:	3d 81       	ldd	r19, Y+5	; 0x05
    1064:	22 30       	cpi	r18, 0x02	; 2
    1066:	31 05       	cpc	r19, r1
    1068:	2c f4       	brge	.+10     	; 0x1074 <GPIO_setupPinDirection+0x4e>
    106a:	8c 81       	ldd	r24, Y+4	; 0x04
    106c:	9d 81       	ldd	r25, Y+5	; 0x05
    106e:	00 97       	sbiw	r24, 0x00	; 0
    1070:	71 f0       	breq	.+28     	; 0x108e <GPIO_setupPinDirection+0x68>
    1072:	bc c0       	rjmp	.+376    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
    1074:	2c 81       	ldd	r18, Y+4	; 0x04
    1076:	3d 81       	ldd	r19, Y+5	; 0x05
    1078:	22 30       	cpi	r18, 0x02	; 2
    107a:	31 05       	cpc	r19, r1
    107c:	09 f4       	brne	.+2      	; 0x1080 <GPIO_setupPinDirection+0x5a>
    107e:	5f c0       	rjmp	.+190    	; 0x113e <GPIO_setupPinDirection+0x118>
    1080:	8c 81       	ldd	r24, Y+4	; 0x04
    1082:	9d 81       	ldd	r25, Y+5	; 0x05
    1084:	83 30       	cpi	r24, 0x03	; 3
    1086:	91 05       	cpc	r25, r1
    1088:	09 f4       	brne	.+2      	; 0x108c <GPIO_setupPinDirection+0x66>
    108a:	85 c0       	rjmp	.+266    	; 0x1196 <GPIO_setupPinDirection+0x170>
    108c:	af c0       	rjmp	.+350    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
		case PORTA_ID:
			if (direction == PIN_OUTPUT) {
    108e:	8b 81       	ldd	r24, Y+3	; 0x03
    1090:	81 30       	cpi	r24, 0x01	; 1
    1092:	a1 f4       	brne	.+40     	; 0x10bc <GPIO_setupPinDirection+0x96>

				SET_BIT(DDRA, pin_num); /* This line is equivalent to 	DDRA |= (1 << pin_num);  */
    1094:	aa e3       	ldi	r26, 0x3A	; 58
    1096:	b0 e0       	ldi	r27, 0x00	; 0
    1098:	ea e3       	ldi	r30, 0x3A	; 58
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	80 81       	ld	r24, Z
    109e:	48 2f       	mov	r20, r24
    10a0:	8a 81       	ldd	r24, Y+2	; 0x02
    10a2:	28 2f       	mov	r18, r24
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	02 2e       	mov	r0, r18
    10ac:	02 c0       	rjmp	.+4      	; 0x10b2 <GPIO_setupPinDirection+0x8c>
    10ae:	88 0f       	add	r24, r24
    10b0:	99 1f       	adc	r25, r25
    10b2:	0a 94       	dec	r0
    10b4:	e2 f7       	brpl	.-8      	; 0x10ae <GPIO_setupPinDirection+0x88>
    10b6:	84 2b       	or	r24, r20
    10b8:	8c 93       	st	X, r24
    10ba:	98 c0       	rjmp	.+304    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRA, pin_num); /* This line is equivalent to 	DDRA &= ~(1 << pin_num); */
    10bc:	aa e3       	ldi	r26, 0x3A	; 58
    10be:	b0 e0       	ldi	r27, 0x00	; 0
    10c0:	ea e3       	ldi	r30, 0x3A	; 58
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	80 81       	ld	r24, Z
    10c6:	48 2f       	mov	r20, r24
    10c8:	8a 81       	ldd	r24, Y+2	; 0x02
    10ca:	28 2f       	mov	r18, r24
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	02 2e       	mov	r0, r18
    10d4:	02 c0       	rjmp	.+4      	; 0x10da <GPIO_setupPinDirection+0xb4>
    10d6:	88 0f       	add	r24, r24
    10d8:	99 1f       	adc	r25, r25
    10da:	0a 94       	dec	r0
    10dc:	e2 f7       	brpl	.-8      	; 0x10d6 <GPIO_setupPinDirection+0xb0>
    10de:	80 95       	com	r24
    10e0:	84 23       	and	r24, r20
    10e2:	8c 93       	st	X, r24
    10e4:	83 c0       	rjmp	.+262    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if (direction == PIN_OUTPUT) {
    10e6:	8b 81       	ldd	r24, Y+3	; 0x03
    10e8:	81 30       	cpi	r24, 0x01	; 1
    10ea:	a1 f4       	brne	.+40     	; 0x1114 <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB, pin_num);
    10ec:	a7 e3       	ldi	r26, 0x37	; 55
    10ee:	b0 e0       	ldi	r27, 0x00	; 0
    10f0:	e7 e3       	ldi	r30, 0x37	; 55
    10f2:	f0 e0       	ldi	r31, 0x00	; 0
    10f4:	80 81       	ld	r24, Z
    10f6:	48 2f       	mov	r20, r24
    10f8:	8a 81       	ldd	r24, Y+2	; 0x02
    10fa:	28 2f       	mov	r18, r24
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	02 2e       	mov	r0, r18
    1104:	02 c0       	rjmp	.+4      	; 0x110a <GPIO_setupPinDirection+0xe4>
    1106:	88 0f       	add	r24, r24
    1108:	99 1f       	adc	r25, r25
    110a:	0a 94       	dec	r0
    110c:	e2 f7       	brpl	.-8      	; 0x1106 <GPIO_setupPinDirection+0xe0>
    110e:	84 2b       	or	r24, r20
    1110:	8c 93       	st	X, r24
    1112:	6c c0       	rjmp	.+216    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRB, pin_num);
    1114:	a7 e3       	ldi	r26, 0x37	; 55
    1116:	b0 e0       	ldi	r27, 0x00	; 0
    1118:	e7 e3       	ldi	r30, 0x37	; 55
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	80 81       	ld	r24, Z
    111e:	48 2f       	mov	r20, r24
    1120:	8a 81       	ldd	r24, Y+2	; 0x02
    1122:	28 2f       	mov	r18, r24
    1124:	30 e0       	ldi	r19, 0x00	; 0
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	02 2e       	mov	r0, r18
    112c:	02 c0       	rjmp	.+4      	; 0x1132 <GPIO_setupPinDirection+0x10c>
    112e:	88 0f       	add	r24, r24
    1130:	99 1f       	adc	r25, r25
    1132:	0a 94       	dec	r0
    1134:	e2 f7       	brpl	.-8      	; 0x112e <GPIO_setupPinDirection+0x108>
    1136:	80 95       	com	r24
    1138:	84 23       	and	r24, r20
    113a:	8c 93       	st	X, r24
    113c:	57 c0       	rjmp	.+174    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if (direction == PIN_OUTPUT) {
    113e:	8b 81       	ldd	r24, Y+3	; 0x03
    1140:	81 30       	cpi	r24, 0x01	; 1
    1142:	a1 f4       	brne	.+40     	; 0x116c <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC, pin_num);
    1144:	a4 e3       	ldi	r26, 0x34	; 52
    1146:	b0 e0       	ldi	r27, 0x00	; 0
    1148:	e4 e3       	ldi	r30, 0x34	; 52
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	80 81       	ld	r24, Z
    114e:	48 2f       	mov	r20, r24
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	28 2f       	mov	r18, r24
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	02 2e       	mov	r0, r18
    115c:	02 c0       	rjmp	.+4      	; 0x1162 <GPIO_setupPinDirection+0x13c>
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	0a 94       	dec	r0
    1164:	e2 f7       	brpl	.-8      	; 0x115e <GPIO_setupPinDirection+0x138>
    1166:	84 2b       	or	r24, r20
    1168:	8c 93       	st	X, r24
    116a:	40 c0       	rjmp	.+128    	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRC, pin_num);
    116c:	a4 e3       	ldi	r26, 0x34	; 52
    116e:	b0 e0       	ldi	r27, 0x00	; 0
    1170:	e4 e3       	ldi	r30, 0x34	; 52
    1172:	f0 e0       	ldi	r31, 0x00	; 0
    1174:	80 81       	ld	r24, Z
    1176:	48 2f       	mov	r20, r24
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	28 2f       	mov	r18, r24
    117c:	30 e0       	ldi	r19, 0x00	; 0
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	02 2e       	mov	r0, r18
    1184:	02 c0       	rjmp	.+4      	; 0x118a <GPIO_setupPinDirection+0x164>
    1186:	88 0f       	add	r24, r24
    1188:	99 1f       	adc	r25, r25
    118a:	0a 94       	dec	r0
    118c:	e2 f7       	brpl	.-8      	; 0x1186 <GPIO_setupPinDirection+0x160>
    118e:	80 95       	com	r24
    1190:	84 23       	and	r24, r20
    1192:	8c 93       	st	X, r24
    1194:	2b c0       	rjmp	.+86     	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if (direction == PIN_OUTPUT) {
    1196:	8b 81       	ldd	r24, Y+3	; 0x03
    1198:	81 30       	cpi	r24, 0x01	; 1
    119a:	a1 f4       	brne	.+40     	; 0x11c4 <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD, pin_num);
    119c:	a1 e3       	ldi	r26, 0x31	; 49
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	e1 e3       	ldi	r30, 0x31	; 49
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	48 2f       	mov	r20, r24
    11a8:	8a 81       	ldd	r24, Y+2	; 0x02
    11aa:	28 2f       	mov	r18, r24
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	02 2e       	mov	r0, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <GPIO_setupPinDirection+0x194>
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	0a 94       	dec	r0
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <GPIO_setupPinDirection+0x190>
    11be:	84 2b       	or	r24, r20
    11c0:	8c 93       	st	X, r24
    11c2:	14 c0       	rjmp	.+40     	; 0x11ec <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRD, pin_num);
    11c4:	a1 e3       	ldi	r26, 0x31	; 49
    11c6:	b0 e0       	ldi	r27, 0x00	; 0
    11c8:	e1 e3       	ldi	r30, 0x31	; 49
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	80 81       	ld	r24, Z
    11ce:	48 2f       	mov	r20, r24
    11d0:	8a 81       	ldd	r24, Y+2	; 0x02
    11d2:	28 2f       	mov	r18, r24
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	02 2e       	mov	r0, r18
    11dc:	02 c0       	rjmp	.+4      	; 0x11e2 <GPIO_setupPinDirection+0x1bc>
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	0a 94       	dec	r0
    11e4:	e2 f7       	brpl	.-8      	; 0x11de <GPIO_setupPinDirection+0x1b8>
    11e6:	80 95       	com	r24
    11e8:	84 23       	and	r24, r20
    11ea:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	cf 91       	pop	r28
    11f8:	df 91       	pop	r29
    11fa:	08 95       	ret

000011fc <GPIO_writePin>:
 * Description :
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value) {
    11fc:	df 93       	push	r29
    11fe:	cf 93       	push	r28
    1200:	00 d0       	rcall	.+0      	; 0x1202 <GPIO_writePin+0x6>
    1202:	00 d0       	rcall	.+0      	; 0x1204 <GPIO_writePin+0x8>
    1204:	0f 92       	push	r0
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
    120a:	89 83       	std	Y+1, r24	; 0x01
    120c:	6a 83       	std	Y+2, r22	; 0x02
    120e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    1210:	8a 81       	ldd	r24, Y+2	; 0x02
    1212:	88 30       	cpi	r24, 0x08	; 8
    1214:	08 f0       	brcs	.+2      	; 0x1218 <GPIO_writePin+0x1c>
    1216:	d5 c0       	rjmp	.+426    	; 0x13c2 <GPIO_writePin+0x1c6>
    1218:	89 81       	ldd	r24, Y+1	; 0x01
    121a:	84 30       	cpi	r24, 0x04	; 4
    121c:	08 f0       	brcs	.+2      	; 0x1220 <GPIO_writePin+0x24>
    121e:	d1 c0       	rjmp	.+418    	; 0x13c2 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	} else {
		/* Write the pin value as required */
		switch (port_num) {
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	28 2f       	mov	r18, r24
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	3d 83       	std	Y+5, r19	; 0x05
    1228:	2c 83       	std	Y+4, r18	; 0x04
    122a:	8c 81       	ldd	r24, Y+4	; 0x04
    122c:	9d 81       	ldd	r25, Y+5	; 0x05
    122e:	81 30       	cpi	r24, 0x01	; 1
    1230:	91 05       	cpc	r25, r1
    1232:	09 f4       	brne	.+2      	; 0x1236 <GPIO_writePin+0x3a>
    1234:	43 c0       	rjmp	.+134    	; 0x12bc <GPIO_writePin+0xc0>
    1236:	2c 81       	ldd	r18, Y+4	; 0x04
    1238:	3d 81       	ldd	r19, Y+5	; 0x05
    123a:	22 30       	cpi	r18, 0x02	; 2
    123c:	31 05       	cpc	r19, r1
    123e:	2c f4       	brge	.+10     	; 0x124a <GPIO_writePin+0x4e>
    1240:	8c 81       	ldd	r24, Y+4	; 0x04
    1242:	9d 81       	ldd	r25, Y+5	; 0x05
    1244:	00 97       	sbiw	r24, 0x00	; 0
    1246:	71 f0       	breq	.+28     	; 0x1264 <GPIO_writePin+0x68>
    1248:	bc c0       	rjmp	.+376    	; 0x13c2 <GPIO_writePin+0x1c6>
    124a:	2c 81       	ldd	r18, Y+4	; 0x04
    124c:	3d 81       	ldd	r19, Y+5	; 0x05
    124e:	22 30       	cpi	r18, 0x02	; 2
    1250:	31 05       	cpc	r19, r1
    1252:	09 f4       	brne	.+2      	; 0x1256 <GPIO_writePin+0x5a>
    1254:	5f c0       	rjmp	.+190    	; 0x1314 <GPIO_writePin+0x118>
    1256:	8c 81       	ldd	r24, Y+4	; 0x04
    1258:	9d 81       	ldd	r25, Y+5	; 0x05
    125a:	83 30       	cpi	r24, 0x03	; 3
    125c:	91 05       	cpc	r25, r1
    125e:	09 f4       	brne	.+2      	; 0x1262 <GPIO_writePin+0x66>
    1260:	85 c0       	rjmp	.+266    	; 0x136c <GPIO_writePin+0x170>
    1262:	af c0       	rjmp	.+350    	; 0x13c2 <GPIO_writePin+0x1c6>
		case PORTA_ID:
			if (value == LOGIC_HIGH) {
    1264:	8b 81       	ldd	r24, Y+3	; 0x03
    1266:	81 30       	cpi	r24, 0x01	; 1
    1268:	a1 f4       	brne	.+40     	; 0x1292 <GPIO_writePin+0x96>
				SET_BIT(PORTA, pin_num);
    126a:	ab e3       	ldi	r26, 0x3B	; 59
    126c:	b0 e0       	ldi	r27, 0x00	; 0
    126e:	eb e3       	ldi	r30, 0x3B	; 59
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	80 81       	ld	r24, Z
    1274:	48 2f       	mov	r20, r24
    1276:	8a 81       	ldd	r24, Y+2	; 0x02
    1278:	28 2f       	mov	r18, r24
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	02 2e       	mov	r0, r18
    1282:	02 c0       	rjmp	.+4      	; 0x1288 <GPIO_writePin+0x8c>
    1284:	88 0f       	add	r24, r24
    1286:	99 1f       	adc	r25, r25
    1288:	0a 94       	dec	r0
    128a:	e2 f7       	brpl	.-8      	; 0x1284 <GPIO_writePin+0x88>
    128c:	84 2b       	or	r24, r20
    128e:	8c 93       	st	X, r24
    1290:	98 c0       	rjmp	.+304    	; 0x13c2 <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTA, pin_num);
    1292:	ab e3       	ldi	r26, 0x3B	; 59
    1294:	b0 e0       	ldi	r27, 0x00	; 0
    1296:	eb e3       	ldi	r30, 0x3B	; 59
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	80 81       	ld	r24, Z
    129c:	48 2f       	mov	r20, r24
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	28 2f       	mov	r18, r24
    12a2:	30 e0       	ldi	r19, 0x00	; 0
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	02 2e       	mov	r0, r18
    12aa:	02 c0       	rjmp	.+4      	; 0x12b0 <GPIO_writePin+0xb4>
    12ac:	88 0f       	add	r24, r24
    12ae:	99 1f       	adc	r25, r25
    12b0:	0a 94       	dec	r0
    12b2:	e2 f7       	brpl	.-8      	; 0x12ac <GPIO_writePin+0xb0>
    12b4:	80 95       	com	r24
    12b6:	84 23       	and	r24, r20
    12b8:	8c 93       	st	X, r24
    12ba:	83 c0       	rjmp	.+262    	; 0x13c2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if (value == LOGIC_HIGH) {
    12bc:	8b 81       	ldd	r24, Y+3	; 0x03
    12be:	81 30       	cpi	r24, 0x01	; 1
    12c0:	a1 f4       	brne	.+40     	; 0x12ea <GPIO_writePin+0xee>
				SET_BIT(PORTB, pin_num);
    12c2:	a8 e3       	ldi	r26, 0x38	; 56
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	e8 e3       	ldi	r30, 0x38	; 56
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	48 2f       	mov	r20, r24
    12ce:	8a 81       	ldd	r24, Y+2	; 0x02
    12d0:	28 2f       	mov	r18, r24
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	02 2e       	mov	r0, r18
    12da:	02 c0       	rjmp	.+4      	; 0x12e0 <GPIO_writePin+0xe4>
    12dc:	88 0f       	add	r24, r24
    12de:	99 1f       	adc	r25, r25
    12e0:	0a 94       	dec	r0
    12e2:	e2 f7       	brpl	.-8      	; 0x12dc <GPIO_writePin+0xe0>
    12e4:	84 2b       	or	r24, r20
    12e6:	8c 93       	st	X, r24
    12e8:	6c c0       	rjmp	.+216    	; 0x13c2 <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTB, pin_num);
    12ea:	a8 e3       	ldi	r26, 0x38	; 56
    12ec:	b0 e0       	ldi	r27, 0x00	; 0
    12ee:	e8 e3       	ldi	r30, 0x38	; 56
    12f0:	f0 e0       	ldi	r31, 0x00	; 0
    12f2:	80 81       	ld	r24, Z
    12f4:	48 2f       	mov	r20, r24
    12f6:	8a 81       	ldd	r24, Y+2	; 0x02
    12f8:	28 2f       	mov	r18, r24
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	02 2e       	mov	r0, r18
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <GPIO_writePin+0x10c>
    1304:	88 0f       	add	r24, r24
    1306:	99 1f       	adc	r25, r25
    1308:	0a 94       	dec	r0
    130a:	e2 f7       	brpl	.-8      	; 0x1304 <GPIO_writePin+0x108>
    130c:	80 95       	com	r24
    130e:	84 23       	and	r24, r20
    1310:	8c 93       	st	X, r24
    1312:	57 c0       	rjmp	.+174    	; 0x13c2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if (value == LOGIC_HIGH) {
    1314:	8b 81       	ldd	r24, Y+3	; 0x03
    1316:	81 30       	cpi	r24, 0x01	; 1
    1318:	a1 f4       	brne	.+40     	; 0x1342 <GPIO_writePin+0x146>
				SET_BIT(PORTC, pin_num);
    131a:	a5 e3       	ldi	r26, 0x35	; 53
    131c:	b0 e0       	ldi	r27, 0x00	; 0
    131e:	e5 e3       	ldi	r30, 0x35	; 53
    1320:	f0 e0       	ldi	r31, 0x00	; 0
    1322:	80 81       	ld	r24, Z
    1324:	48 2f       	mov	r20, r24
    1326:	8a 81       	ldd	r24, Y+2	; 0x02
    1328:	28 2f       	mov	r18, r24
    132a:	30 e0       	ldi	r19, 0x00	; 0
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	90 e0       	ldi	r25, 0x00	; 0
    1330:	02 2e       	mov	r0, r18
    1332:	02 c0       	rjmp	.+4      	; 0x1338 <GPIO_writePin+0x13c>
    1334:	88 0f       	add	r24, r24
    1336:	99 1f       	adc	r25, r25
    1338:	0a 94       	dec	r0
    133a:	e2 f7       	brpl	.-8      	; 0x1334 <GPIO_writePin+0x138>
    133c:	84 2b       	or	r24, r20
    133e:	8c 93       	st	X, r24
    1340:	40 c0       	rjmp	.+128    	; 0x13c2 <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTC, pin_num);
    1342:	a5 e3       	ldi	r26, 0x35	; 53
    1344:	b0 e0       	ldi	r27, 0x00	; 0
    1346:	e5 e3       	ldi	r30, 0x35	; 53
    1348:	f0 e0       	ldi	r31, 0x00	; 0
    134a:	80 81       	ld	r24, Z
    134c:	48 2f       	mov	r20, r24
    134e:	8a 81       	ldd	r24, Y+2	; 0x02
    1350:	28 2f       	mov	r18, r24
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	02 2e       	mov	r0, r18
    135a:	02 c0       	rjmp	.+4      	; 0x1360 <GPIO_writePin+0x164>
    135c:	88 0f       	add	r24, r24
    135e:	99 1f       	adc	r25, r25
    1360:	0a 94       	dec	r0
    1362:	e2 f7       	brpl	.-8      	; 0x135c <GPIO_writePin+0x160>
    1364:	80 95       	com	r24
    1366:	84 23       	and	r24, r20
    1368:	8c 93       	st	X, r24
    136a:	2b c0       	rjmp	.+86     	; 0x13c2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if (value == LOGIC_HIGH) {
    136c:	8b 81       	ldd	r24, Y+3	; 0x03
    136e:	81 30       	cpi	r24, 0x01	; 1
    1370:	a1 f4       	brne	.+40     	; 0x139a <GPIO_writePin+0x19e>
				SET_BIT(PORTD, pin_num);
    1372:	a2 e3       	ldi	r26, 0x32	; 50
    1374:	b0 e0       	ldi	r27, 0x00	; 0
    1376:	e2 e3       	ldi	r30, 0x32	; 50
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	48 2f       	mov	r20, r24
    137e:	8a 81       	ldd	r24, Y+2	; 0x02
    1380:	28 2f       	mov	r18, r24
    1382:	30 e0       	ldi	r19, 0x00	; 0
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	02 2e       	mov	r0, r18
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <GPIO_writePin+0x194>
    138c:	88 0f       	add	r24, r24
    138e:	99 1f       	adc	r25, r25
    1390:	0a 94       	dec	r0
    1392:	e2 f7       	brpl	.-8      	; 0x138c <GPIO_writePin+0x190>
    1394:	84 2b       	or	r24, r20
    1396:	8c 93       	st	X, r24
    1398:	14 c0       	rjmp	.+40     	; 0x13c2 <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTD, pin_num);
    139a:	a2 e3       	ldi	r26, 0x32	; 50
    139c:	b0 e0       	ldi	r27, 0x00	; 0
    139e:	e2 e3       	ldi	r30, 0x32	; 50
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	80 81       	ld	r24, Z
    13a4:	48 2f       	mov	r20, r24
    13a6:	8a 81       	ldd	r24, Y+2	; 0x02
    13a8:	28 2f       	mov	r18, r24
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	02 2e       	mov	r0, r18
    13b2:	02 c0       	rjmp	.+4      	; 0x13b8 <GPIO_writePin+0x1bc>
    13b4:	88 0f       	add	r24, r24
    13b6:	99 1f       	adc	r25, r25
    13b8:	0a 94       	dec	r0
    13ba:	e2 f7       	brpl	.-8      	; 0x13b4 <GPIO_writePin+0x1b8>
    13bc:	80 95       	com	r24
    13be:	84 23       	and	r24, r20
    13c0:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	0f 90       	pop	r0
    13cc:	cf 91       	pop	r28
    13ce:	df 91       	pop	r29
    13d0:	08 95       	ret

000013d2 <GPIO_readPin>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num) {
    13d2:	df 93       	push	r29
    13d4:	cf 93       	push	r28
    13d6:	00 d0       	rcall	.+0      	; 0x13d8 <GPIO_readPin+0x6>
    13d8:	00 d0       	rcall	.+0      	; 0x13da <GPIO_readPin+0x8>
    13da:	0f 92       	push	r0
    13dc:	cd b7       	in	r28, 0x3d	; 61
    13de:	de b7       	in	r29, 0x3e	; 62
    13e0:	8a 83       	std	Y+2, r24	; 0x02
    13e2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    13e4:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    13e6:	8b 81       	ldd	r24, Y+3	; 0x03
    13e8:	88 30       	cpi	r24, 0x08	; 8
    13ea:	08 f0       	brcs	.+2      	; 0x13ee <GPIO_readPin+0x1c>
    13ec:	84 c0       	rjmp	.+264    	; 0x14f6 <GPIO_readPin+0x124>
    13ee:	8a 81       	ldd	r24, Y+2	; 0x02
    13f0:	84 30       	cpi	r24, 0x04	; 4
    13f2:	08 f0       	brcs	.+2      	; 0x13f6 <GPIO_readPin+0x24>
    13f4:	80 c0       	rjmp	.+256    	; 0x14f6 <GPIO_readPin+0x124>
		/* Do Nothing */
	} else {
		/* Read the pin value as required */
		switch (port_num) {
    13f6:	8a 81       	ldd	r24, Y+2	; 0x02
    13f8:	28 2f       	mov	r18, r24
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	3d 83       	std	Y+5, r19	; 0x05
    13fe:	2c 83       	std	Y+4, r18	; 0x04
    1400:	4c 81       	ldd	r20, Y+4	; 0x04
    1402:	5d 81       	ldd	r21, Y+5	; 0x05
    1404:	41 30       	cpi	r20, 0x01	; 1
    1406:	51 05       	cpc	r21, r1
    1408:	79 f1       	breq	.+94     	; 0x1468 <GPIO_readPin+0x96>
    140a:	8c 81       	ldd	r24, Y+4	; 0x04
    140c:	9d 81       	ldd	r25, Y+5	; 0x05
    140e:	82 30       	cpi	r24, 0x02	; 2
    1410:	91 05       	cpc	r25, r1
    1412:	34 f4       	brge	.+12     	; 0x1420 <GPIO_readPin+0x4e>
    1414:	2c 81       	ldd	r18, Y+4	; 0x04
    1416:	3d 81       	ldd	r19, Y+5	; 0x05
    1418:	21 15       	cp	r18, r1
    141a:	31 05       	cpc	r19, r1
    141c:	69 f0       	breq	.+26     	; 0x1438 <GPIO_readPin+0x66>
    141e:	6b c0       	rjmp	.+214    	; 0x14f6 <GPIO_readPin+0x124>
    1420:	4c 81       	ldd	r20, Y+4	; 0x04
    1422:	5d 81       	ldd	r21, Y+5	; 0x05
    1424:	42 30       	cpi	r20, 0x02	; 2
    1426:	51 05       	cpc	r21, r1
    1428:	b9 f1       	breq	.+110    	; 0x1498 <GPIO_readPin+0xc6>
    142a:	8c 81       	ldd	r24, Y+4	; 0x04
    142c:	9d 81       	ldd	r25, Y+5	; 0x05
    142e:	83 30       	cpi	r24, 0x03	; 3
    1430:	91 05       	cpc	r25, r1
    1432:	09 f4       	brne	.+2      	; 0x1436 <GPIO_readPin+0x64>
    1434:	49 c0       	rjmp	.+146    	; 0x14c8 <GPIO_readPin+0xf6>
    1436:	5f c0       	rjmp	.+190    	; 0x14f6 <GPIO_readPin+0x124>
		case PORTA_ID:
			if (BIT_IS_SET(PINA, pin_num)) {
    1438:	e9 e3       	ldi	r30, 0x39	; 57
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	80 81       	ld	r24, Z
    143e:	28 2f       	mov	r18, r24
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	8b 81       	ldd	r24, Y+3	; 0x03
    1444:	88 2f       	mov	r24, r24
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	a9 01       	movw	r20, r18
    144a:	02 c0       	rjmp	.+4      	; 0x1450 <GPIO_readPin+0x7e>
    144c:	55 95       	asr	r21
    144e:	47 95       	ror	r20
    1450:	8a 95       	dec	r24
    1452:	e2 f7       	brpl	.-8      	; 0x144c <GPIO_readPin+0x7a>
    1454:	ca 01       	movw	r24, r20
    1456:	81 70       	andi	r24, 0x01	; 1
    1458:	90 70       	andi	r25, 0x00	; 0
    145a:	88 23       	and	r24, r24
    145c:	19 f0       	breq	.+6      	; 0x1464 <GPIO_readPin+0x92>
				pin_value = LOGIC_HIGH;
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	89 83       	std	Y+1, r24	; 0x01
    1462:	49 c0       	rjmp	.+146    	; 0x14f6 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1464:	19 82       	std	Y+1, r1	; 0x01
    1466:	47 c0       	rjmp	.+142    	; 0x14f6 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if (BIT_IS_SET(PINB, pin_num)) {
    1468:	e6 e3       	ldi	r30, 0x36	; 54
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	80 81       	ld	r24, Z
    146e:	28 2f       	mov	r18, r24
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	88 2f       	mov	r24, r24
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	a9 01       	movw	r20, r18
    147a:	02 c0       	rjmp	.+4      	; 0x1480 <GPIO_readPin+0xae>
    147c:	55 95       	asr	r21
    147e:	47 95       	ror	r20
    1480:	8a 95       	dec	r24
    1482:	e2 f7       	brpl	.-8      	; 0x147c <GPIO_readPin+0xaa>
    1484:	ca 01       	movw	r24, r20
    1486:	81 70       	andi	r24, 0x01	; 1
    1488:	90 70       	andi	r25, 0x00	; 0
    148a:	88 23       	and	r24, r24
    148c:	19 f0       	breq	.+6      	; 0x1494 <GPIO_readPin+0xc2>
				pin_value = LOGIC_HIGH;
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	89 83       	std	Y+1, r24	; 0x01
    1492:	31 c0       	rjmp	.+98     	; 0x14f6 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1494:	19 82       	std	Y+1, r1	; 0x01
    1496:	2f c0       	rjmp	.+94     	; 0x14f6 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if (BIT_IS_SET(PINC, pin_num)) {
    1498:	e3 e3       	ldi	r30, 0x33	; 51
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	80 81       	ld	r24, Z
    149e:	28 2f       	mov	r18, r24
    14a0:	30 e0       	ldi	r19, 0x00	; 0
    14a2:	8b 81       	ldd	r24, Y+3	; 0x03
    14a4:	88 2f       	mov	r24, r24
    14a6:	90 e0       	ldi	r25, 0x00	; 0
    14a8:	a9 01       	movw	r20, r18
    14aa:	02 c0       	rjmp	.+4      	; 0x14b0 <GPIO_readPin+0xde>
    14ac:	55 95       	asr	r21
    14ae:	47 95       	ror	r20
    14b0:	8a 95       	dec	r24
    14b2:	e2 f7       	brpl	.-8      	; 0x14ac <GPIO_readPin+0xda>
    14b4:	ca 01       	movw	r24, r20
    14b6:	81 70       	andi	r24, 0x01	; 1
    14b8:	90 70       	andi	r25, 0x00	; 0
    14ba:	88 23       	and	r24, r24
    14bc:	19 f0       	breq	.+6      	; 0x14c4 <GPIO_readPin+0xf2>
				pin_value = LOGIC_HIGH;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	89 83       	std	Y+1, r24	; 0x01
    14c2:	19 c0       	rjmp	.+50     	; 0x14f6 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    14c4:	19 82       	std	Y+1, r1	; 0x01
    14c6:	17 c0       	rjmp	.+46     	; 0x14f6 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if (BIT_IS_SET(PIND, pin_num)) {
    14c8:	e0 e3       	ldi	r30, 0x30	; 48
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	80 81       	ld	r24, Z
    14ce:	28 2f       	mov	r18, r24
    14d0:	30 e0       	ldi	r19, 0x00	; 0
    14d2:	8b 81       	ldd	r24, Y+3	; 0x03
    14d4:	88 2f       	mov	r24, r24
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	a9 01       	movw	r20, r18
    14da:	02 c0       	rjmp	.+4      	; 0x14e0 <GPIO_readPin+0x10e>
    14dc:	55 95       	asr	r21
    14de:	47 95       	ror	r20
    14e0:	8a 95       	dec	r24
    14e2:	e2 f7       	brpl	.-8      	; 0x14dc <GPIO_readPin+0x10a>
    14e4:	ca 01       	movw	r24, r20
    14e6:	81 70       	andi	r24, 0x01	; 1
    14e8:	90 70       	andi	r25, 0x00	; 0
    14ea:	88 23       	and	r24, r24
    14ec:	19 f0       	breq	.+6      	; 0x14f4 <GPIO_readPin+0x122>
				pin_value = LOGIC_HIGH;
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	89 83       	std	Y+1, r24	; 0x01
    14f2:	01 c0       	rjmp	.+2      	; 0x14f6 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    14f4:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    14f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    14f8:	0f 90       	pop	r0
    14fa:	0f 90       	pop	r0
    14fc:	0f 90       	pop	r0
    14fe:	0f 90       	pop	r0
    1500:	0f 90       	pop	r0
    1502:	cf 91       	pop	r28
    1504:	df 91       	pop	r29
    1506:	08 95       	ret

00001508 <GPIO_setupPortDirection>:
 * Setup the direction of the required port all pins input/output.
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction) {
    1508:	df 93       	push	r29
    150a:	cf 93       	push	r28
    150c:	00 d0       	rcall	.+0      	; 0x150e <GPIO_setupPortDirection+0x6>
    150e:	00 d0       	rcall	.+0      	; 0x1510 <GPIO_setupPortDirection+0x8>
    1510:	cd b7       	in	r28, 0x3d	; 61
    1512:	de b7       	in	r29, 0x3e	; 62
    1514:	89 83       	std	Y+1, r24	; 0x01
    1516:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1518:	89 81       	ldd	r24, Y+1	; 0x01
    151a:	84 30       	cpi	r24, 0x04	; 4
    151c:	90 f5       	brcc	.+100    	; 0x1582 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	} else {
		/* Setup the port direction as required */
		switch (port_num) {
    151e:	89 81       	ldd	r24, Y+1	; 0x01
    1520:	28 2f       	mov	r18, r24
    1522:	30 e0       	ldi	r19, 0x00	; 0
    1524:	3c 83       	std	Y+4, r19	; 0x04
    1526:	2b 83       	std	Y+3, r18	; 0x03
    1528:	8b 81       	ldd	r24, Y+3	; 0x03
    152a:	9c 81       	ldd	r25, Y+4	; 0x04
    152c:	81 30       	cpi	r24, 0x01	; 1
    152e:	91 05       	cpc	r25, r1
    1530:	d1 f0       	breq	.+52     	; 0x1566 <GPIO_setupPortDirection+0x5e>
    1532:	2b 81       	ldd	r18, Y+3	; 0x03
    1534:	3c 81       	ldd	r19, Y+4	; 0x04
    1536:	22 30       	cpi	r18, 0x02	; 2
    1538:	31 05       	cpc	r19, r1
    153a:	2c f4       	brge	.+10     	; 0x1546 <GPIO_setupPortDirection+0x3e>
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	00 97       	sbiw	r24, 0x00	; 0
    1542:	61 f0       	breq	.+24     	; 0x155c <GPIO_setupPortDirection+0x54>
    1544:	1e c0       	rjmp	.+60     	; 0x1582 <GPIO_setupPortDirection+0x7a>
    1546:	2b 81       	ldd	r18, Y+3	; 0x03
    1548:	3c 81       	ldd	r19, Y+4	; 0x04
    154a:	22 30       	cpi	r18, 0x02	; 2
    154c:	31 05       	cpc	r19, r1
    154e:	81 f0       	breq	.+32     	; 0x1570 <GPIO_setupPortDirection+0x68>
    1550:	8b 81       	ldd	r24, Y+3	; 0x03
    1552:	9c 81       	ldd	r25, Y+4	; 0x04
    1554:	83 30       	cpi	r24, 0x03	; 3
    1556:	91 05       	cpc	r25, r1
    1558:	81 f0       	breq	.+32     	; 0x157a <GPIO_setupPortDirection+0x72>
    155a:	13 c0       	rjmp	.+38     	; 0x1582 <GPIO_setupPortDirection+0x7a>
		case PORTA_ID:
			DDRA = direction;
    155c:	ea e3       	ldi	r30, 0x3A	; 58
    155e:	f0 e0       	ldi	r31, 0x00	; 0
    1560:	8a 81       	ldd	r24, Y+2	; 0x02
    1562:	80 83       	st	Z, r24
    1564:	0e c0       	rjmp	.+28     	; 0x1582 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1566:	e7 e3       	ldi	r30, 0x37	; 55
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	8a 81       	ldd	r24, Y+2	; 0x02
    156c:	80 83       	st	Z, r24
    156e:	09 c0       	rjmp	.+18     	; 0x1582 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1570:	e4 e3       	ldi	r30, 0x34	; 52
    1572:	f0 e0       	ldi	r31, 0x00	; 0
    1574:	8a 81       	ldd	r24, Y+2	; 0x02
    1576:	80 83       	st	Z, r24
    1578:	04 c0       	rjmp	.+8      	; 0x1582 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    157a:	e1 e3       	ldi	r30, 0x31	; 49
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	8a 81       	ldd	r24, Y+2	; 0x02
    1580:	80 83       	st	Z, r24
			break;
		}
	}
}
    1582:	0f 90       	pop	r0
    1584:	0f 90       	pop	r0
    1586:	0f 90       	pop	r0
    1588:	0f 90       	pop	r0
    158a:	cf 91       	pop	r28
    158c:	df 91       	pop	r29
    158e:	08 95       	ret

00001590 <GPIO_writePort>:
 * Write the value on the required port.
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value) {
    1590:	df 93       	push	r29
    1592:	cf 93       	push	r28
    1594:	00 d0       	rcall	.+0      	; 0x1596 <GPIO_writePort+0x6>
    1596:	00 d0       	rcall	.+0      	; 0x1598 <GPIO_writePort+0x8>
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	89 83       	std	Y+1, r24	; 0x01
    159e:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    15a0:	89 81       	ldd	r24, Y+1	; 0x01
    15a2:	84 30       	cpi	r24, 0x04	; 4
    15a4:	90 f5       	brcc	.+100    	; 0x160a <GPIO_writePort+0x7a>
		/* Do Nothing */
	} else {
		/* Write the port value as required */
		switch (port_num) {
    15a6:	89 81       	ldd	r24, Y+1	; 0x01
    15a8:	28 2f       	mov	r18, r24
    15aa:	30 e0       	ldi	r19, 0x00	; 0
    15ac:	3c 83       	std	Y+4, r19	; 0x04
    15ae:	2b 83       	std	Y+3, r18	; 0x03
    15b0:	8b 81       	ldd	r24, Y+3	; 0x03
    15b2:	9c 81       	ldd	r25, Y+4	; 0x04
    15b4:	81 30       	cpi	r24, 0x01	; 1
    15b6:	91 05       	cpc	r25, r1
    15b8:	d1 f0       	breq	.+52     	; 0x15ee <GPIO_writePort+0x5e>
    15ba:	2b 81       	ldd	r18, Y+3	; 0x03
    15bc:	3c 81       	ldd	r19, Y+4	; 0x04
    15be:	22 30       	cpi	r18, 0x02	; 2
    15c0:	31 05       	cpc	r19, r1
    15c2:	2c f4       	brge	.+10     	; 0x15ce <GPIO_writePort+0x3e>
    15c4:	8b 81       	ldd	r24, Y+3	; 0x03
    15c6:	9c 81       	ldd	r25, Y+4	; 0x04
    15c8:	00 97       	sbiw	r24, 0x00	; 0
    15ca:	61 f0       	breq	.+24     	; 0x15e4 <GPIO_writePort+0x54>
    15cc:	1e c0       	rjmp	.+60     	; 0x160a <GPIO_writePort+0x7a>
    15ce:	2b 81       	ldd	r18, Y+3	; 0x03
    15d0:	3c 81       	ldd	r19, Y+4	; 0x04
    15d2:	22 30       	cpi	r18, 0x02	; 2
    15d4:	31 05       	cpc	r19, r1
    15d6:	81 f0       	breq	.+32     	; 0x15f8 <GPIO_writePort+0x68>
    15d8:	8b 81       	ldd	r24, Y+3	; 0x03
    15da:	9c 81       	ldd	r25, Y+4	; 0x04
    15dc:	83 30       	cpi	r24, 0x03	; 3
    15de:	91 05       	cpc	r25, r1
    15e0:	81 f0       	breq	.+32     	; 0x1602 <GPIO_writePort+0x72>
    15e2:	13 c0       	rjmp	.+38     	; 0x160a <GPIO_writePort+0x7a>
		case PORTA_ID:
			PORTA = value;
    15e4:	eb e3       	ldi	r30, 0x3B	; 59
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ea:	80 83       	st	Z, r24
    15ec:	0e c0       	rjmp	.+28     	; 0x160a <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    15ee:	e8 e3       	ldi	r30, 0x38	; 56
    15f0:	f0 e0       	ldi	r31, 0x00	; 0
    15f2:	8a 81       	ldd	r24, Y+2	; 0x02
    15f4:	80 83       	st	Z, r24
    15f6:	09 c0       	rjmp	.+18     	; 0x160a <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    15f8:	e5 e3       	ldi	r30, 0x35	; 53
    15fa:	f0 e0       	ldi	r31, 0x00	; 0
    15fc:	8a 81       	ldd	r24, Y+2	; 0x02
    15fe:	80 83       	st	Z, r24
    1600:	04 c0       	rjmp	.+8      	; 0x160a <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1602:	e2 e3       	ldi	r30, 0x32	; 50
    1604:	f0 e0       	ldi	r31, 0x00	; 0
    1606:	8a 81       	ldd	r24, Y+2	; 0x02
    1608:	80 83       	st	Z, r24
			break;
		}
	}
}
    160a:	0f 90       	pop	r0
    160c:	0f 90       	pop	r0
    160e:	0f 90       	pop	r0
    1610:	0f 90       	pop	r0
    1612:	cf 91       	pop	r28
    1614:	df 91       	pop	r29
    1616:	08 95       	ret

00001618 <GPIO_readPort>:
/*
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num) {
    1618:	df 93       	push	r29
    161a:	cf 93       	push	r28
    161c:	00 d0       	rcall	.+0      	; 0x161e <GPIO_readPort+0x6>
    161e:	00 d0       	rcall	.+0      	; 0x1620 <GPIO_readPort+0x8>
    1620:	cd b7       	in	r28, 0x3d	; 61
    1622:	de b7       	in	r29, 0x3e	; 62
    1624:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1626:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1628:	8a 81       	ldd	r24, Y+2	; 0x02
    162a:	84 30       	cpi	r24, 0x04	; 4
    162c:	90 f5       	brcc	.+100    	; 0x1692 <GPIO_readPort+0x7a>
		/* Do Nothing */
	} else {
		/* Read the port value as required */
		switch (port_num) {
    162e:	8a 81       	ldd	r24, Y+2	; 0x02
    1630:	28 2f       	mov	r18, r24
    1632:	30 e0       	ldi	r19, 0x00	; 0
    1634:	3c 83       	std	Y+4, r19	; 0x04
    1636:	2b 83       	std	Y+3, r18	; 0x03
    1638:	8b 81       	ldd	r24, Y+3	; 0x03
    163a:	9c 81       	ldd	r25, Y+4	; 0x04
    163c:	81 30       	cpi	r24, 0x01	; 1
    163e:	91 05       	cpc	r25, r1
    1640:	d1 f0       	breq	.+52     	; 0x1676 <GPIO_readPort+0x5e>
    1642:	2b 81       	ldd	r18, Y+3	; 0x03
    1644:	3c 81       	ldd	r19, Y+4	; 0x04
    1646:	22 30       	cpi	r18, 0x02	; 2
    1648:	31 05       	cpc	r19, r1
    164a:	2c f4       	brge	.+10     	; 0x1656 <GPIO_readPort+0x3e>
    164c:	8b 81       	ldd	r24, Y+3	; 0x03
    164e:	9c 81       	ldd	r25, Y+4	; 0x04
    1650:	00 97       	sbiw	r24, 0x00	; 0
    1652:	61 f0       	breq	.+24     	; 0x166c <GPIO_readPort+0x54>
    1654:	1e c0       	rjmp	.+60     	; 0x1692 <GPIO_readPort+0x7a>
    1656:	2b 81       	ldd	r18, Y+3	; 0x03
    1658:	3c 81       	ldd	r19, Y+4	; 0x04
    165a:	22 30       	cpi	r18, 0x02	; 2
    165c:	31 05       	cpc	r19, r1
    165e:	81 f0       	breq	.+32     	; 0x1680 <GPIO_readPort+0x68>
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	83 30       	cpi	r24, 0x03	; 3
    1666:	91 05       	cpc	r25, r1
    1668:	81 f0       	breq	.+32     	; 0x168a <GPIO_readPort+0x72>
    166a:	13 c0       	rjmp	.+38     	; 0x1692 <GPIO_readPort+0x7a>
		case PORTA_ID:
			value = PINA;
    166c:	e9 e3       	ldi	r30, 0x39	; 57
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	89 83       	std	Y+1, r24	; 0x01
    1674:	0e c0       	rjmp	.+28     	; 0x1692 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1676:	e6 e3       	ldi	r30, 0x36	; 54
    1678:	f0 e0       	ldi	r31, 0x00	; 0
    167a:	80 81       	ld	r24, Z
    167c:	89 83       	std	Y+1, r24	; 0x01
    167e:	09 c0       	rjmp	.+18     	; 0x1692 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1680:	e3 e3       	ldi	r30, 0x33	; 51
    1682:	f0 e0       	ldi	r31, 0x00	; 0
    1684:	80 81       	ld	r24, Z
    1686:	89 83       	std	Y+1, r24	; 0x01
    1688:	04 c0       	rjmp	.+8      	; 0x1692 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    168a:	e0 e3       	ldi	r30, 0x30	; 48
    168c:	f0 e0       	ldi	r31, 0x00	; 0
    168e:	80 81       	ld	r24, Z
    1690:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    1692:	89 81       	ldd	r24, Y+1	; 0x01
}
    1694:	0f 90       	pop	r0
    1696:	0f 90       	pop	r0
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	cf 91       	pop	r28
    169e:	df 91       	pop	r29
    16a0:	08 95       	ret

000016a2 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    16a2:	df 93       	push	r29
    16a4:	cf 93       	push	r28
    16a6:	cd b7       	in	r28, 0x3d	; 61
    16a8:	de b7       	in	r29, 0x3e	; 62
    16aa:	2e 97       	sbiw	r28, 0x0e	; 14
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	f8 94       	cli
    16b0:	de bf       	out	0x3e, r29	; 62
    16b2:	0f be       	out	0x3f, r0	; 63
    16b4:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	60 e0       	ldi	r22, 0x00	; 0
    16ba:	41 e0       	ldi	r20, 0x01	; 1
    16bc:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	61 e0       	ldi	r22, 0x01	; 1
    16c4:	41 e0       	ldi	r20, 0x01	; 1
    16c6:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	a0 ea       	ldi	r26, 0xA0	; 160
    16d0:	b1 e4       	ldi	r27, 0x41	; 65
    16d2:	8b 87       	std	Y+11, r24	; 0x0b
    16d4:	9c 87       	std	Y+12, r25	; 0x0c
    16d6:	ad 87       	std	Y+13, r26	; 0x0d
    16d8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    16da:	6b 85       	ldd	r22, Y+11	; 0x0b
    16dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    16de:	8d 85       	ldd	r24, Y+13	; 0x0d
    16e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	4a ef       	ldi	r20, 0xFA	; 250
    16e8:	54 e4       	ldi	r21, 0x44	; 68
    16ea:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    16ee:	dc 01       	movw	r26, r24
    16f0:	cb 01       	movw	r24, r22
    16f2:	8f 83       	std	Y+7, r24	; 0x07
    16f4:	98 87       	std	Y+8, r25	; 0x08
    16f6:	a9 87       	std	Y+9, r26	; 0x09
    16f8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    16fa:	6f 81       	ldd	r22, Y+7	; 0x07
    16fc:	78 85       	ldd	r23, Y+8	; 0x08
    16fe:	89 85       	ldd	r24, Y+9	; 0x09
    1700:	9a 85       	ldd	r25, Y+10	; 0x0a
    1702:	20 e0       	ldi	r18, 0x00	; 0
    1704:	30 e0       	ldi	r19, 0x00	; 0
    1706:	40 e8       	ldi	r20, 0x80	; 128
    1708:	5f e3       	ldi	r21, 0x3F	; 63
    170a:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    170e:	88 23       	and	r24, r24
    1710:	2c f4       	brge	.+10     	; 0x171c <LCD_init+0x7a>
		__ticks = 1;
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	9e 83       	std	Y+6, r25	; 0x06
    1718:	8d 83       	std	Y+5, r24	; 0x05
    171a:	3f c0       	rjmp	.+126    	; 0x179a <LCD_init+0xf8>
	else if (__tmp > 65535)
    171c:	6f 81       	ldd	r22, Y+7	; 0x07
    171e:	78 85       	ldd	r23, Y+8	; 0x08
    1720:	89 85       	ldd	r24, Y+9	; 0x09
    1722:	9a 85       	ldd	r25, Y+10	; 0x0a
    1724:	20 e0       	ldi	r18, 0x00	; 0
    1726:	3f ef       	ldi	r19, 0xFF	; 255
    1728:	4f e7       	ldi	r20, 0x7F	; 127
    172a:	57 e4       	ldi	r21, 0x47	; 71
    172c:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1730:	18 16       	cp	r1, r24
    1732:	4c f5       	brge	.+82     	; 0x1786 <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1734:	6b 85       	ldd	r22, Y+11	; 0x0b
    1736:	7c 85       	ldd	r23, Y+12	; 0x0c
    1738:	8d 85       	ldd	r24, Y+13	; 0x0d
    173a:	9e 85       	ldd	r25, Y+14	; 0x0e
    173c:	20 e0       	ldi	r18, 0x00	; 0
    173e:	30 e0       	ldi	r19, 0x00	; 0
    1740:	40 e2       	ldi	r20, 0x20	; 32
    1742:	51 e4       	ldi	r21, 0x41	; 65
    1744:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1748:	dc 01       	movw	r26, r24
    174a:	cb 01       	movw	r24, r22
    174c:	bc 01       	movw	r22, r24
    174e:	cd 01       	movw	r24, r26
    1750:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1754:	dc 01       	movw	r26, r24
    1756:	cb 01       	movw	r24, r22
    1758:	9e 83       	std	Y+6, r25	; 0x06
    175a:	8d 83       	std	Y+5, r24	; 0x05
    175c:	0f c0       	rjmp	.+30     	; 0x177c <LCD_init+0xda>
    175e:	88 ec       	ldi	r24, 0xC8	; 200
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	9c 83       	std	Y+4, r25	; 0x04
    1764:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1766:	8b 81       	ldd	r24, Y+3	; 0x03
    1768:	9c 81       	ldd	r25, Y+4	; 0x04
    176a:	01 97       	sbiw	r24, 0x01	; 1
    176c:	f1 f7       	brne	.-4      	; 0x176a <LCD_init+0xc8>
    176e:	9c 83       	std	Y+4, r25	; 0x04
    1770:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1772:	8d 81       	ldd	r24, Y+5	; 0x05
    1774:	9e 81       	ldd	r25, Y+6	; 0x06
    1776:	01 97       	sbiw	r24, 0x01	; 1
    1778:	9e 83       	std	Y+6, r25	; 0x06
    177a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    177c:	8d 81       	ldd	r24, Y+5	; 0x05
    177e:	9e 81       	ldd	r25, Y+6	; 0x06
    1780:	00 97       	sbiw	r24, 0x00	; 0
    1782:	69 f7       	brne	.-38     	; 0x175e <LCD_init+0xbc>
    1784:	14 c0       	rjmp	.+40     	; 0x17ae <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1786:	6f 81       	ldd	r22, Y+7	; 0x07
    1788:	78 85       	ldd	r23, Y+8	; 0x08
    178a:	89 85       	ldd	r24, Y+9	; 0x09
    178c:	9a 85       	ldd	r25, Y+10	; 0x0a
    178e:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1792:	dc 01       	movw	r26, r24
    1794:	cb 01       	movw	r24, r22
    1796:	9e 83       	std	Y+6, r25	; 0x06
    1798:	8d 83       	std	Y+5, r24	; 0x05
    179a:	8d 81       	ldd	r24, Y+5	; 0x05
    179c:	9e 81       	ldd	r25, Y+6	; 0x06
    179e:	9a 83       	std	Y+2, r25	; 0x02
    17a0:	89 83       	std	Y+1, r24	; 0x01
    17a2:	89 81       	ldd	r24, Y+1	; 0x01
    17a4:	9a 81       	ldd	r25, Y+2	; 0x02
    17a6:	01 97       	sbiw	r24, 0x01	; 1
    17a8:	f1 f7       	brne	.-4      	; 0x17a6 <LCD_init+0x104>
    17aa:	9a 83       	std	Y+2, r25	; 0x02
    17ac:	89 83       	std	Y+1, r24	; 0x01
	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);

#elif(LCD_DATA_BITS_MODE == 8)
	/* Configure the data port as output port */
	GPIO_setupPortDirection(LCD_DATA_PORT_ID,PORT_OUTPUT);
    17ae:	80 e0       	ldi	r24, 0x00	; 0
    17b0:	6f ef       	ldi	r22, 0xFF	; 255
    17b2:	0e 94 84 0a 	call	0x1508	; 0x1508 <GPIO_setupPortDirection>

	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);
    17b6:	88 e3       	ldi	r24, 0x38	; 56
    17b8:	0e 94 ed 0b 	call	0x17da	; 0x17da <LCD_sendCommand>

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    17bc:	8c e0       	ldi	r24, 0x0C	; 12
    17be:	0e 94 ed 0b 	call	0x17da	; 0x17da <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	0e 94 ed 0b 	call	0x17da	; 0x17da <LCD_sendCommand>
}
    17c8:	2e 96       	adiw	r28, 0x0e	; 14
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	f8 94       	cli
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	0f be       	out	0x3f, r0	; 63
    17d2:	cd bf       	out	0x3d, r28	; 61
    17d4:	cf 91       	pop	r28
    17d6:	df 91       	pop	r29
    17d8:	08 95       	ret

000017da <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    17da:	df 93       	push	r29
    17dc:	cf 93       	push	r28
    17de:	cd b7       	in	r28, 0x3d	; 61
    17e0:	de b7       	in	r29, 0x3e	; 62
    17e2:	e9 97       	sbiw	r28, 0x39	; 57
    17e4:	0f b6       	in	r0, 0x3f	; 63
    17e6:	f8 94       	cli
    17e8:	de bf       	out	0x3e, r29	; 62
    17ea:	0f be       	out	0x3f, r0	; 63
    17ec:	cd bf       	out	0x3d, r28	; 61
    17ee:	89 af       	std	Y+57, r24	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	60 e0       	ldi	r22, 0x00	; 0
    17f4:	40 e0       	ldi	r20, 0x00	; 0
    17f6:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    17fa:	80 e0       	ldi	r24, 0x00	; 0
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	a0 e8       	ldi	r26, 0x80	; 128
    1800:	bf e3       	ldi	r27, 0x3F	; 63
    1802:	8d ab       	std	Y+53, r24	; 0x35
    1804:	9e ab       	std	Y+54, r25	; 0x36
    1806:	af ab       	std	Y+55, r26	; 0x37
    1808:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    180a:	6d a9       	ldd	r22, Y+53	; 0x35
    180c:	7e a9       	ldd	r23, Y+54	; 0x36
    180e:	8f a9       	ldd	r24, Y+55	; 0x37
    1810:	98 ad       	ldd	r25, Y+56	; 0x38
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	30 e0       	ldi	r19, 0x00	; 0
    1816:	4a ef       	ldi	r20, 0xFA	; 250
    1818:	54 e4       	ldi	r21, 0x44	; 68
    181a:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    181e:	dc 01       	movw	r26, r24
    1820:	cb 01       	movw	r24, r22
    1822:	89 ab       	std	Y+49, r24	; 0x31
    1824:	9a ab       	std	Y+50, r25	; 0x32
    1826:	ab ab       	std	Y+51, r26	; 0x33
    1828:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    182a:	69 a9       	ldd	r22, Y+49	; 0x31
    182c:	7a a9       	ldd	r23, Y+50	; 0x32
    182e:	8b a9       	ldd	r24, Y+51	; 0x33
    1830:	9c a9       	ldd	r25, Y+52	; 0x34
    1832:	20 e0       	ldi	r18, 0x00	; 0
    1834:	30 e0       	ldi	r19, 0x00	; 0
    1836:	40 e8       	ldi	r20, 0x80	; 128
    1838:	5f e3       	ldi	r21, 0x3F	; 63
    183a:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    183e:	88 23       	and	r24, r24
    1840:	2c f4       	brge	.+10     	; 0x184c <LCD_sendCommand+0x72>
		__ticks = 1;
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	98 ab       	std	Y+48, r25	; 0x30
    1848:	8f a7       	std	Y+47, r24	; 0x2f
    184a:	3f c0       	rjmp	.+126    	; 0x18ca <LCD_sendCommand+0xf0>
	else if (__tmp > 65535)
    184c:	69 a9       	ldd	r22, Y+49	; 0x31
    184e:	7a a9       	ldd	r23, Y+50	; 0x32
    1850:	8b a9       	ldd	r24, Y+51	; 0x33
    1852:	9c a9       	ldd	r25, Y+52	; 0x34
    1854:	20 e0       	ldi	r18, 0x00	; 0
    1856:	3f ef       	ldi	r19, 0xFF	; 255
    1858:	4f e7       	ldi	r20, 0x7F	; 127
    185a:	57 e4       	ldi	r21, 0x47	; 71
    185c:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1860:	18 16       	cp	r1, r24
    1862:	4c f5       	brge	.+82     	; 0x18b6 <LCD_sendCommand+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1864:	6d a9       	ldd	r22, Y+53	; 0x35
    1866:	7e a9       	ldd	r23, Y+54	; 0x36
    1868:	8f a9       	ldd	r24, Y+55	; 0x37
    186a:	98 ad       	ldd	r25, Y+56	; 0x38
    186c:	20 e0       	ldi	r18, 0x00	; 0
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	40 e2       	ldi	r20, 0x20	; 32
    1872:	51 e4       	ldi	r21, 0x41	; 65
    1874:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1878:	dc 01       	movw	r26, r24
    187a:	cb 01       	movw	r24, r22
    187c:	bc 01       	movw	r22, r24
    187e:	cd 01       	movw	r24, r26
    1880:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1884:	dc 01       	movw	r26, r24
    1886:	cb 01       	movw	r24, r22
    1888:	98 ab       	std	Y+48, r25	; 0x30
    188a:	8f a7       	std	Y+47, r24	; 0x2f
    188c:	0f c0       	rjmp	.+30     	; 0x18ac <LCD_sendCommand+0xd2>
    188e:	88 ec       	ldi	r24, 0xC8	; 200
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	9e a7       	std	Y+46, r25	; 0x2e
    1894:	8d a7       	std	Y+45, r24	; 0x2d
    1896:	8d a5       	ldd	r24, Y+45	; 0x2d
    1898:	9e a5       	ldd	r25, Y+46	; 0x2e
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	f1 f7       	brne	.-4      	; 0x189a <LCD_sendCommand+0xc0>
    189e:	9e a7       	std	Y+46, r25	; 0x2e
    18a0:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18a2:	8f a5       	ldd	r24, Y+47	; 0x2f
    18a4:	98 a9       	ldd	r25, Y+48	; 0x30
    18a6:	01 97       	sbiw	r24, 0x01	; 1
    18a8:	98 ab       	std	Y+48, r25	; 0x30
    18aa:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18ac:	8f a5       	ldd	r24, Y+47	; 0x2f
    18ae:	98 a9       	ldd	r25, Y+48	; 0x30
    18b0:	00 97       	sbiw	r24, 0x00	; 0
    18b2:	69 f7       	brne	.-38     	; 0x188e <LCD_sendCommand+0xb4>
    18b4:	14 c0       	rjmp	.+40     	; 0x18de <LCD_sendCommand+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18b6:	69 a9       	ldd	r22, Y+49	; 0x31
    18b8:	7a a9       	ldd	r23, Y+50	; 0x32
    18ba:	8b a9       	ldd	r24, Y+51	; 0x33
    18bc:	9c a9       	ldd	r25, Y+52	; 0x34
    18be:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    18c2:	dc 01       	movw	r26, r24
    18c4:	cb 01       	movw	r24, r22
    18c6:	98 ab       	std	Y+48, r25	; 0x30
    18c8:	8f a7       	std	Y+47, r24	; 0x2f
    18ca:	8f a5       	ldd	r24, Y+47	; 0x2f
    18cc:	98 a9       	ldd	r25, Y+48	; 0x30
    18ce:	9c a7       	std	Y+44, r25	; 0x2c
    18d0:	8b a7       	std	Y+43, r24	; 0x2b
    18d2:	8b a5       	ldd	r24, Y+43	; 0x2b
    18d4:	9c a5       	ldd	r25, Y+44	; 0x2c
    18d6:	01 97       	sbiw	r24, 0x01	; 1
    18d8:	f1 f7       	brne	.-4      	; 0x18d6 <LCD_sendCommand+0xfc>
    18da:	9c a7       	std	Y+44, r25	; 0x2c
    18dc:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    18de:	81 e0       	ldi	r24, 0x01	; 1
    18e0:	61 e0       	ldi	r22, 0x01	; 1
    18e2:	41 e0       	ldi	r20, 0x01	; 1
    18e4:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    18e8:	80 e0       	ldi	r24, 0x00	; 0
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	a0 e8       	ldi	r26, 0x80	; 128
    18ee:	bf e3       	ldi	r27, 0x3F	; 63
    18f0:	8f a3       	std	Y+39, r24	; 0x27
    18f2:	98 a7       	std	Y+40, r25	; 0x28
    18f4:	a9 a7       	std	Y+41, r26	; 0x29
    18f6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    18f8:	6f a1       	ldd	r22, Y+39	; 0x27
    18fa:	78 a5       	ldd	r23, Y+40	; 0x28
    18fc:	89 a5       	ldd	r24, Y+41	; 0x29
    18fe:	9a a5       	ldd	r25, Y+42	; 0x2a
    1900:	20 e0       	ldi	r18, 0x00	; 0
    1902:	30 e0       	ldi	r19, 0x00	; 0
    1904:	4a ef       	ldi	r20, 0xFA	; 250
    1906:	54 e4       	ldi	r21, 0x44	; 68
    1908:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    190c:	dc 01       	movw	r26, r24
    190e:	cb 01       	movw	r24, r22
    1910:	8b a3       	std	Y+35, r24	; 0x23
    1912:	9c a3       	std	Y+36, r25	; 0x24
    1914:	ad a3       	std	Y+37, r26	; 0x25
    1916:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1918:	6b a1       	ldd	r22, Y+35	; 0x23
    191a:	7c a1       	ldd	r23, Y+36	; 0x24
    191c:	8d a1       	ldd	r24, Y+37	; 0x25
    191e:	9e a1       	ldd	r25, Y+38	; 0x26
    1920:	20 e0       	ldi	r18, 0x00	; 0
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	40 e8       	ldi	r20, 0x80	; 128
    1926:	5f e3       	ldi	r21, 0x3F	; 63
    1928:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    192c:	88 23       	and	r24, r24
    192e:	2c f4       	brge	.+10     	; 0x193a <LCD_sendCommand+0x160>
		__ticks = 1;
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	9a a3       	std	Y+34, r25	; 0x22
    1936:	89 a3       	std	Y+33, r24	; 0x21
    1938:	3f c0       	rjmp	.+126    	; 0x19b8 <LCD_sendCommand+0x1de>
	else if (__tmp > 65535)
    193a:	6b a1       	ldd	r22, Y+35	; 0x23
    193c:	7c a1       	ldd	r23, Y+36	; 0x24
    193e:	8d a1       	ldd	r24, Y+37	; 0x25
    1940:	9e a1       	ldd	r25, Y+38	; 0x26
    1942:	20 e0       	ldi	r18, 0x00	; 0
    1944:	3f ef       	ldi	r19, 0xFF	; 255
    1946:	4f e7       	ldi	r20, 0x7F	; 127
    1948:	57 e4       	ldi	r21, 0x47	; 71
    194a:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    194e:	18 16       	cp	r1, r24
    1950:	4c f5       	brge	.+82     	; 0x19a4 <LCD_sendCommand+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1952:	6f a1       	ldd	r22, Y+39	; 0x27
    1954:	78 a5       	ldd	r23, Y+40	; 0x28
    1956:	89 a5       	ldd	r24, Y+41	; 0x29
    1958:	9a a5       	ldd	r25, Y+42	; 0x2a
    195a:	20 e0       	ldi	r18, 0x00	; 0
    195c:	30 e0       	ldi	r19, 0x00	; 0
    195e:	40 e2       	ldi	r20, 0x20	; 32
    1960:	51 e4       	ldi	r21, 0x41	; 65
    1962:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1966:	dc 01       	movw	r26, r24
    1968:	cb 01       	movw	r24, r22
    196a:	bc 01       	movw	r22, r24
    196c:	cd 01       	movw	r24, r26
    196e:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1972:	dc 01       	movw	r26, r24
    1974:	cb 01       	movw	r24, r22
    1976:	9a a3       	std	Y+34, r25	; 0x22
    1978:	89 a3       	std	Y+33, r24	; 0x21
    197a:	0f c0       	rjmp	.+30     	; 0x199a <LCD_sendCommand+0x1c0>
    197c:	88 ec       	ldi	r24, 0xC8	; 200
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	98 a3       	std	Y+32, r25	; 0x20
    1982:	8f 8f       	std	Y+31, r24	; 0x1f
    1984:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1986:	98 a1       	ldd	r25, Y+32	; 0x20
    1988:	01 97       	sbiw	r24, 0x01	; 1
    198a:	f1 f7       	brne	.-4      	; 0x1988 <LCD_sendCommand+0x1ae>
    198c:	98 a3       	std	Y+32, r25	; 0x20
    198e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1990:	89 a1       	ldd	r24, Y+33	; 0x21
    1992:	9a a1       	ldd	r25, Y+34	; 0x22
    1994:	01 97       	sbiw	r24, 0x01	; 1
    1996:	9a a3       	std	Y+34, r25	; 0x22
    1998:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    199a:	89 a1       	ldd	r24, Y+33	; 0x21
    199c:	9a a1       	ldd	r25, Y+34	; 0x22
    199e:	00 97       	sbiw	r24, 0x00	; 0
    19a0:	69 f7       	brne	.-38     	; 0x197c <LCD_sendCommand+0x1a2>
    19a2:	14 c0       	rjmp	.+40     	; 0x19cc <LCD_sendCommand+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19a4:	6b a1       	ldd	r22, Y+35	; 0x23
    19a6:	7c a1       	ldd	r23, Y+36	; 0x24
    19a8:	8d a1       	ldd	r24, Y+37	; 0x25
    19aa:	9e a1       	ldd	r25, Y+38	; 0x26
    19ac:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    19b0:	dc 01       	movw	r26, r24
    19b2:	cb 01       	movw	r24, r22
    19b4:	9a a3       	std	Y+34, r25	; 0x22
    19b6:	89 a3       	std	Y+33, r24	; 0x21
    19b8:	89 a1       	ldd	r24, Y+33	; 0x21
    19ba:	9a a1       	ldd	r25, Y+34	; 0x22
    19bc:	9e 8f       	std	Y+30, r25	; 0x1e
    19be:	8d 8f       	std	Y+29, r24	; 0x1d
    19c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    19c2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    19c4:	01 97       	sbiw	r24, 0x01	; 1
    19c6:	f1 f7       	brne	.-4      	; 0x19c4 <LCD_sendCommand+0x1ea>
    19c8:	9e 8f       	std	Y+30, r25	; 0x1e
    19ca:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	69 ad       	ldd	r22, Y+57	; 0x39
    19d0:	0e 94 c8 0a 	call	0x1590	; 0x1590 <GPIO_writePort>
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	a0 e8       	ldi	r26, 0x80	; 128
    19da:	bf e3       	ldi	r27, 0x3F	; 63
    19dc:	89 8f       	std	Y+25, r24	; 0x19
    19de:	9a 8f       	std	Y+26, r25	; 0x1a
    19e0:	ab 8f       	std	Y+27, r26	; 0x1b
    19e2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19e4:	69 8d       	ldd	r22, Y+25	; 0x19
    19e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    19e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    19ec:	20 e0       	ldi	r18, 0x00	; 0
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	4a ef       	ldi	r20, 0xFA	; 250
    19f2:	54 e4       	ldi	r21, 0x44	; 68
    19f4:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    19f8:	dc 01       	movw	r26, r24
    19fa:	cb 01       	movw	r24, r22
    19fc:	8d 8b       	std	Y+21, r24	; 0x15
    19fe:	9e 8b       	std	Y+22, r25	; 0x16
    1a00:	af 8b       	std	Y+23, r26	; 0x17
    1a02:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1a04:	6d 89       	ldd	r22, Y+21	; 0x15
    1a06:	7e 89       	ldd	r23, Y+22	; 0x16
    1a08:	8f 89       	ldd	r24, Y+23	; 0x17
    1a0a:	98 8d       	ldd	r25, Y+24	; 0x18
    1a0c:	20 e0       	ldi	r18, 0x00	; 0
    1a0e:	30 e0       	ldi	r19, 0x00	; 0
    1a10:	40 e8       	ldi	r20, 0x80	; 128
    1a12:	5f e3       	ldi	r21, 0x3F	; 63
    1a14:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1a18:	88 23       	and	r24, r24
    1a1a:	2c f4       	brge	.+10     	; 0x1a26 <LCD_sendCommand+0x24c>
		__ticks = 1;
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	9c 8b       	std	Y+20, r25	; 0x14
    1a22:	8b 8b       	std	Y+19, r24	; 0x13
    1a24:	3f c0       	rjmp	.+126    	; 0x1aa4 <LCD_sendCommand+0x2ca>
	else if (__tmp > 65535)
    1a26:	6d 89       	ldd	r22, Y+21	; 0x15
    1a28:	7e 89       	ldd	r23, Y+22	; 0x16
    1a2a:	8f 89       	ldd	r24, Y+23	; 0x17
    1a2c:	98 8d       	ldd	r25, Y+24	; 0x18
    1a2e:	20 e0       	ldi	r18, 0x00	; 0
    1a30:	3f ef       	ldi	r19, 0xFF	; 255
    1a32:	4f e7       	ldi	r20, 0x7F	; 127
    1a34:	57 e4       	ldi	r21, 0x47	; 71
    1a36:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1a3a:	18 16       	cp	r1, r24
    1a3c:	4c f5       	brge	.+82     	; 0x1a90 <LCD_sendCommand+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a3e:	69 8d       	ldd	r22, Y+25	; 0x19
    1a40:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1a42:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a44:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1a46:	20 e0       	ldi	r18, 0x00	; 0
    1a48:	30 e0       	ldi	r19, 0x00	; 0
    1a4a:	40 e2       	ldi	r20, 0x20	; 32
    1a4c:	51 e4       	ldi	r21, 0x41	; 65
    1a4e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1a52:	dc 01       	movw	r26, r24
    1a54:	cb 01       	movw	r24, r22
    1a56:	bc 01       	movw	r22, r24
    1a58:	cd 01       	movw	r24, r26
    1a5a:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1a5e:	dc 01       	movw	r26, r24
    1a60:	cb 01       	movw	r24, r22
    1a62:	9c 8b       	std	Y+20, r25	; 0x14
    1a64:	8b 8b       	std	Y+19, r24	; 0x13
    1a66:	0f c0       	rjmp	.+30     	; 0x1a86 <LCD_sendCommand+0x2ac>
    1a68:	88 ec       	ldi	r24, 0xC8	; 200
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	9a 8b       	std	Y+18, r25	; 0x12
    1a6e:	89 8b       	std	Y+17, r24	; 0x11
    1a70:	89 89       	ldd	r24, Y+17	; 0x11
    1a72:	9a 89       	ldd	r25, Y+18	; 0x12
    1a74:	01 97       	sbiw	r24, 0x01	; 1
    1a76:	f1 f7       	brne	.-4      	; 0x1a74 <LCD_sendCommand+0x29a>
    1a78:	9a 8b       	std	Y+18, r25	; 0x12
    1a7a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a7c:	8b 89       	ldd	r24, Y+19	; 0x13
    1a7e:	9c 89       	ldd	r25, Y+20	; 0x14
    1a80:	01 97       	sbiw	r24, 0x01	; 1
    1a82:	9c 8b       	std	Y+20, r25	; 0x14
    1a84:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a86:	8b 89       	ldd	r24, Y+19	; 0x13
    1a88:	9c 89       	ldd	r25, Y+20	; 0x14
    1a8a:	00 97       	sbiw	r24, 0x00	; 0
    1a8c:	69 f7       	brne	.-38     	; 0x1a68 <LCD_sendCommand+0x28e>
    1a8e:	14 c0       	rjmp	.+40     	; 0x1ab8 <LCD_sendCommand+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a90:	6d 89       	ldd	r22, Y+21	; 0x15
    1a92:	7e 89       	ldd	r23, Y+22	; 0x16
    1a94:	8f 89       	ldd	r24, Y+23	; 0x17
    1a96:	98 8d       	ldd	r25, Y+24	; 0x18
    1a98:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1a9c:	dc 01       	movw	r26, r24
    1a9e:	cb 01       	movw	r24, r22
    1aa0:	9c 8b       	std	Y+20, r25	; 0x14
    1aa2:	8b 8b       	std	Y+19, r24	; 0x13
    1aa4:	8b 89       	ldd	r24, Y+19	; 0x13
    1aa6:	9c 89       	ldd	r25, Y+20	; 0x14
    1aa8:	98 8b       	std	Y+16, r25	; 0x10
    1aaa:	8f 87       	std	Y+15, r24	; 0x0f
    1aac:	8f 85       	ldd	r24, Y+15	; 0x0f
    1aae:	98 89       	ldd	r25, Y+16	; 0x10
    1ab0:	01 97       	sbiw	r24, 0x01	; 1
    1ab2:	f1 f7       	brne	.-4      	; 0x1ab0 <LCD_sendCommand+0x2d6>
    1ab4:	98 8b       	std	Y+16, r25	; 0x10
    1ab6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	61 e0       	ldi	r22, 0x01	; 1
    1abc:	40 e0       	ldi	r20, 0x00	; 0
    1abe:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	a0 e8       	ldi	r26, 0x80	; 128
    1ac8:	bf e3       	ldi	r27, 0x3F	; 63
    1aca:	8b 87       	std	Y+11, r24	; 0x0b
    1acc:	9c 87       	std	Y+12, r25	; 0x0c
    1ace:	ad 87       	std	Y+13, r26	; 0x0d
    1ad0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ad2:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ad4:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ad6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ad8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ada:	20 e0       	ldi	r18, 0x00	; 0
    1adc:	30 e0       	ldi	r19, 0x00	; 0
    1ade:	4a ef       	ldi	r20, 0xFA	; 250
    1ae0:	54 e4       	ldi	r21, 0x44	; 68
    1ae2:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1ae6:	dc 01       	movw	r26, r24
    1ae8:	cb 01       	movw	r24, r22
    1aea:	8f 83       	std	Y+7, r24	; 0x07
    1aec:	98 87       	std	Y+8, r25	; 0x08
    1aee:	a9 87       	std	Y+9, r26	; 0x09
    1af0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1af2:	6f 81       	ldd	r22, Y+7	; 0x07
    1af4:	78 85       	ldd	r23, Y+8	; 0x08
    1af6:	89 85       	ldd	r24, Y+9	; 0x09
    1af8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	40 e8       	ldi	r20, 0x80	; 128
    1b00:	5f e3       	ldi	r21, 0x3F	; 63
    1b02:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1b06:	88 23       	and	r24, r24
    1b08:	2c f4       	brge	.+10     	; 0x1b14 <LCD_sendCommand+0x33a>
		__ticks = 1;
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	90 e0       	ldi	r25, 0x00	; 0
    1b0e:	9e 83       	std	Y+6, r25	; 0x06
    1b10:	8d 83       	std	Y+5, r24	; 0x05
    1b12:	3f c0       	rjmp	.+126    	; 0x1b92 <LCD_sendCommand+0x3b8>
	else if (__tmp > 65535)
    1b14:	6f 81       	ldd	r22, Y+7	; 0x07
    1b16:	78 85       	ldd	r23, Y+8	; 0x08
    1b18:	89 85       	ldd	r24, Y+9	; 0x09
    1b1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	3f ef       	ldi	r19, 0xFF	; 255
    1b20:	4f e7       	ldi	r20, 0x7F	; 127
    1b22:	57 e4       	ldi	r21, 0x47	; 71
    1b24:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1b28:	18 16       	cp	r1, r24
    1b2a:	4c f5       	brge	.+82     	; 0x1b7e <LCD_sendCommand+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b2c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b2e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b30:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b32:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b34:	20 e0       	ldi	r18, 0x00	; 0
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	40 e2       	ldi	r20, 0x20	; 32
    1b3a:	51 e4       	ldi	r21, 0x41	; 65
    1b3c:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1b40:	dc 01       	movw	r26, r24
    1b42:	cb 01       	movw	r24, r22
    1b44:	bc 01       	movw	r22, r24
    1b46:	cd 01       	movw	r24, r26
    1b48:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1b4c:	dc 01       	movw	r26, r24
    1b4e:	cb 01       	movw	r24, r22
    1b50:	9e 83       	std	Y+6, r25	; 0x06
    1b52:	8d 83       	std	Y+5, r24	; 0x05
    1b54:	0f c0       	rjmp	.+30     	; 0x1b74 <LCD_sendCommand+0x39a>
    1b56:	88 ec       	ldi	r24, 0xC8	; 200
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	9c 83       	std	Y+4, r25	; 0x04
    1b5c:	8b 83       	std	Y+3, r24	; 0x03
    1b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b60:	9c 81       	ldd	r25, Y+4	; 0x04
    1b62:	01 97       	sbiw	r24, 0x01	; 1
    1b64:	f1 f7       	brne	.-4      	; 0x1b62 <LCD_sendCommand+0x388>
    1b66:	9c 83       	std	Y+4, r25	; 0x04
    1b68:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b6e:	01 97       	sbiw	r24, 0x01	; 1
    1b70:	9e 83       	std	Y+6, r25	; 0x06
    1b72:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b74:	8d 81       	ldd	r24, Y+5	; 0x05
    1b76:	9e 81       	ldd	r25, Y+6	; 0x06
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	69 f7       	brne	.-38     	; 0x1b56 <LCD_sendCommand+0x37c>
    1b7c:	14 c0       	rjmp	.+40     	; 0x1ba6 <LCD_sendCommand+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b7e:	6f 81       	ldd	r22, Y+7	; 0x07
    1b80:	78 85       	ldd	r23, Y+8	; 0x08
    1b82:	89 85       	ldd	r24, Y+9	; 0x09
    1b84:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b86:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1b8a:	dc 01       	movw	r26, r24
    1b8c:	cb 01       	movw	r24, r22
    1b8e:	9e 83       	std	Y+6, r25	; 0x06
    1b90:	8d 83       	std	Y+5, r24	; 0x05
    1b92:	8d 81       	ldd	r24, Y+5	; 0x05
    1b94:	9e 81       	ldd	r25, Y+6	; 0x06
    1b96:	9a 83       	std	Y+2, r25	; 0x02
    1b98:	89 83       	std	Y+1, r24	; 0x01
    1b9a:	89 81       	ldd	r24, Y+1	; 0x01
    1b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9e:	01 97       	sbiw	r24, 0x01	; 1
    1ba0:	f1 f7       	brne	.-4      	; 0x1b9e <LCD_sendCommand+0x3c4>
    1ba2:	9a 83       	std	Y+2, r25	; 0x02
    1ba4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    1ba6:	e9 96       	adiw	r28, 0x39	; 57
    1ba8:	0f b6       	in	r0, 0x3f	; 63
    1baa:	f8 94       	cli
    1bac:	de bf       	out	0x3e, r29	; 62
    1bae:	0f be       	out	0x3f, r0	; 63
    1bb0:	cd bf       	out	0x3d, r28	; 61
    1bb2:	cf 91       	pop	r28
    1bb4:	df 91       	pop	r29
    1bb6:	08 95       	ret

00001bb8 <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    1bb8:	df 93       	push	r29
    1bba:	cf 93       	push	r28
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	e9 97       	sbiw	r28, 0x39	; 57
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	89 af       	std	Y+57, r24	; 0x39
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	60 e0       	ldi	r22, 0x00	; 0
    1bd2:	41 e0       	ldi	r20, 0x01	; 1
    1bd4:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	a0 e8       	ldi	r26, 0x80	; 128
    1bde:	bf e3       	ldi	r27, 0x3F	; 63
    1be0:	8d ab       	std	Y+53, r24	; 0x35
    1be2:	9e ab       	std	Y+54, r25	; 0x36
    1be4:	af ab       	std	Y+55, r26	; 0x37
    1be6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1be8:	6d a9       	ldd	r22, Y+53	; 0x35
    1bea:	7e a9       	ldd	r23, Y+54	; 0x36
    1bec:	8f a9       	ldd	r24, Y+55	; 0x37
    1bee:	98 ad       	ldd	r25, Y+56	; 0x38
    1bf0:	20 e0       	ldi	r18, 0x00	; 0
    1bf2:	30 e0       	ldi	r19, 0x00	; 0
    1bf4:	4a ef       	ldi	r20, 0xFA	; 250
    1bf6:	54 e4       	ldi	r21, 0x44	; 68
    1bf8:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1bfc:	dc 01       	movw	r26, r24
    1bfe:	cb 01       	movw	r24, r22
    1c00:	89 ab       	std	Y+49, r24	; 0x31
    1c02:	9a ab       	std	Y+50, r25	; 0x32
    1c04:	ab ab       	std	Y+51, r26	; 0x33
    1c06:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1c08:	69 a9       	ldd	r22, Y+49	; 0x31
    1c0a:	7a a9       	ldd	r23, Y+50	; 0x32
    1c0c:	8b a9       	ldd	r24, Y+51	; 0x33
    1c0e:	9c a9       	ldd	r25, Y+52	; 0x34
    1c10:	20 e0       	ldi	r18, 0x00	; 0
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	40 e8       	ldi	r20, 0x80	; 128
    1c16:	5f e3       	ldi	r21, 0x3F	; 63
    1c18:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1c1c:	88 23       	and	r24, r24
    1c1e:	2c f4       	brge	.+10     	; 0x1c2a <LCD_displayCharacter+0x72>
		__ticks = 1;
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	98 ab       	std	Y+48, r25	; 0x30
    1c26:	8f a7       	std	Y+47, r24	; 0x2f
    1c28:	3f c0       	rjmp	.+126    	; 0x1ca8 <LCD_displayCharacter+0xf0>
	else if (__tmp > 65535)
    1c2a:	69 a9       	ldd	r22, Y+49	; 0x31
    1c2c:	7a a9       	ldd	r23, Y+50	; 0x32
    1c2e:	8b a9       	ldd	r24, Y+51	; 0x33
    1c30:	9c a9       	ldd	r25, Y+52	; 0x34
    1c32:	20 e0       	ldi	r18, 0x00	; 0
    1c34:	3f ef       	ldi	r19, 0xFF	; 255
    1c36:	4f e7       	ldi	r20, 0x7F	; 127
    1c38:	57 e4       	ldi	r21, 0x47	; 71
    1c3a:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1c3e:	18 16       	cp	r1, r24
    1c40:	4c f5       	brge	.+82     	; 0x1c94 <LCD_displayCharacter+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c42:	6d a9       	ldd	r22, Y+53	; 0x35
    1c44:	7e a9       	ldd	r23, Y+54	; 0x36
    1c46:	8f a9       	ldd	r24, Y+55	; 0x37
    1c48:	98 ad       	ldd	r25, Y+56	; 0x38
    1c4a:	20 e0       	ldi	r18, 0x00	; 0
    1c4c:	30 e0       	ldi	r19, 0x00	; 0
    1c4e:	40 e2       	ldi	r20, 0x20	; 32
    1c50:	51 e4       	ldi	r21, 0x41	; 65
    1c52:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1c56:	dc 01       	movw	r26, r24
    1c58:	cb 01       	movw	r24, r22
    1c5a:	bc 01       	movw	r22, r24
    1c5c:	cd 01       	movw	r24, r26
    1c5e:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1c62:	dc 01       	movw	r26, r24
    1c64:	cb 01       	movw	r24, r22
    1c66:	98 ab       	std	Y+48, r25	; 0x30
    1c68:	8f a7       	std	Y+47, r24	; 0x2f
    1c6a:	0f c0       	rjmp	.+30     	; 0x1c8a <LCD_displayCharacter+0xd2>
    1c6c:	88 ec       	ldi	r24, 0xC8	; 200
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	9e a7       	std	Y+46, r25	; 0x2e
    1c72:	8d a7       	std	Y+45, r24	; 0x2d
    1c74:	8d a5       	ldd	r24, Y+45	; 0x2d
    1c76:	9e a5       	ldd	r25, Y+46	; 0x2e
    1c78:	01 97       	sbiw	r24, 0x01	; 1
    1c7a:	f1 f7       	brne	.-4      	; 0x1c78 <LCD_displayCharacter+0xc0>
    1c7c:	9e a7       	std	Y+46, r25	; 0x2e
    1c7e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c80:	8f a5       	ldd	r24, Y+47	; 0x2f
    1c82:	98 a9       	ldd	r25, Y+48	; 0x30
    1c84:	01 97       	sbiw	r24, 0x01	; 1
    1c86:	98 ab       	std	Y+48, r25	; 0x30
    1c88:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c8a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1c8c:	98 a9       	ldd	r25, Y+48	; 0x30
    1c8e:	00 97       	sbiw	r24, 0x00	; 0
    1c90:	69 f7       	brne	.-38     	; 0x1c6c <LCD_displayCharacter+0xb4>
    1c92:	14 c0       	rjmp	.+40     	; 0x1cbc <LCD_displayCharacter+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c94:	69 a9       	ldd	r22, Y+49	; 0x31
    1c96:	7a a9       	ldd	r23, Y+50	; 0x32
    1c98:	8b a9       	ldd	r24, Y+51	; 0x33
    1c9a:	9c a9       	ldd	r25, Y+52	; 0x34
    1c9c:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1ca0:	dc 01       	movw	r26, r24
    1ca2:	cb 01       	movw	r24, r22
    1ca4:	98 ab       	std	Y+48, r25	; 0x30
    1ca6:	8f a7       	std	Y+47, r24	; 0x2f
    1ca8:	8f a5       	ldd	r24, Y+47	; 0x2f
    1caa:	98 a9       	ldd	r25, Y+48	; 0x30
    1cac:	9c a7       	std	Y+44, r25	; 0x2c
    1cae:	8b a7       	std	Y+43, r24	; 0x2b
    1cb0:	8b a5       	ldd	r24, Y+43	; 0x2b
    1cb2:	9c a5       	ldd	r25, Y+44	; 0x2c
    1cb4:	01 97       	sbiw	r24, 0x01	; 1
    1cb6:	f1 f7       	brne	.-4      	; 0x1cb4 <LCD_displayCharacter+0xfc>
    1cb8:	9c a7       	std	Y+44, r25	; 0x2c
    1cba:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	61 e0       	ldi	r22, 0x01	; 1
    1cc0:	41 e0       	ldi	r20, 0x01	; 1
    1cc2:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    1cc6:	80 e0       	ldi	r24, 0x00	; 0
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	a0 e8       	ldi	r26, 0x80	; 128
    1ccc:	bf e3       	ldi	r27, 0x3F	; 63
    1cce:	8f a3       	std	Y+39, r24	; 0x27
    1cd0:	98 a7       	std	Y+40, r25	; 0x28
    1cd2:	a9 a7       	std	Y+41, r26	; 0x29
    1cd4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cd6:	6f a1       	ldd	r22, Y+39	; 0x27
    1cd8:	78 a5       	ldd	r23, Y+40	; 0x28
    1cda:	89 a5       	ldd	r24, Y+41	; 0x29
    1cdc:	9a a5       	ldd	r25, Y+42	; 0x2a
    1cde:	20 e0       	ldi	r18, 0x00	; 0
    1ce0:	30 e0       	ldi	r19, 0x00	; 0
    1ce2:	4a ef       	ldi	r20, 0xFA	; 250
    1ce4:	54 e4       	ldi	r21, 0x44	; 68
    1ce6:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1cea:	dc 01       	movw	r26, r24
    1cec:	cb 01       	movw	r24, r22
    1cee:	8b a3       	std	Y+35, r24	; 0x23
    1cf0:	9c a3       	std	Y+36, r25	; 0x24
    1cf2:	ad a3       	std	Y+37, r26	; 0x25
    1cf4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1cf6:	6b a1       	ldd	r22, Y+35	; 0x23
    1cf8:	7c a1       	ldd	r23, Y+36	; 0x24
    1cfa:	8d a1       	ldd	r24, Y+37	; 0x25
    1cfc:	9e a1       	ldd	r25, Y+38	; 0x26
    1cfe:	20 e0       	ldi	r18, 0x00	; 0
    1d00:	30 e0       	ldi	r19, 0x00	; 0
    1d02:	40 e8       	ldi	r20, 0x80	; 128
    1d04:	5f e3       	ldi	r21, 0x3F	; 63
    1d06:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1d0a:	88 23       	and	r24, r24
    1d0c:	2c f4       	brge	.+10     	; 0x1d18 <LCD_displayCharacter+0x160>
		__ticks = 1;
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	9a a3       	std	Y+34, r25	; 0x22
    1d14:	89 a3       	std	Y+33, r24	; 0x21
    1d16:	3f c0       	rjmp	.+126    	; 0x1d96 <LCD_displayCharacter+0x1de>
	else if (__tmp > 65535)
    1d18:	6b a1       	ldd	r22, Y+35	; 0x23
    1d1a:	7c a1       	ldd	r23, Y+36	; 0x24
    1d1c:	8d a1       	ldd	r24, Y+37	; 0x25
    1d1e:	9e a1       	ldd	r25, Y+38	; 0x26
    1d20:	20 e0       	ldi	r18, 0x00	; 0
    1d22:	3f ef       	ldi	r19, 0xFF	; 255
    1d24:	4f e7       	ldi	r20, 0x7F	; 127
    1d26:	57 e4       	ldi	r21, 0x47	; 71
    1d28:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1d2c:	18 16       	cp	r1, r24
    1d2e:	4c f5       	brge	.+82     	; 0x1d82 <LCD_displayCharacter+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d30:	6f a1       	ldd	r22, Y+39	; 0x27
    1d32:	78 a5       	ldd	r23, Y+40	; 0x28
    1d34:	89 a5       	ldd	r24, Y+41	; 0x29
    1d36:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d38:	20 e0       	ldi	r18, 0x00	; 0
    1d3a:	30 e0       	ldi	r19, 0x00	; 0
    1d3c:	40 e2       	ldi	r20, 0x20	; 32
    1d3e:	51 e4       	ldi	r21, 0x41	; 65
    1d40:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1d44:	dc 01       	movw	r26, r24
    1d46:	cb 01       	movw	r24, r22
    1d48:	bc 01       	movw	r22, r24
    1d4a:	cd 01       	movw	r24, r26
    1d4c:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1d50:	dc 01       	movw	r26, r24
    1d52:	cb 01       	movw	r24, r22
    1d54:	9a a3       	std	Y+34, r25	; 0x22
    1d56:	89 a3       	std	Y+33, r24	; 0x21
    1d58:	0f c0       	rjmp	.+30     	; 0x1d78 <LCD_displayCharacter+0x1c0>
    1d5a:	88 ec       	ldi	r24, 0xC8	; 200
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	98 a3       	std	Y+32, r25	; 0x20
    1d60:	8f 8f       	std	Y+31, r24	; 0x1f
    1d62:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1d64:	98 a1       	ldd	r25, Y+32	; 0x20
    1d66:	01 97       	sbiw	r24, 0x01	; 1
    1d68:	f1 f7       	brne	.-4      	; 0x1d66 <LCD_displayCharacter+0x1ae>
    1d6a:	98 a3       	std	Y+32, r25	; 0x20
    1d6c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d6e:	89 a1       	ldd	r24, Y+33	; 0x21
    1d70:	9a a1       	ldd	r25, Y+34	; 0x22
    1d72:	01 97       	sbiw	r24, 0x01	; 1
    1d74:	9a a3       	std	Y+34, r25	; 0x22
    1d76:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d78:	89 a1       	ldd	r24, Y+33	; 0x21
    1d7a:	9a a1       	ldd	r25, Y+34	; 0x22
    1d7c:	00 97       	sbiw	r24, 0x00	; 0
    1d7e:	69 f7       	brne	.-38     	; 0x1d5a <LCD_displayCharacter+0x1a2>
    1d80:	14 c0       	rjmp	.+40     	; 0x1daa <LCD_displayCharacter+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d82:	6b a1       	ldd	r22, Y+35	; 0x23
    1d84:	7c a1       	ldd	r23, Y+36	; 0x24
    1d86:	8d a1       	ldd	r24, Y+37	; 0x25
    1d88:	9e a1       	ldd	r25, Y+38	; 0x26
    1d8a:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1d8e:	dc 01       	movw	r26, r24
    1d90:	cb 01       	movw	r24, r22
    1d92:	9a a3       	std	Y+34, r25	; 0x22
    1d94:	89 a3       	std	Y+33, r24	; 0x21
    1d96:	89 a1       	ldd	r24, Y+33	; 0x21
    1d98:	9a a1       	ldd	r25, Y+34	; 0x22
    1d9a:	9e 8f       	std	Y+30, r25	; 0x1e
    1d9c:	8d 8f       	std	Y+29, r24	; 0x1d
    1d9e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1da0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1da2:	01 97       	sbiw	r24, 0x01	; 1
    1da4:	f1 f7       	brne	.-4      	; 0x1da2 <LCD_displayCharacter+0x1ea>
    1da6:	9e 8f       	std	Y+30, r25	; 0x1e
    1da8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	69 ad       	ldd	r22, Y+57	; 0x39
    1dae:	0e 94 c8 0a 	call	0x1590	; 0x1590 <GPIO_writePort>
    1db2:	80 e0       	ldi	r24, 0x00	; 0
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	a0 e8       	ldi	r26, 0x80	; 128
    1db8:	bf e3       	ldi	r27, 0x3F	; 63
    1dba:	89 8f       	std	Y+25, r24	; 0x19
    1dbc:	9a 8f       	std	Y+26, r25	; 0x1a
    1dbe:	ab 8f       	std	Y+27, r26	; 0x1b
    1dc0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dc2:	69 8d       	ldd	r22, Y+25	; 0x19
    1dc4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1dc6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dc8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1dca:	20 e0       	ldi	r18, 0x00	; 0
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	4a ef       	ldi	r20, 0xFA	; 250
    1dd0:	54 e4       	ldi	r21, 0x44	; 68
    1dd2:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1dd6:	dc 01       	movw	r26, r24
    1dd8:	cb 01       	movw	r24, r22
    1dda:	8d 8b       	std	Y+21, r24	; 0x15
    1ddc:	9e 8b       	std	Y+22, r25	; 0x16
    1dde:	af 8b       	std	Y+23, r26	; 0x17
    1de0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1de2:	6d 89       	ldd	r22, Y+21	; 0x15
    1de4:	7e 89       	ldd	r23, Y+22	; 0x16
    1de6:	8f 89       	ldd	r24, Y+23	; 0x17
    1de8:	98 8d       	ldd	r25, Y+24	; 0x18
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	40 e8       	ldi	r20, 0x80	; 128
    1df0:	5f e3       	ldi	r21, 0x3F	; 63
    1df2:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1df6:	88 23       	and	r24, r24
    1df8:	2c f4       	brge	.+10     	; 0x1e04 <LCD_displayCharacter+0x24c>
		__ticks = 1;
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	9c 8b       	std	Y+20, r25	; 0x14
    1e00:	8b 8b       	std	Y+19, r24	; 0x13
    1e02:	3f c0       	rjmp	.+126    	; 0x1e82 <LCD_displayCharacter+0x2ca>
	else if (__tmp > 65535)
    1e04:	6d 89       	ldd	r22, Y+21	; 0x15
    1e06:	7e 89       	ldd	r23, Y+22	; 0x16
    1e08:	8f 89       	ldd	r24, Y+23	; 0x17
    1e0a:	98 8d       	ldd	r25, Y+24	; 0x18
    1e0c:	20 e0       	ldi	r18, 0x00	; 0
    1e0e:	3f ef       	ldi	r19, 0xFF	; 255
    1e10:	4f e7       	ldi	r20, 0x7F	; 127
    1e12:	57 e4       	ldi	r21, 0x47	; 71
    1e14:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1e18:	18 16       	cp	r1, r24
    1e1a:	4c f5       	brge	.+82     	; 0x1e6e <LCD_displayCharacter+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e1c:	69 8d       	ldd	r22, Y+25	; 0x19
    1e1e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1e20:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e22:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e24:	20 e0       	ldi	r18, 0x00	; 0
    1e26:	30 e0       	ldi	r19, 0x00	; 0
    1e28:	40 e2       	ldi	r20, 0x20	; 32
    1e2a:	51 e4       	ldi	r21, 0x41	; 65
    1e2c:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1e30:	dc 01       	movw	r26, r24
    1e32:	cb 01       	movw	r24, r22
    1e34:	bc 01       	movw	r22, r24
    1e36:	cd 01       	movw	r24, r26
    1e38:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1e3c:	dc 01       	movw	r26, r24
    1e3e:	cb 01       	movw	r24, r22
    1e40:	9c 8b       	std	Y+20, r25	; 0x14
    1e42:	8b 8b       	std	Y+19, r24	; 0x13
    1e44:	0f c0       	rjmp	.+30     	; 0x1e64 <LCD_displayCharacter+0x2ac>
    1e46:	88 ec       	ldi	r24, 0xC8	; 200
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	9a 8b       	std	Y+18, r25	; 0x12
    1e4c:	89 8b       	std	Y+17, r24	; 0x11
    1e4e:	89 89       	ldd	r24, Y+17	; 0x11
    1e50:	9a 89       	ldd	r25, Y+18	; 0x12
    1e52:	01 97       	sbiw	r24, 0x01	; 1
    1e54:	f1 f7       	brne	.-4      	; 0x1e52 <LCD_displayCharacter+0x29a>
    1e56:	9a 8b       	std	Y+18, r25	; 0x12
    1e58:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e5a:	8b 89       	ldd	r24, Y+19	; 0x13
    1e5c:	9c 89       	ldd	r25, Y+20	; 0x14
    1e5e:	01 97       	sbiw	r24, 0x01	; 1
    1e60:	9c 8b       	std	Y+20, r25	; 0x14
    1e62:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e64:	8b 89       	ldd	r24, Y+19	; 0x13
    1e66:	9c 89       	ldd	r25, Y+20	; 0x14
    1e68:	00 97       	sbiw	r24, 0x00	; 0
    1e6a:	69 f7       	brne	.-38     	; 0x1e46 <LCD_displayCharacter+0x28e>
    1e6c:	14 c0       	rjmp	.+40     	; 0x1e96 <LCD_displayCharacter+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e6e:	6d 89       	ldd	r22, Y+21	; 0x15
    1e70:	7e 89       	ldd	r23, Y+22	; 0x16
    1e72:	8f 89       	ldd	r24, Y+23	; 0x17
    1e74:	98 8d       	ldd	r25, Y+24	; 0x18
    1e76:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1e7a:	dc 01       	movw	r26, r24
    1e7c:	cb 01       	movw	r24, r22
    1e7e:	9c 8b       	std	Y+20, r25	; 0x14
    1e80:	8b 8b       	std	Y+19, r24	; 0x13
    1e82:	8b 89       	ldd	r24, Y+19	; 0x13
    1e84:	9c 89       	ldd	r25, Y+20	; 0x14
    1e86:	98 8b       	std	Y+16, r25	; 0x10
    1e88:	8f 87       	std	Y+15, r24	; 0x0f
    1e8a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e8c:	98 89       	ldd	r25, Y+16	; 0x10
    1e8e:	01 97       	sbiw	r24, 0x01	; 1
    1e90:	f1 f7       	brne	.-4      	; 0x1e8e <LCD_displayCharacter+0x2d6>
    1e92:	98 8b       	std	Y+16, r25	; 0x10
    1e94:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	61 e0       	ldi	r22, 0x01	; 1
    1e9a:	40 e0       	ldi	r20, 0x00	; 0
    1e9c:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>
    1ea0:	80 e0       	ldi	r24, 0x00	; 0
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	a0 e8       	ldi	r26, 0x80	; 128
    1ea6:	bf e3       	ldi	r27, 0x3F	; 63
    1ea8:	8b 87       	std	Y+11, r24	; 0x0b
    1eaa:	9c 87       	std	Y+12, r25	; 0x0c
    1eac:	ad 87       	std	Y+13, r26	; 0x0d
    1eae:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1eb0:	6b 85       	ldd	r22, Y+11	; 0x0b
    1eb2:	7c 85       	ldd	r23, Y+12	; 0x0c
    1eb4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eb6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eb8:	20 e0       	ldi	r18, 0x00	; 0
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	4a ef       	ldi	r20, 0xFA	; 250
    1ebe:	54 e4       	ldi	r21, 0x44	; 68
    1ec0:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1ec4:	dc 01       	movw	r26, r24
    1ec6:	cb 01       	movw	r24, r22
    1ec8:	8f 83       	std	Y+7, r24	; 0x07
    1eca:	98 87       	std	Y+8, r25	; 0x08
    1ecc:	a9 87       	std	Y+9, r26	; 0x09
    1ece:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1ed0:	6f 81       	ldd	r22, Y+7	; 0x07
    1ed2:	78 85       	ldd	r23, Y+8	; 0x08
    1ed4:	89 85       	ldd	r24, Y+9	; 0x09
    1ed6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ed8:	20 e0       	ldi	r18, 0x00	; 0
    1eda:	30 e0       	ldi	r19, 0x00	; 0
    1edc:	40 e8       	ldi	r20, 0x80	; 128
    1ede:	5f e3       	ldi	r21, 0x3F	; 63
    1ee0:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    1ee4:	88 23       	and	r24, r24
    1ee6:	2c f4       	brge	.+10     	; 0x1ef2 <LCD_displayCharacter+0x33a>
		__ticks = 1;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	9e 83       	std	Y+6, r25	; 0x06
    1eee:	8d 83       	std	Y+5, r24	; 0x05
    1ef0:	3f c0       	rjmp	.+126    	; 0x1f70 <LCD_displayCharacter+0x3b8>
	else if (__tmp > 65535)
    1ef2:	6f 81       	ldd	r22, Y+7	; 0x07
    1ef4:	78 85       	ldd	r23, Y+8	; 0x08
    1ef6:	89 85       	ldd	r24, Y+9	; 0x09
    1ef8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1efa:	20 e0       	ldi	r18, 0x00	; 0
    1efc:	3f ef       	ldi	r19, 0xFF	; 255
    1efe:	4f e7       	ldi	r20, 0x7F	; 127
    1f00:	57 e4       	ldi	r21, 0x47	; 71
    1f02:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    1f06:	18 16       	cp	r1, r24
    1f08:	4c f5       	brge	.+82     	; 0x1f5c <LCD_displayCharacter+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f0a:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f0c:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f0e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f10:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	40 e2       	ldi	r20, 0x20	; 32
    1f18:	51 e4       	ldi	r21, 0x41	; 65
    1f1a:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    1f1e:	dc 01       	movw	r26, r24
    1f20:	cb 01       	movw	r24, r22
    1f22:	bc 01       	movw	r22, r24
    1f24:	cd 01       	movw	r24, r26
    1f26:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1f2a:	dc 01       	movw	r26, r24
    1f2c:	cb 01       	movw	r24, r22
    1f2e:	9e 83       	std	Y+6, r25	; 0x06
    1f30:	8d 83       	std	Y+5, r24	; 0x05
    1f32:	0f c0       	rjmp	.+30     	; 0x1f52 <LCD_displayCharacter+0x39a>
    1f34:	88 ec       	ldi	r24, 0xC8	; 200
    1f36:	90 e0       	ldi	r25, 0x00	; 0
    1f38:	9c 83       	std	Y+4, r25	; 0x04
    1f3a:	8b 83       	std	Y+3, r24	; 0x03
    1f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f40:	01 97       	sbiw	r24, 0x01	; 1
    1f42:	f1 f7       	brne	.-4      	; 0x1f40 <LCD_displayCharacter+0x388>
    1f44:	9c 83       	std	Y+4, r25	; 0x04
    1f46:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f48:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f4c:	01 97       	sbiw	r24, 0x01	; 1
    1f4e:	9e 83       	std	Y+6, r25	; 0x06
    1f50:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f52:	8d 81       	ldd	r24, Y+5	; 0x05
    1f54:	9e 81       	ldd	r25, Y+6	; 0x06
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	69 f7       	brne	.-38     	; 0x1f34 <LCD_displayCharacter+0x37c>
    1f5a:	14 c0       	rjmp	.+40     	; 0x1f84 <LCD_displayCharacter+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f5c:	6f 81       	ldd	r22, Y+7	; 0x07
    1f5e:	78 85       	ldd	r23, Y+8	; 0x08
    1f60:	89 85       	ldd	r24, Y+9	; 0x09
    1f62:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f64:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    1f68:	dc 01       	movw	r26, r24
    1f6a:	cb 01       	movw	r24, r22
    1f6c:	9e 83       	std	Y+6, r25	; 0x06
    1f6e:	8d 83       	std	Y+5, r24	; 0x05
    1f70:	8d 81       	ldd	r24, Y+5	; 0x05
    1f72:	9e 81       	ldd	r25, Y+6	; 0x06
    1f74:	9a 83       	std	Y+2, r25	; 0x02
    1f76:	89 83       	std	Y+1, r24	; 0x01
    1f78:	89 81       	ldd	r24, Y+1	; 0x01
    1f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7c:	01 97       	sbiw	r24, 0x01	; 1
    1f7e:	f1 f7       	brne	.-4      	; 0x1f7c <LCD_displayCharacter+0x3c4>
    1f80:	9a 83       	std	Y+2, r25	; 0x02
    1f82:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    1f84:	e9 96       	adiw	r28, 0x39	; 57
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	cf 91       	pop	r28
    1f92:	df 91       	pop	r29
    1f94:	08 95       	ret

00001f96 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    1f96:	df 93       	push	r29
    1f98:	cf 93       	push	r28
    1f9a:	00 d0       	rcall	.+0      	; 0x1f9c <LCD_displayString+0x6>
    1f9c:	0f 92       	push	r0
    1f9e:	cd b7       	in	r28, 0x3d	; 61
    1fa0:	de b7       	in	r29, 0x3e	; 62
    1fa2:	9b 83       	std	Y+3, r25	; 0x03
    1fa4:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1fa6:	19 82       	std	Y+1, r1	; 0x01
    1fa8:	0e c0       	rjmp	.+28     	; 0x1fc6 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1faa:	89 81       	ldd	r24, Y+1	; 0x01
    1fac:	28 2f       	mov	r18, r24
    1fae:	30 e0       	ldi	r19, 0x00	; 0
    1fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb2:	9b 81       	ldd	r25, Y+3	; 0x03
    1fb4:	fc 01       	movw	r30, r24
    1fb6:	e2 0f       	add	r30, r18
    1fb8:	f3 1f       	adc	r31, r19
    1fba:	80 81       	ld	r24, Z
    1fbc:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <LCD_displayCharacter>
		i++;
    1fc0:	89 81       	ldd	r24, Y+1	; 0x01
    1fc2:	8f 5f       	subi	r24, 0xFF	; 255
    1fc4:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    1fc6:	89 81       	ldd	r24, Y+1	; 0x01
    1fc8:	28 2f       	mov	r18, r24
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fce:	9b 81       	ldd	r25, Y+3	; 0x03
    1fd0:	fc 01       	movw	r30, r24
    1fd2:	e2 0f       	add	r30, r18
    1fd4:	f3 1f       	adc	r31, r19
    1fd6:	80 81       	ld	r24, Z
    1fd8:	88 23       	and	r24, r24
    1fda:	39 f7       	brne	.-50     	; 0x1faa <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}
	*********************************************************/
}
    1fdc:	0f 90       	pop	r0
    1fde:	0f 90       	pop	r0
    1fe0:	0f 90       	pop	r0
    1fe2:	cf 91       	pop	r28
    1fe4:	df 91       	pop	r29
    1fe6:	08 95       	ret

00001fe8 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    1fe8:	df 93       	push	r29
    1fea:	cf 93       	push	r28
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <LCD_moveCursor+0x6>
    1fee:	00 d0       	rcall	.+0      	; 0x1ff0 <LCD_moveCursor+0x8>
    1ff0:	0f 92       	push	r0
    1ff2:	cd b7       	in	r28, 0x3d	; 61
    1ff4:	de b7       	in	r29, 0x3e	; 62
    1ff6:	8a 83       	std	Y+2, r24	; 0x02
    1ff8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;

	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    1ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffc:	28 2f       	mov	r18, r24
    1ffe:	30 e0       	ldi	r19, 0x00	; 0
    2000:	3d 83       	std	Y+5, r19	; 0x05
    2002:	2c 83       	std	Y+4, r18	; 0x04
    2004:	8c 81       	ldd	r24, Y+4	; 0x04
    2006:	9d 81       	ldd	r25, Y+5	; 0x05
    2008:	81 30       	cpi	r24, 0x01	; 1
    200a:	91 05       	cpc	r25, r1
    200c:	c1 f0       	breq	.+48     	; 0x203e <LCD_moveCursor+0x56>
    200e:	2c 81       	ldd	r18, Y+4	; 0x04
    2010:	3d 81       	ldd	r19, Y+5	; 0x05
    2012:	22 30       	cpi	r18, 0x02	; 2
    2014:	31 05       	cpc	r19, r1
    2016:	2c f4       	brge	.+10     	; 0x2022 <LCD_moveCursor+0x3a>
    2018:	8c 81       	ldd	r24, Y+4	; 0x04
    201a:	9d 81       	ldd	r25, Y+5	; 0x05
    201c:	00 97       	sbiw	r24, 0x00	; 0
    201e:	61 f0       	breq	.+24     	; 0x2038 <LCD_moveCursor+0x50>
    2020:	19 c0       	rjmp	.+50     	; 0x2054 <LCD_moveCursor+0x6c>
    2022:	2c 81       	ldd	r18, Y+4	; 0x04
    2024:	3d 81       	ldd	r19, Y+5	; 0x05
    2026:	22 30       	cpi	r18, 0x02	; 2
    2028:	31 05       	cpc	r19, r1
    202a:	69 f0       	breq	.+26     	; 0x2046 <LCD_moveCursor+0x5e>
    202c:	8c 81       	ldd	r24, Y+4	; 0x04
    202e:	9d 81       	ldd	r25, Y+5	; 0x05
    2030:	83 30       	cpi	r24, 0x03	; 3
    2032:	91 05       	cpc	r25, r1
    2034:	61 f0       	breq	.+24     	; 0x204e <LCD_moveCursor+0x66>
    2036:	0e c0       	rjmp	.+28     	; 0x2054 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	89 83       	std	Y+1, r24	; 0x01
    203c:	0b c0       	rjmp	.+22     	; 0x2054 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	80 5c       	subi	r24, 0xC0	; 192
    2042:	89 83       	std	Y+1, r24	; 0x01
    2044:	07 c0       	rjmp	.+14     	; 0x2054 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    2046:	8b 81       	ldd	r24, Y+3	; 0x03
    2048:	80 5f       	subi	r24, 0xF0	; 240
    204a:	89 83       	std	Y+1, r24	; 0x01
    204c:	03 c0       	rjmp	.+6      	; 0x2054 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    204e:	8b 81       	ldd	r24, Y+3	; 0x03
    2050:	80 5b       	subi	r24, 0xB0	; 176
    2052:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    2054:	89 81       	ldd	r24, Y+1	; 0x01
    2056:	80 68       	ori	r24, 0x80	; 128
    2058:	0e 94 ed 0b 	call	0x17da	; 0x17da <LCD_sendCommand>
}
    205c:	0f 90       	pop	r0
    205e:	0f 90       	pop	r0
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	0f 90       	pop	r0
    2066:	cf 91       	pop	r28
    2068:	df 91       	pop	r29
    206a:	08 95       	ret

0000206c <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    206c:	df 93       	push	r29
    206e:	cf 93       	push	r28
    2070:	00 d0       	rcall	.+0      	; 0x2072 <LCD_displayStringRowColumn+0x6>
    2072:	00 d0       	rcall	.+0      	; 0x2074 <LCD_displayStringRowColumn+0x8>
    2074:	cd b7       	in	r28, 0x3d	; 61
    2076:	de b7       	in	r29, 0x3e	; 62
    2078:	89 83       	std	Y+1, r24	; 0x01
    207a:	6a 83       	std	Y+2, r22	; 0x02
    207c:	5c 83       	std	Y+4, r21	; 0x04
    207e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	6a 81       	ldd	r22, Y+2	; 0x02
    2084:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    2088:	8b 81       	ldd	r24, Y+3	; 0x03
    208a:	9c 81       	ldd	r25, Y+4	; 0x04
    208c:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <LCD_displayString>
}
    2090:	0f 90       	pop	r0
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	cf 91       	pop	r28
    209a:	df 91       	pop	r29
    209c:	08 95       	ret

0000209e <LCD_integerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_integerToString(int data)
{
    209e:	df 93       	push	r29
    20a0:	cf 93       	push	r28
    20a2:	cd b7       	in	r28, 0x3d	; 61
    20a4:	de b7       	in	r29, 0x3e	; 62
    20a6:	62 97       	sbiw	r28, 0x12	; 18
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	f8 94       	cli
    20ac:	de bf       	out	0x3e, r29	; 62
    20ae:	0f be       	out	0x3f, r0	; 63
    20b0:	cd bf       	out	0x3d, r28	; 61
    20b2:	9a 8b       	std	Y+18, r25	; 0x12
    20b4:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    20b6:	89 89       	ldd	r24, Y+17	; 0x11
    20b8:	9a 89       	ldd	r25, Y+18	; 0x12
    20ba:	9e 01       	movw	r18, r28
    20bc:	2f 5f       	subi	r18, 0xFF	; 255
    20be:	3f 4f       	sbci	r19, 0xFF	; 255
    20c0:	b9 01       	movw	r22, r18
    20c2:	4a e0       	ldi	r20, 0x0A	; 10
    20c4:	50 e0       	ldi	r21, 0x00	; 0
    20c6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <itoa>
   LCD_displayString(buff); /* Display the string */
    20ca:	ce 01       	movw	r24, r28
    20cc:	01 96       	adiw	r24, 0x01	; 1
    20ce:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <LCD_displayString>
}
    20d2:	62 96       	adiw	r28, 0x12	; 18
    20d4:	0f b6       	in	r0, 0x3f	; 63
    20d6:	f8 94       	cli
    20d8:	de bf       	out	0x3e, r29	; 62
    20da:	0f be       	out	0x3f, r0	; 63
    20dc:	cd bf       	out	0x3d, r28	; 61
    20de:	cf 91       	pop	r28
    20e0:	df 91       	pop	r29
    20e2:	08 95       	ret

000020e4 <LCD_floatToString>:

/*
 * Description :
 * Converts a floating-point/double number to a string.
 */
void LCD_floatToString(float32 data) {
    20e4:	0f 93       	push	r16
    20e6:	1f 93       	push	r17
    20e8:	df 93       	push	r29
    20ea:	cf 93       	push	r28
    20ec:	cd b7       	in	r28, 0x3d	; 61
    20ee:	de b7       	in	r29, 0x3e	; 62
    20f0:	64 97       	sbiw	r28, 0x14	; 20
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	de bf       	out	0x3e, r29	; 62
    20f8:	0f be       	out	0x3f, r0	; 63
    20fa:	cd bf       	out	0x3d, r28	; 61
    20fc:	69 8b       	std	Y+17, r22	; 0x11
    20fe:	7a 8b       	std	Y+18, r23	; 0x12
    2100:	8b 8b       	std	Y+19, r24	; 0x13
    2102:	9c 8b       	std	Y+20, r25	; 0x14
	char buff[16]; /* String to hold the ascii result */
	dtostrf(data, 6, 1, buff); /* Use dtostrf C function to convert the data to its corresponding ASCII value, 10 for float decimal */
    2104:	89 89       	ldd	r24, Y+17	; 0x11
    2106:	9a 89       	ldd	r25, Y+18	; 0x12
    2108:	ab 89       	ldd	r26, Y+19	; 0x13
    210a:	bc 89       	ldd	r27, Y+20	; 0x14
    210c:	bc 01       	movw	r22, r24
    210e:	cd 01       	movw	r24, r26
    2110:	46 e0       	ldi	r20, 0x06	; 6
    2112:	50 e0       	ldi	r21, 0x00	; 0
    2114:	21 e0       	ldi	r18, 0x01	; 1
    2116:	30 e0       	ldi	r19, 0x00	; 0
    2118:	fe 01       	movw	r30, r28
    211a:	31 96       	adiw	r30, 0x01	; 1
    211c:	8f 01       	movw	r16, r30
    211e:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <dtostrf>
	LCD_displayString(buff); /* Display the string */
    2122:	ce 01       	movw	r24, r28
    2124:	01 96       	adiw	r24, 0x01	; 1
    2126:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <LCD_displayString>
}
    212a:	64 96       	adiw	r28, 0x14	; 20
    212c:	0f b6       	in	r0, 0x3f	; 63
    212e:	f8 94       	cli
    2130:	de bf       	out	0x3e, r29	; 62
    2132:	0f be       	out	0x3f, r0	; 63
    2134:	cd bf       	out	0x3d, r28	; 61
    2136:	cf 91       	pop	r28
    2138:	df 91       	pop	r29
    213a:	1f 91       	pop	r17
    213c:	0f 91       	pop	r16
    213e:	08 95       	ret

00002140 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    2140:	df 93       	push	r29
    2142:	cf 93       	push	r28
    2144:	cd b7       	in	r28, 0x3d	; 61
    2146:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	0e 94 ed 0b 	call	0x17da	; 0x17da <LCD_sendCommand>
}
    214e:	cf 91       	pop	r28
    2150:	df 91       	pop	r29
    2152:	08 95       	ret

00002154 <KEYPAD_getPressedKey>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

uint8 KEYPAD_getPressedKey(void)
{
    2154:	df 93       	push	r29
    2156:	cf 93       	push	r28
    2158:	cd b7       	in	r28, 0x3d	; 61
    215a:	de b7       	in	r29, 0x3e	; 62
    215c:	60 97       	sbiw	r28, 0x10	; 16
    215e:	0f b6       	in	r0, 0x3f	; 63
    2160:	f8 94       	cli
    2162:	de bf       	out	0x3e, r29	; 62
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	cd bf       	out	0x3d, r28	; 61
	uint8 col,row;
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID, PIN_INPUT);
    2168:	82 e0       	ldi	r24, 0x02	; 2
    216a:	60 e0       	ldi	r22, 0x00	; 0
    216c:	40 e0       	ldi	r20, 0x00	; 0
    216e:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+1, PIN_INPUT);
    2172:	82 e0       	ldi	r24, 0x02	; 2
    2174:	61 e0       	ldi	r22, 0x01	; 1
    2176:	40 e0       	ldi	r20, 0x00	; 0
    2178:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+2, PIN_INPUT);
    217c:	82 e0       	ldi	r24, 0x02	; 2
    217e:	62 e0       	ldi	r22, 0x02	; 2
    2180:	40 e0       	ldi	r20, 0x00	; 0
    2182:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+3, PIN_INPUT);
    2186:	82 e0       	ldi	r24, 0x02	; 2
    2188:	63 e0       	ldi	r22, 0x03	; 3
    218a:	40 e0       	ldi	r20, 0x00	; 0
    218c:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>

	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID, PIN_INPUT);
    2190:	82 e0       	ldi	r24, 0x02	; 2
    2192:	64 e0       	ldi	r22, 0x04	; 4
    2194:	40 e0       	ldi	r20, 0x00	; 0
    2196:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+1, PIN_INPUT);
    219a:	82 e0       	ldi	r24, 0x02	; 2
    219c:	65 e0       	ldi	r22, 0x05	; 5
    219e:	40 e0       	ldi	r20, 0x00	; 0
    21a0:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+2, PIN_INPUT);
    21a4:	82 e0       	ldi	r24, 0x02	; 2
    21a6:	66 e0       	ldi	r22, 0x06	; 6
    21a8:	40 e0       	ldi	r20, 0x00	; 0
    21aa:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
#if(KEYPAD_NUM_COLS == 4)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
    21ae:	82 e0       	ldi	r24, 0x02	; 2
    21b0:	67 e0       	ldi	r22, 0x07	; 7
    21b2:	40 e0       	ldi	r20, 0x00	; 0
    21b4:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
    21b8:	1f 86       	std	Y+15, r1	; 0x0f
    21ba:	ab c0       	rjmp	.+342    	; 0x2312 <KEYPAD_getPressedKey+0x1be>
		{
			/*
			 * Each time setup the direction for all keypad port as input pins,
			 * except this row will be output pin
			 */
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);
    21bc:	82 e0       	ldi	r24, 0x02	; 2
    21be:	6f 85       	ldd	r22, Y+15	; 0x0f
    21c0:	41 e0       	ldi	r20, 0x01	; 1
    21c2:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);
    21c6:	82 e0       	ldi	r24, 0x02	; 2
    21c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    21ca:	40 e0       	ldi	r20, 0x00	; 0
    21cc:	0e 94 fe 08 	call	0x11fc	; 0x11fc <GPIO_writePin>

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
    21d0:	18 8a       	std	Y+16, r1	; 0x10
    21d2:	22 c0       	rjmp	.+68     	; 0x2218 <KEYPAD_getPressedKey+0xc4>
			{
				/* Check if the switch is pressed in this column */
				if(GPIO_readPin(KEYPAD_COL_PORT_ID,KEYPAD_FIRST_COL_PIN_ID+col) == KEYPAD_BUTTON_PRESSED)
    21d4:	88 89       	ldd	r24, Y+16	; 0x10
    21d6:	98 2f       	mov	r25, r24
    21d8:	9c 5f       	subi	r25, 0xFC	; 252
    21da:	82 e0       	ldi	r24, 0x02	; 2
    21dc:	69 2f       	mov	r22, r25
    21de:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <GPIO_readPin>
    21e2:	88 23       	and	r24, r24
    21e4:	b1 f4       	brne	.+44     	; 0x2212 <KEYPAD_getPressedKey+0xbe>
						#endif
					#elif (KEYPAD_NUM_COLS == 4)
						#ifdef STANDARD_KEYPAD
							return ((row*KEYPAD_NUM_COLS)+col+1);
						#else
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
    21e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    21e8:	88 2f       	mov	r24, r24
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	88 0f       	add	r24, r24
    21ee:	99 1f       	adc	r25, r25
    21f0:	88 0f       	add	r24, r24
    21f2:	99 1f       	adc	r25, r25
    21f4:	98 2f       	mov	r25, r24
    21f6:	88 89       	ldd	r24, Y+16	; 0x10
    21f8:	89 0f       	add	r24, r25
    21fa:	8f 5f       	subi	r24, 0xFF	; 255
    21fc:	0e 94 8e 11 	call	0x231c	; 0x231c <KEYPAD_4x4_adjustKeyNumber>
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
			_delay_ms(5); /* Add small delay to fix CPU load issue in proteus */
		}
	}
}
    2200:	60 96       	adiw	r28, 0x10	; 16
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	f8 94       	cli
    2206:	de bf       	out	0x3e, r29	; 62
    2208:	0f be       	out	0x3f, r0	; 63
    220a:	cd bf       	out	0x3d, r28	; 61
    220c:	cf 91       	pop	r28
    220e:	df 91       	pop	r29
    2210:	08 95       	ret
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
    2212:	88 89       	ldd	r24, Y+16	; 0x10
    2214:	8f 5f       	subi	r24, 0xFF	; 255
    2216:	88 8b       	std	Y+16, r24	; 0x10
    2218:	88 89       	ldd	r24, Y+16	; 0x10
    221a:	84 30       	cpi	r24, 0x04	; 4
    221c:	d8 f2       	brcs	.-74     	; 0x21d4 <KEYPAD_getPressedKey+0x80>
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
						#endif
					#endif
				}
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
    221e:	82 e0       	ldi	r24, 0x02	; 2
    2220:	6f 85       	ldd	r22, Y+15	; 0x0f
    2222:	40 e0       	ldi	r20, 0x00	; 0
    2224:	0e 94 13 08 	call	0x1026	; 0x1026 <GPIO_setupPinDirection>
    2228:	80 e0       	ldi	r24, 0x00	; 0
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	a0 ea       	ldi	r26, 0xA0	; 160
    222e:	b0 e4       	ldi	r27, 0x40	; 64
    2230:	8b 87       	std	Y+11, r24	; 0x0b
    2232:	9c 87       	std	Y+12, r25	; 0x0c
    2234:	ad 87       	std	Y+13, r26	; 0x0d
    2236:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2238:	6b 85       	ldd	r22, Y+11	; 0x0b
    223a:	7c 85       	ldd	r23, Y+12	; 0x0c
    223c:	8d 85       	ldd	r24, Y+13	; 0x0d
    223e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2240:	20 e0       	ldi	r18, 0x00	; 0
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	4a ef       	ldi	r20, 0xFA	; 250
    2246:	54 e4       	ldi	r21, 0x44	; 68
    2248:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    224c:	dc 01       	movw	r26, r24
    224e:	cb 01       	movw	r24, r22
    2250:	8f 83       	std	Y+7, r24	; 0x07
    2252:	98 87       	std	Y+8, r25	; 0x08
    2254:	a9 87       	std	Y+9, r26	; 0x09
    2256:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2258:	6f 81       	ldd	r22, Y+7	; 0x07
    225a:	78 85       	ldd	r23, Y+8	; 0x08
    225c:	89 85       	ldd	r24, Y+9	; 0x09
    225e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2260:	20 e0       	ldi	r18, 0x00	; 0
    2262:	30 e0       	ldi	r19, 0x00	; 0
    2264:	40 e8       	ldi	r20, 0x80	; 128
    2266:	5f e3       	ldi	r21, 0x3F	; 63
    2268:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    226c:	88 23       	and	r24, r24
    226e:	2c f4       	brge	.+10     	; 0x227a <KEYPAD_getPressedKey+0x126>
		__ticks = 1;
    2270:	81 e0       	ldi	r24, 0x01	; 1
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	9e 83       	std	Y+6, r25	; 0x06
    2276:	8d 83       	std	Y+5, r24	; 0x05
    2278:	3f c0       	rjmp	.+126    	; 0x22f8 <KEYPAD_getPressedKey+0x1a4>
	else if (__tmp > 65535)
    227a:	6f 81       	ldd	r22, Y+7	; 0x07
    227c:	78 85       	ldd	r23, Y+8	; 0x08
    227e:	89 85       	ldd	r24, Y+9	; 0x09
    2280:	9a 85       	ldd	r25, Y+10	; 0x0a
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	3f ef       	ldi	r19, 0xFF	; 255
    2286:	4f e7       	ldi	r20, 0x7F	; 127
    2288:	57 e4       	ldi	r21, 0x47	; 71
    228a:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    228e:	18 16       	cp	r1, r24
    2290:	4c f5       	brge	.+82     	; 0x22e4 <KEYPAD_getPressedKey+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2292:	6b 85       	ldd	r22, Y+11	; 0x0b
    2294:	7c 85       	ldd	r23, Y+12	; 0x0c
    2296:	8d 85       	ldd	r24, Y+13	; 0x0d
    2298:	9e 85       	ldd	r25, Y+14	; 0x0e
    229a:	20 e0       	ldi	r18, 0x00	; 0
    229c:	30 e0       	ldi	r19, 0x00	; 0
    229e:	40 e2       	ldi	r20, 0x20	; 32
    22a0:	51 e4       	ldi	r21, 0x41	; 65
    22a2:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    22a6:	dc 01       	movw	r26, r24
    22a8:	cb 01       	movw	r24, r22
    22aa:	bc 01       	movw	r22, r24
    22ac:	cd 01       	movw	r24, r26
    22ae:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    22b2:	dc 01       	movw	r26, r24
    22b4:	cb 01       	movw	r24, r22
    22b6:	9e 83       	std	Y+6, r25	; 0x06
    22b8:	8d 83       	std	Y+5, r24	; 0x05
    22ba:	0f c0       	rjmp	.+30     	; 0x22da <KEYPAD_getPressedKey+0x186>
    22bc:	88 ec       	ldi	r24, 0xC8	; 200
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	9c 83       	std	Y+4, r25	; 0x04
    22c2:	8b 83       	std	Y+3, r24	; 0x03
    22c4:	8b 81       	ldd	r24, Y+3	; 0x03
    22c6:	9c 81       	ldd	r25, Y+4	; 0x04
    22c8:	01 97       	sbiw	r24, 0x01	; 1
    22ca:	f1 f7       	brne	.-4      	; 0x22c8 <KEYPAD_getPressedKey+0x174>
    22cc:	9c 83       	std	Y+4, r25	; 0x04
    22ce:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22d0:	8d 81       	ldd	r24, Y+5	; 0x05
    22d2:	9e 81       	ldd	r25, Y+6	; 0x06
    22d4:	01 97       	sbiw	r24, 0x01	; 1
    22d6:	9e 83       	std	Y+6, r25	; 0x06
    22d8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22da:	8d 81       	ldd	r24, Y+5	; 0x05
    22dc:	9e 81       	ldd	r25, Y+6	; 0x06
    22de:	00 97       	sbiw	r24, 0x00	; 0
    22e0:	69 f7       	brne	.-38     	; 0x22bc <KEYPAD_getPressedKey+0x168>
    22e2:	14 c0       	rjmp	.+40     	; 0x230c <KEYPAD_getPressedKey+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    22e4:	6f 81       	ldd	r22, Y+7	; 0x07
    22e6:	78 85       	ldd	r23, Y+8	; 0x08
    22e8:	89 85       	ldd	r24, Y+9	; 0x09
    22ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    22ec:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    22f0:	dc 01       	movw	r26, r24
    22f2:	cb 01       	movw	r24, r22
    22f4:	9e 83       	std	Y+6, r25	; 0x06
    22f6:	8d 83       	std	Y+5, r24	; 0x05
    22f8:	8d 81       	ldd	r24, Y+5	; 0x05
    22fa:	9e 81       	ldd	r25, Y+6	; 0x06
    22fc:	9a 83       	std	Y+2, r25	; 0x02
    22fe:	89 83       	std	Y+1, r24	; 0x01
    2300:	89 81       	ldd	r24, Y+1	; 0x01
    2302:	9a 81       	ldd	r25, Y+2	; 0x02
    2304:	01 97       	sbiw	r24, 0x01	; 1
    2306:	f1 f7       	brne	.-4      	; 0x2304 <KEYPAD_getPressedKey+0x1b0>
    2308:	9a 83       	std	Y+2, r25	; 0x02
    230a:	89 83       	std	Y+1, r24	; 0x01
#if(KEYPAD_NUM_COLS == 4)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
    230c:	8f 85       	ldd	r24, Y+15	; 0x0f
    230e:	8f 5f       	subi	r24, 0xFF	; 255
    2310:	8f 87       	std	Y+15, r24	; 0x0f
    2312:	8f 85       	ldd	r24, Y+15	; 0x0f
    2314:	84 30       	cpi	r24, 0x04	; 4
    2316:	08 f4       	brcc	.+2      	; 0x231a <KEYPAD_getPressedKey+0x1c6>
    2318:	51 cf       	rjmp	.-350    	; 0x21bc <KEYPAD_getPressedKey+0x68>
    231a:	4e cf       	rjmp	.-356    	; 0x21b8 <KEYPAD_getPressedKey+0x64>

0000231c <KEYPAD_4x4_adjustKeyNumber>:
/*
 * Description :
 * Update the keypad pressed button value with the correct one in keypad 4x4 shape
 */
static uint8 KEYPAD_4x4_adjustKeyNumber(uint8 button_number)
{
    231c:	df 93       	push	r29
    231e:	cf 93       	push	r28
    2320:	00 d0       	rcall	.+0      	; 0x2322 <KEYPAD_4x4_adjustKeyNumber+0x6>
    2322:	00 d0       	rcall	.+0      	; 0x2324 <KEYPAD_4x4_adjustKeyNumber+0x8>
    2324:	cd b7       	in	r28, 0x3d	; 61
    2326:	de b7       	in	r29, 0x3e	; 62
    2328:	8a 83       	std	Y+2, r24	; 0x02
	uint8 keypad_button = 0;
    232a:	19 82       	std	Y+1, r1	; 0x01
	switch(button_number)
    232c:	8a 81       	ldd	r24, Y+2	; 0x02
    232e:	28 2f       	mov	r18, r24
    2330:	30 e0       	ldi	r19, 0x00	; 0
    2332:	3c 83       	std	Y+4, r19	; 0x04
    2334:	2b 83       	std	Y+3, r18	; 0x03
    2336:	8b 81       	ldd	r24, Y+3	; 0x03
    2338:	9c 81       	ldd	r25, Y+4	; 0x04
    233a:	88 30       	cpi	r24, 0x08	; 8
    233c:	91 05       	cpc	r25, r1
    233e:	09 f4       	brne	.+2      	; 0x2342 <KEYPAD_4x4_adjustKeyNumber+0x26>
    2340:	70 c0       	rjmp	.+224    	; 0x2422 <KEYPAD_4x4_adjustKeyNumber+0x106>
    2342:	2b 81       	ldd	r18, Y+3	; 0x03
    2344:	3c 81       	ldd	r19, Y+4	; 0x04
    2346:	29 30       	cpi	r18, 0x09	; 9
    2348:	31 05       	cpc	r19, r1
    234a:	5c f5       	brge	.+86     	; 0x23a2 <KEYPAD_4x4_adjustKeyNumber+0x86>
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	9c 81       	ldd	r25, Y+4	; 0x04
    2350:	84 30       	cpi	r24, 0x04	; 4
    2352:	91 05       	cpc	r25, r1
    2354:	09 f4       	brne	.+2      	; 0x2358 <KEYPAD_4x4_adjustKeyNumber+0x3c>
    2356:	59 c0       	rjmp	.+178    	; 0x240a <KEYPAD_4x4_adjustKeyNumber+0xee>
    2358:	2b 81       	ldd	r18, Y+3	; 0x03
    235a:	3c 81       	ldd	r19, Y+4	; 0x04
    235c:	25 30       	cpi	r18, 0x05	; 5
    235e:	31 05       	cpc	r19, r1
    2360:	9c f4       	brge	.+38     	; 0x2388 <KEYPAD_4x4_adjustKeyNumber+0x6c>
    2362:	8b 81       	ldd	r24, Y+3	; 0x03
    2364:	9c 81       	ldd	r25, Y+4	; 0x04
    2366:	82 30       	cpi	r24, 0x02	; 2
    2368:	91 05       	cpc	r25, r1
    236a:	09 f4       	brne	.+2      	; 0x236e <KEYPAD_4x4_adjustKeyNumber+0x52>
    236c:	48 c0       	rjmp	.+144    	; 0x23fe <KEYPAD_4x4_adjustKeyNumber+0xe2>
    236e:	2b 81       	ldd	r18, Y+3	; 0x03
    2370:	3c 81       	ldd	r19, Y+4	; 0x04
    2372:	23 30       	cpi	r18, 0x03	; 3
    2374:	31 05       	cpc	r19, r1
    2376:	0c f0       	brlt	.+2      	; 0x237a <KEYPAD_4x4_adjustKeyNumber+0x5e>
    2378:	45 c0       	rjmp	.+138    	; 0x2404 <KEYPAD_4x4_adjustKeyNumber+0xe8>
    237a:	8b 81       	ldd	r24, Y+3	; 0x03
    237c:	9c 81       	ldd	r25, Y+4	; 0x04
    237e:	81 30       	cpi	r24, 0x01	; 1
    2380:	91 05       	cpc	r25, r1
    2382:	09 f4       	brne	.+2      	; 0x2386 <KEYPAD_4x4_adjustKeyNumber+0x6a>
    2384:	39 c0       	rjmp	.+114    	; 0x23f8 <KEYPAD_4x4_adjustKeyNumber+0xdc>
    2386:	67 c0       	rjmp	.+206    	; 0x2456 <KEYPAD_4x4_adjustKeyNumber+0x13a>
    2388:	2b 81       	ldd	r18, Y+3	; 0x03
    238a:	3c 81       	ldd	r19, Y+4	; 0x04
    238c:	26 30       	cpi	r18, 0x06	; 6
    238e:	31 05       	cpc	r19, r1
    2390:	09 f4       	brne	.+2      	; 0x2394 <KEYPAD_4x4_adjustKeyNumber+0x78>
    2392:	41 c0       	rjmp	.+130    	; 0x2416 <KEYPAD_4x4_adjustKeyNumber+0xfa>
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	87 30       	cpi	r24, 0x07	; 7
    239a:	91 05       	cpc	r25, r1
    239c:	0c f0       	brlt	.+2      	; 0x23a0 <KEYPAD_4x4_adjustKeyNumber+0x84>
    239e:	3e c0       	rjmp	.+124    	; 0x241c <KEYPAD_4x4_adjustKeyNumber+0x100>
    23a0:	37 c0       	rjmp	.+110    	; 0x2410 <KEYPAD_4x4_adjustKeyNumber+0xf4>
    23a2:	2b 81       	ldd	r18, Y+3	; 0x03
    23a4:	3c 81       	ldd	r19, Y+4	; 0x04
    23a6:	2c 30       	cpi	r18, 0x0C	; 12
    23a8:	31 05       	cpc	r19, r1
    23aa:	09 f4       	brne	.+2      	; 0x23ae <KEYPAD_4x4_adjustKeyNumber+0x92>
    23ac:	46 c0       	rjmp	.+140    	; 0x243a <KEYPAD_4x4_adjustKeyNumber+0x11e>
    23ae:	8b 81       	ldd	r24, Y+3	; 0x03
    23b0:	9c 81       	ldd	r25, Y+4	; 0x04
    23b2:	8d 30       	cpi	r24, 0x0D	; 13
    23b4:	91 05       	cpc	r25, r1
    23b6:	5c f4       	brge	.+22     	; 0x23ce <KEYPAD_4x4_adjustKeyNumber+0xb2>
    23b8:	2b 81       	ldd	r18, Y+3	; 0x03
    23ba:	3c 81       	ldd	r19, Y+4	; 0x04
    23bc:	2a 30       	cpi	r18, 0x0A	; 10
    23be:	31 05       	cpc	r19, r1
    23c0:	b1 f1       	breq	.+108    	; 0x242e <KEYPAD_4x4_adjustKeyNumber+0x112>
    23c2:	8b 81       	ldd	r24, Y+3	; 0x03
    23c4:	9c 81       	ldd	r25, Y+4	; 0x04
    23c6:	8b 30       	cpi	r24, 0x0B	; 11
    23c8:	91 05       	cpc	r25, r1
    23ca:	a4 f5       	brge	.+104    	; 0x2434 <KEYPAD_4x4_adjustKeyNumber+0x118>
    23cc:	2d c0       	rjmp	.+90     	; 0x2428 <KEYPAD_4x4_adjustKeyNumber+0x10c>
    23ce:	2b 81       	ldd	r18, Y+3	; 0x03
    23d0:	3c 81       	ldd	r19, Y+4	; 0x04
    23d2:	2e 30       	cpi	r18, 0x0E	; 14
    23d4:	31 05       	cpc	r19, r1
    23d6:	b9 f1       	breq	.+110    	; 0x2446 <KEYPAD_4x4_adjustKeyNumber+0x12a>
    23d8:	8b 81       	ldd	r24, Y+3	; 0x03
    23da:	9c 81       	ldd	r25, Y+4	; 0x04
    23dc:	8e 30       	cpi	r24, 0x0E	; 14
    23de:	91 05       	cpc	r25, r1
    23e0:	7c f1       	brlt	.+94     	; 0x2440 <KEYPAD_4x4_adjustKeyNumber+0x124>
    23e2:	2b 81       	ldd	r18, Y+3	; 0x03
    23e4:	3c 81       	ldd	r19, Y+4	; 0x04
    23e6:	2f 30       	cpi	r18, 0x0F	; 15
    23e8:	31 05       	cpc	r19, r1
    23ea:	79 f1       	breq	.+94     	; 0x244a <KEYPAD_4x4_adjustKeyNumber+0x12e>
    23ec:	8b 81       	ldd	r24, Y+3	; 0x03
    23ee:	9c 81       	ldd	r25, Y+4	; 0x04
    23f0:	80 31       	cpi	r24, 0x10	; 16
    23f2:	91 05       	cpc	r25, r1
    23f4:	69 f1       	breq	.+90     	; 0x2450 <KEYPAD_4x4_adjustKeyNumber+0x134>
    23f6:	2f c0       	rjmp	.+94     	; 0x2456 <KEYPAD_4x4_adjustKeyNumber+0x13a>
	{
		case 1: keypad_button = 7;
    23f8:	87 e0       	ldi	r24, 0x07	; 7
    23fa:	89 83       	std	Y+1, r24	; 0x01
    23fc:	2e c0       	rjmp	.+92     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 2: keypad_button = 8;
    23fe:	88 e0       	ldi	r24, 0x08	; 8
    2400:	89 83       	std	Y+1, r24	; 0x01
    2402:	2b c0       	rjmp	.+86     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 3: keypad_button = 9;
    2404:	89 e0       	ldi	r24, 0x09	; 9
    2406:	89 83       	std	Y+1, r24	; 0x01
    2408:	28 c0       	rjmp	.+80     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 4: keypad_button = '%'; // ASCII Code of %
    240a:	85 e2       	ldi	r24, 0x25	; 37
    240c:	89 83       	std	Y+1, r24	; 0x01
    240e:	25 c0       	rjmp	.+74     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 5: keypad_button = 4;
    2410:	84 e0       	ldi	r24, 0x04	; 4
    2412:	89 83       	std	Y+1, r24	; 0x01
    2414:	22 c0       	rjmp	.+68     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 6: keypad_button = 5;
    2416:	85 e0       	ldi	r24, 0x05	; 5
    2418:	89 83       	std	Y+1, r24	; 0x01
    241a:	1f c0       	rjmp	.+62     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 7: keypad_button = 6;
    241c:	86 e0       	ldi	r24, 0x06	; 6
    241e:	89 83       	std	Y+1, r24	; 0x01
    2420:	1c c0       	rjmp	.+56     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 8: keypad_button = '*'; /* ASCII Code of '*' */
    2422:	8a e2       	ldi	r24, 0x2A	; 42
    2424:	89 83       	std	Y+1, r24	; 0x01
    2426:	19 c0       	rjmp	.+50     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 9: keypad_button = 1;
    2428:	81 e0       	ldi	r24, 0x01	; 1
    242a:	89 83       	std	Y+1, r24	; 0x01
    242c:	16 c0       	rjmp	.+44     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 10: keypad_button = 2;
    242e:	82 e0       	ldi	r24, 0x02	; 2
    2430:	89 83       	std	Y+1, r24	; 0x01
    2432:	13 c0       	rjmp	.+38     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 11: keypad_button = 3;
    2434:	83 e0       	ldi	r24, 0x03	; 3
    2436:	89 83       	std	Y+1, r24	; 0x01
    2438:	10 c0       	rjmp	.+32     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 12: keypad_button = '-'; /* ASCII Code of '-' */
    243a:	8d e2       	ldi	r24, 0x2D	; 45
    243c:	89 83       	std	Y+1, r24	; 0x01
    243e:	0d c0       	rjmp	.+26     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 13: keypad_button = 13;  /* ASCII of Enter */
    2440:	8d e0       	ldi	r24, 0x0D	; 13
    2442:	89 83       	std	Y+1, r24	; 0x01
    2444:	0a c0       	rjmp	.+20     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 14: keypad_button = 0;
    2446:	19 82       	std	Y+1, r1	; 0x01
    2448:	08 c0       	rjmp	.+16     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 15: keypad_button = '='; /* ASCII Code of '=' */
    244a:	8d e3       	ldi	r24, 0x3D	; 61
    244c:	89 83       	std	Y+1, r24	; 0x01
    244e:	05 c0       	rjmp	.+10     	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 16: keypad_button = '+'; /* ASCII Code of '+' */
    2450:	8b e2       	ldi	r24, 0x2B	; 43
    2452:	89 83       	std	Y+1, r24	; 0x01
    2454:	02 c0       	rjmp	.+4      	; 0x245a <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		default: keypad_button = button_number;
    2456:	8a 81       	ldd	r24, Y+2	; 0x02
    2458:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	return keypad_button;
    245a:	89 81       	ldd	r24, Y+1	; 0x01
}
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	cf 91       	pop	r28
    2466:	df 91       	pop	r29
    2468:	08 95       	ret

0000246a <main>:
/*******************************************************************************
 *                                MAIN                                         *
 *******************************************************************************/
volatile uint8 timer1_Ticks = 0;
volatile uint8 trial_flag = 3;
int main(void) {
    246a:	0f 93       	push	r16
    246c:	1f 93       	push	r17
    246e:	df 93       	push	r29
    2470:	cf 93       	push	r28
    2472:	cd b7       	in	r28, 0x3d	; 61
    2474:	de b7       	in	r29, 0x3e	; 62
    2476:	cf 55       	subi	r28, 0x5F	; 95
    2478:	d0 40       	sbci	r29, 0x00	; 0
    247a:	0f b6       	in	r0, 0x3f	; 63
    247c:	f8 94       	cli
    247e:	de bf       	out	0x3e, r29	; 62
    2480:	0f be       	out	0x3f, r0	; 63
    2482:	cd bf       	out	0x3d, r28	; 61
	SREG_REG.bits.I_BIT = 1;/*Enable I-bit by bit register field*/
    2484:	ef e5       	ldi	r30, 0x5F	; 95
    2486:	f0 e0       	ldi	r31, 0x00	; 0
    2488:	80 81       	ld	r24, Z
    248a:	80 68       	ori	r24, 0x80	; 128
    248c:	80 83       	st	Z, r24
	 * 8-bit data
	 * parity check is disabled
	 * stop bit is one bit
	 * baud rate is 9600
	 */
	UART_ConfigType UART_config = { EIGHT_bit, Disabled, ONE_bit, BR3 };
    248e:	ce 01       	movw	r24, r28
    2490:	8e 5a       	subi	r24, 0xAE	; 174
    2492:	9f 4f       	sbci	r25, 0xFF	; 255
    2494:	6d 96       	adiw	r28, 0x1d	; 29
    2496:	9f af       	std	Y+63, r25	; 0x3f
    2498:	8e af       	std	Y+62, r24	; 0x3e
    249a:	6d 97       	sbiw	r28, 0x1d	; 29
    249c:	2b e1       	ldi	r18, 0x1B	; 27
    249e:	31 e0       	ldi	r19, 0x01	; 1
    24a0:	6f 96       	adiw	r28, 0x1f	; 31
    24a2:	3f af       	std	Y+63, r19	; 0x3f
    24a4:	2e af       	std	Y+62, r18	; 0x3e
    24a6:	6f 97       	sbiw	r28, 0x1f	; 31
    24a8:	37 e0       	ldi	r19, 0x07	; 7
    24aa:	a0 96       	adiw	r28, 0x20	; 32
    24ac:	3f af       	std	Y+63, r19	; 0x3f
    24ae:	a0 97       	sbiw	r28, 0x20	; 32
    24b0:	6f 96       	adiw	r28, 0x1f	; 31
    24b2:	ee ad       	ldd	r30, Y+62	; 0x3e
    24b4:	ff ad       	ldd	r31, Y+63	; 0x3f
    24b6:	6f 97       	sbiw	r28, 0x1f	; 31
    24b8:	00 80       	ld	r0, Z
    24ba:	6f 96       	adiw	r28, 0x1f	; 31
    24bc:	2e ad       	ldd	r18, Y+62	; 0x3e
    24be:	3f ad       	ldd	r19, Y+63	; 0x3f
    24c0:	6f 97       	sbiw	r28, 0x1f	; 31
    24c2:	2f 5f       	subi	r18, 0xFF	; 255
    24c4:	3f 4f       	sbci	r19, 0xFF	; 255
    24c6:	6f 96       	adiw	r28, 0x1f	; 31
    24c8:	3f af       	std	Y+63, r19	; 0x3f
    24ca:	2e af       	std	Y+62, r18	; 0x3e
    24cc:	6f 97       	sbiw	r28, 0x1f	; 31
    24ce:	6d 96       	adiw	r28, 0x1d	; 29
    24d0:	ee ad       	ldd	r30, Y+62	; 0x3e
    24d2:	ff ad       	ldd	r31, Y+63	; 0x3f
    24d4:	6d 97       	sbiw	r28, 0x1d	; 29
    24d6:	00 82       	st	Z, r0
    24d8:	6d 96       	adiw	r28, 0x1d	; 29
    24da:	2e ad       	ldd	r18, Y+62	; 0x3e
    24dc:	3f ad       	ldd	r19, Y+63	; 0x3f
    24de:	6d 97       	sbiw	r28, 0x1d	; 29
    24e0:	2f 5f       	subi	r18, 0xFF	; 255
    24e2:	3f 4f       	sbci	r19, 0xFF	; 255
    24e4:	6d 96       	adiw	r28, 0x1d	; 29
    24e6:	3f af       	std	Y+63, r19	; 0x3f
    24e8:	2e af       	std	Y+62, r18	; 0x3e
    24ea:	6d 97       	sbiw	r28, 0x1d	; 29
    24ec:	a0 96       	adiw	r28, 0x20	; 32
    24ee:	3f ad       	ldd	r19, Y+63	; 0x3f
    24f0:	a0 97       	sbiw	r28, 0x20	; 32
    24f2:	31 50       	subi	r19, 0x01	; 1
    24f4:	a0 96       	adiw	r28, 0x20	; 32
    24f6:	3f af       	std	Y+63, r19	; 0x3f
    24f8:	a0 97       	sbiw	r28, 0x20	; 32
    24fa:	a0 96       	adiw	r28, 0x20	; 32
    24fc:	8f ad       	ldd	r24, Y+63	; 0x3f
    24fe:	a0 97       	sbiw	r28, 0x20	; 32
    2500:	88 23       	and	r24, r24
    2502:	b1 f6       	brne	.-84     	; 0x24b0 <main+0x46>
	UART_init(&UART_config);
    2504:	ce 01       	movw	r24, r28
    2506:	8e 5a       	subi	r24, 0xAE	; 174
    2508:	9f 4f       	sbci	r25, 0xFF	; 255
    250a:	0e 94 20 06 	call	0xc40	; 0xc40 <UART_init>
	LCD_init();
    250e:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <LCD_init>

	while (1) {
		/*Step 1 part 1: Take password and confirmed password from user*/
		EnterPassword(password1);
    2512:	ce 01       	movw	r24, r28
    2514:	88 5b       	subi	r24, 0xB8	; 184
    2516:	9f 4f       	sbci	r25, 0xFF	; 255
    2518:	0e 94 76 15 	call	0x2aec	; 0x2aec <EnterPassword>
    251c:	fe 01       	movw	r30, r28
    251e:	ed 5b       	subi	r30, 0xBD	; 189
    2520:	ff 4f       	sbci	r31, 0xFF	; 255
    2522:	80 e0       	ldi	r24, 0x00	; 0
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	a6 e9       	ldi	r26, 0x96	; 150
    2528:	b3 e4       	ldi	r27, 0x43	; 67
    252a:	80 83       	st	Z, r24
    252c:	91 83       	std	Z+1, r25	; 0x01
    252e:	a2 83       	std	Z+2, r26	; 0x02
    2530:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2532:	8e 01       	movw	r16, r28
    2534:	01 5c       	subi	r16, 0xC1	; 193
    2536:	1f 4f       	sbci	r17, 0xFF	; 255
    2538:	fe 01       	movw	r30, r28
    253a:	ed 5b       	subi	r30, 0xBD	; 189
    253c:	ff 4f       	sbci	r31, 0xFF	; 255
    253e:	60 81       	ld	r22, Z
    2540:	71 81       	ldd	r23, Z+1	; 0x01
    2542:	82 81       	ldd	r24, Z+2	; 0x02
    2544:	93 81       	ldd	r25, Z+3	; 0x03
    2546:	20 e0       	ldi	r18, 0x00	; 0
    2548:	30 e0       	ldi	r19, 0x00	; 0
    254a:	4a ef       	ldi	r20, 0xFA	; 250
    254c:	54 e4       	ldi	r21, 0x44	; 68
    254e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2552:	dc 01       	movw	r26, r24
    2554:	cb 01       	movw	r24, r22
    2556:	f8 01       	movw	r30, r16
    2558:	80 83       	st	Z, r24
    255a:	91 83       	std	Z+1, r25	; 0x01
    255c:	a2 83       	std	Z+2, r26	; 0x02
    255e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2560:	fe 01       	movw	r30, r28
    2562:	ff 96       	adiw	r30, 0x3f	; 63
    2564:	60 81       	ld	r22, Z
    2566:	71 81       	ldd	r23, Z+1	; 0x01
    2568:	82 81       	ldd	r24, Z+2	; 0x02
    256a:	93 81       	ldd	r25, Z+3	; 0x03
    256c:	20 e0       	ldi	r18, 0x00	; 0
    256e:	30 e0       	ldi	r19, 0x00	; 0
    2570:	40 e8       	ldi	r20, 0x80	; 128
    2572:	5f e3       	ldi	r21, 0x3F	; 63
    2574:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2578:	88 23       	and	r24, r24
    257a:	2c f4       	brge	.+10     	; 0x2586 <main+0x11c>
		__ticks = 1;
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	9e af       	std	Y+62, r25	; 0x3e
    2582:	8d af       	std	Y+61, r24	; 0x3d
    2584:	46 c0       	rjmp	.+140    	; 0x2612 <main+0x1a8>
	else if (__tmp > 65535)
    2586:	fe 01       	movw	r30, r28
    2588:	ff 96       	adiw	r30, 0x3f	; 63
    258a:	60 81       	ld	r22, Z
    258c:	71 81       	ldd	r23, Z+1	; 0x01
    258e:	82 81       	ldd	r24, Z+2	; 0x02
    2590:	93 81       	ldd	r25, Z+3	; 0x03
    2592:	20 e0       	ldi	r18, 0x00	; 0
    2594:	3f ef       	ldi	r19, 0xFF	; 255
    2596:	4f e7       	ldi	r20, 0x7F	; 127
    2598:	57 e4       	ldi	r21, 0x47	; 71
    259a:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    259e:	18 16       	cp	r1, r24
    25a0:	64 f5       	brge	.+88     	; 0x25fa <main+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25a2:	fe 01       	movw	r30, r28
    25a4:	ed 5b       	subi	r30, 0xBD	; 189
    25a6:	ff 4f       	sbci	r31, 0xFF	; 255
    25a8:	60 81       	ld	r22, Z
    25aa:	71 81       	ldd	r23, Z+1	; 0x01
    25ac:	82 81       	ldd	r24, Z+2	; 0x02
    25ae:	93 81       	ldd	r25, Z+3	; 0x03
    25b0:	20 e0       	ldi	r18, 0x00	; 0
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	40 e2       	ldi	r20, 0x20	; 32
    25b6:	51 e4       	ldi	r21, 0x41	; 65
    25b8:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    25bc:	dc 01       	movw	r26, r24
    25be:	cb 01       	movw	r24, r22
    25c0:	bc 01       	movw	r22, r24
    25c2:	cd 01       	movw	r24, r26
    25c4:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    25c8:	dc 01       	movw	r26, r24
    25ca:	cb 01       	movw	r24, r22
    25cc:	9e af       	std	Y+62, r25	; 0x3e
    25ce:	8d af       	std	Y+61, r24	; 0x3d
    25d0:	0f c0       	rjmp	.+30     	; 0x25f0 <main+0x186>
    25d2:	88 ec       	ldi	r24, 0xC8	; 200
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	9c af       	std	Y+60, r25	; 0x3c
    25d8:	8b af       	std	Y+59, r24	; 0x3b
    25da:	8b ad       	ldd	r24, Y+59	; 0x3b
    25dc:	9c ad       	ldd	r25, Y+60	; 0x3c
    25de:	01 97       	sbiw	r24, 0x01	; 1
    25e0:	f1 f7       	brne	.-4      	; 0x25de <main+0x174>
    25e2:	9c af       	std	Y+60, r25	; 0x3c
    25e4:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25e6:	8d ad       	ldd	r24, Y+61	; 0x3d
    25e8:	9e ad       	ldd	r25, Y+62	; 0x3e
    25ea:	01 97       	sbiw	r24, 0x01	; 1
    25ec:	9e af       	std	Y+62, r25	; 0x3e
    25ee:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25f0:	8d ad       	ldd	r24, Y+61	; 0x3d
    25f2:	9e ad       	ldd	r25, Y+62	; 0x3e
    25f4:	00 97       	sbiw	r24, 0x00	; 0
    25f6:	69 f7       	brne	.-38     	; 0x25d2 <main+0x168>
    25f8:	16 c0       	rjmp	.+44     	; 0x2626 <main+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25fa:	fe 01       	movw	r30, r28
    25fc:	ff 96       	adiw	r30, 0x3f	; 63
    25fe:	60 81       	ld	r22, Z
    2600:	71 81       	ldd	r23, Z+1	; 0x01
    2602:	82 81       	ldd	r24, Z+2	; 0x02
    2604:	93 81       	ldd	r25, Z+3	; 0x03
    2606:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    260a:	dc 01       	movw	r26, r24
    260c:	cb 01       	movw	r24, r22
    260e:	9e af       	std	Y+62, r25	; 0x3e
    2610:	8d af       	std	Y+61, r24	; 0x3d
    2612:	8d ad       	ldd	r24, Y+61	; 0x3d
    2614:	9e ad       	ldd	r25, Y+62	; 0x3e
    2616:	9a af       	std	Y+58, r25	; 0x3a
    2618:	89 af       	std	Y+57, r24	; 0x39
    261a:	89 ad       	ldd	r24, Y+57	; 0x39
    261c:	9a ad       	ldd	r25, Y+58	; 0x3a
    261e:	01 97       	sbiw	r24, 0x01	; 1
    2620:	f1 f7       	brne	.-4      	; 0x261e <main+0x1b4>
    2622:	9a af       	std	Y+58, r25	; 0x3a
    2624:	89 af       	std	Y+57, r24	; 0x39
		_delay_ms(MEDIUM_DELAY);
		ReEnterSamePassword(password2);
    2626:	ce 01       	movw	r24, r28
    2628:	83 5b       	subi	r24, 0xB3	; 179
    262a:	9f 4f       	sbci	r25, 0xFF	; 255
    262c:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <ReEnterSamePassword>
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	90 e0       	ldi	r25, 0x00	; 0
    2634:	a6 e9       	ldi	r26, 0x96	; 150
    2636:	b3 e4       	ldi	r27, 0x43	; 67
    2638:	8d ab       	std	Y+53, r24	; 0x35
    263a:	9e ab       	std	Y+54, r25	; 0x36
    263c:	af ab       	std	Y+55, r26	; 0x37
    263e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2640:	6d a9       	ldd	r22, Y+53	; 0x35
    2642:	7e a9       	ldd	r23, Y+54	; 0x36
    2644:	8f a9       	ldd	r24, Y+55	; 0x37
    2646:	98 ad       	ldd	r25, Y+56	; 0x38
    2648:	20 e0       	ldi	r18, 0x00	; 0
    264a:	30 e0       	ldi	r19, 0x00	; 0
    264c:	4a ef       	ldi	r20, 0xFA	; 250
    264e:	54 e4       	ldi	r21, 0x44	; 68
    2650:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2654:	dc 01       	movw	r26, r24
    2656:	cb 01       	movw	r24, r22
    2658:	89 ab       	std	Y+49, r24	; 0x31
    265a:	9a ab       	std	Y+50, r25	; 0x32
    265c:	ab ab       	std	Y+51, r26	; 0x33
    265e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2660:	69 a9       	ldd	r22, Y+49	; 0x31
    2662:	7a a9       	ldd	r23, Y+50	; 0x32
    2664:	8b a9       	ldd	r24, Y+51	; 0x33
    2666:	9c a9       	ldd	r25, Y+52	; 0x34
    2668:	20 e0       	ldi	r18, 0x00	; 0
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	40 e8       	ldi	r20, 0x80	; 128
    266e:	5f e3       	ldi	r21, 0x3F	; 63
    2670:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2674:	88 23       	and	r24, r24
    2676:	2c f4       	brge	.+10     	; 0x2682 <main+0x218>
		__ticks = 1;
    2678:	81 e0       	ldi	r24, 0x01	; 1
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	98 ab       	std	Y+48, r25	; 0x30
    267e:	8f a7       	std	Y+47, r24	; 0x2f
    2680:	3f c0       	rjmp	.+126    	; 0x2700 <main+0x296>
	else if (__tmp > 65535)
    2682:	69 a9       	ldd	r22, Y+49	; 0x31
    2684:	7a a9       	ldd	r23, Y+50	; 0x32
    2686:	8b a9       	ldd	r24, Y+51	; 0x33
    2688:	9c a9       	ldd	r25, Y+52	; 0x34
    268a:	20 e0       	ldi	r18, 0x00	; 0
    268c:	3f ef       	ldi	r19, 0xFF	; 255
    268e:	4f e7       	ldi	r20, 0x7F	; 127
    2690:	57 e4       	ldi	r21, 0x47	; 71
    2692:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    2696:	18 16       	cp	r1, r24
    2698:	4c f5       	brge	.+82     	; 0x26ec <main+0x282>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    269a:	6d a9       	ldd	r22, Y+53	; 0x35
    269c:	7e a9       	ldd	r23, Y+54	; 0x36
    269e:	8f a9       	ldd	r24, Y+55	; 0x37
    26a0:	98 ad       	ldd	r25, Y+56	; 0x38
    26a2:	20 e0       	ldi	r18, 0x00	; 0
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	40 e2       	ldi	r20, 0x20	; 32
    26a8:	51 e4       	ldi	r21, 0x41	; 65
    26aa:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    26ae:	dc 01       	movw	r26, r24
    26b0:	cb 01       	movw	r24, r22
    26b2:	bc 01       	movw	r22, r24
    26b4:	cd 01       	movw	r24, r26
    26b6:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    26ba:	dc 01       	movw	r26, r24
    26bc:	cb 01       	movw	r24, r22
    26be:	98 ab       	std	Y+48, r25	; 0x30
    26c0:	8f a7       	std	Y+47, r24	; 0x2f
    26c2:	0f c0       	rjmp	.+30     	; 0x26e2 <main+0x278>
    26c4:	88 ec       	ldi	r24, 0xC8	; 200
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	9e a7       	std	Y+46, r25	; 0x2e
    26ca:	8d a7       	std	Y+45, r24	; 0x2d
    26cc:	8d a5       	ldd	r24, Y+45	; 0x2d
    26ce:	9e a5       	ldd	r25, Y+46	; 0x2e
    26d0:	01 97       	sbiw	r24, 0x01	; 1
    26d2:	f1 f7       	brne	.-4      	; 0x26d0 <main+0x266>
    26d4:	9e a7       	std	Y+46, r25	; 0x2e
    26d6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26d8:	8f a5       	ldd	r24, Y+47	; 0x2f
    26da:	98 a9       	ldd	r25, Y+48	; 0x30
    26dc:	01 97       	sbiw	r24, 0x01	; 1
    26de:	98 ab       	std	Y+48, r25	; 0x30
    26e0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26e2:	8f a5       	ldd	r24, Y+47	; 0x2f
    26e4:	98 a9       	ldd	r25, Y+48	; 0x30
    26e6:	00 97       	sbiw	r24, 0x00	; 0
    26e8:	69 f7       	brne	.-38     	; 0x26c4 <main+0x25a>
    26ea:	14 c0       	rjmp	.+40     	; 0x2714 <main+0x2aa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    26ec:	69 a9       	ldd	r22, Y+49	; 0x31
    26ee:	7a a9       	ldd	r23, Y+50	; 0x32
    26f0:	8b a9       	ldd	r24, Y+51	; 0x33
    26f2:	9c a9       	ldd	r25, Y+52	; 0x34
    26f4:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    26f8:	dc 01       	movw	r26, r24
    26fa:	cb 01       	movw	r24, r22
    26fc:	98 ab       	std	Y+48, r25	; 0x30
    26fe:	8f a7       	std	Y+47, r24	; 0x2f
    2700:	8f a5       	ldd	r24, Y+47	; 0x2f
    2702:	98 a9       	ldd	r25, Y+48	; 0x30
    2704:	9c a7       	std	Y+44, r25	; 0x2c
    2706:	8b a7       	std	Y+43, r24	; 0x2b
    2708:	8b a5       	ldd	r24, Y+43	; 0x2b
    270a:	9c a5       	ldd	r25, Y+44	; 0x2c
    270c:	01 97       	sbiw	r24, 0x01	; 1
    270e:	f1 f7       	brne	.-4      	; 0x270c <main+0x2a2>
    2710:	9c a7       	std	Y+44, r25	; 0x2c
    2712:	8b a7       	std	Y+43, r24	; 0x2b
		_delay_ms(MEDIUM_DELAY);

		/*Step 1 part 2: Send password and confirmed password to M2 via UART*/
		SendTwoPasswords(password1, password2);
    2714:	ce 01       	movw	r24, r28
    2716:	88 5b       	subi	r24, 0xB8	; 184
    2718:	9f 4f       	sbci	r25, 0xFF	; 255
    271a:	9e 01       	movw	r18, r28
    271c:	23 5b       	subi	r18, 0xB3	; 179
    271e:	3f 4f       	sbci	r19, 0xFF	; 255
    2720:	b9 01       	movw	r22, r18
    2722:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <SendTwoPasswords>
    2726:	80 e0       	ldi	r24, 0x00	; 0
    2728:	90 e0       	ldi	r25, 0x00	; 0
    272a:	a6 e9       	ldi	r26, 0x96	; 150
    272c:	b3 e4       	ldi	r27, 0x43	; 67
    272e:	8f a3       	std	Y+39, r24	; 0x27
    2730:	98 a7       	std	Y+40, r25	; 0x28
    2732:	a9 a7       	std	Y+41, r26	; 0x29
    2734:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2736:	6f a1       	ldd	r22, Y+39	; 0x27
    2738:	78 a5       	ldd	r23, Y+40	; 0x28
    273a:	89 a5       	ldd	r24, Y+41	; 0x29
    273c:	9a a5       	ldd	r25, Y+42	; 0x2a
    273e:	20 e0       	ldi	r18, 0x00	; 0
    2740:	30 e0       	ldi	r19, 0x00	; 0
    2742:	4a ef       	ldi	r20, 0xFA	; 250
    2744:	54 e4       	ldi	r21, 0x44	; 68
    2746:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    274a:	dc 01       	movw	r26, r24
    274c:	cb 01       	movw	r24, r22
    274e:	8b a3       	std	Y+35, r24	; 0x23
    2750:	9c a3       	std	Y+36, r25	; 0x24
    2752:	ad a3       	std	Y+37, r26	; 0x25
    2754:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2756:	6b a1       	ldd	r22, Y+35	; 0x23
    2758:	7c a1       	ldd	r23, Y+36	; 0x24
    275a:	8d a1       	ldd	r24, Y+37	; 0x25
    275c:	9e a1       	ldd	r25, Y+38	; 0x26
    275e:	20 e0       	ldi	r18, 0x00	; 0
    2760:	30 e0       	ldi	r19, 0x00	; 0
    2762:	40 e8       	ldi	r20, 0x80	; 128
    2764:	5f e3       	ldi	r21, 0x3F	; 63
    2766:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    276a:	88 23       	and	r24, r24
    276c:	2c f4       	brge	.+10     	; 0x2778 <main+0x30e>
		__ticks = 1;
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	9a a3       	std	Y+34, r25	; 0x22
    2774:	89 a3       	std	Y+33, r24	; 0x21
    2776:	3f c0       	rjmp	.+126    	; 0x27f6 <main+0x38c>
	else if (__tmp > 65535)
    2778:	6b a1       	ldd	r22, Y+35	; 0x23
    277a:	7c a1       	ldd	r23, Y+36	; 0x24
    277c:	8d a1       	ldd	r24, Y+37	; 0x25
    277e:	9e a1       	ldd	r25, Y+38	; 0x26
    2780:	20 e0       	ldi	r18, 0x00	; 0
    2782:	3f ef       	ldi	r19, 0xFF	; 255
    2784:	4f e7       	ldi	r20, 0x7F	; 127
    2786:	57 e4       	ldi	r21, 0x47	; 71
    2788:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    278c:	18 16       	cp	r1, r24
    278e:	4c f5       	brge	.+82     	; 0x27e2 <main+0x378>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2790:	6f a1       	ldd	r22, Y+39	; 0x27
    2792:	78 a5       	ldd	r23, Y+40	; 0x28
    2794:	89 a5       	ldd	r24, Y+41	; 0x29
    2796:	9a a5       	ldd	r25, Y+42	; 0x2a
    2798:	20 e0       	ldi	r18, 0x00	; 0
    279a:	30 e0       	ldi	r19, 0x00	; 0
    279c:	40 e2       	ldi	r20, 0x20	; 32
    279e:	51 e4       	ldi	r21, 0x41	; 65
    27a0:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    27a4:	dc 01       	movw	r26, r24
    27a6:	cb 01       	movw	r24, r22
    27a8:	bc 01       	movw	r22, r24
    27aa:	cd 01       	movw	r24, r26
    27ac:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    27b0:	dc 01       	movw	r26, r24
    27b2:	cb 01       	movw	r24, r22
    27b4:	9a a3       	std	Y+34, r25	; 0x22
    27b6:	89 a3       	std	Y+33, r24	; 0x21
    27b8:	0f c0       	rjmp	.+30     	; 0x27d8 <main+0x36e>
    27ba:	88 ec       	ldi	r24, 0xC8	; 200
    27bc:	90 e0       	ldi	r25, 0x00	; 0
    27be:	98 a3       	std	Y+32, r25	; 0x20
    27c0:	8f 8f       	std	Y+31, r24	; 0x1f
    27c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27c4:	98 a1       	ldd	r25, Y+32	; 0x20
    27c6:	01 97       	sbiw	r24, 0x01	; 1
    27c8:	f1 f7       	brne	.-4      	; 0x27c6 <main+0x35c>
    27ca:	98 a3       	std	Y+32, r25	; 0x20
    27cc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27ce:	89 a1       	ldd	r24, Y+33	; 0x21
    27d0:	9a a1       	ldd	r25, Y+34	; 0x22
    27d2:	01 97       	sbiw	r24, 0x01	; 1
    27d4:	9a a3       	std	Y+34, r25	; 0x22
    27d6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27d8:	89 a1       	ldd	r24, Y+33	; 0x21
    27da:	9a a1       	ldd	r25, Y+34	; 0x22
    27dc:	00 97       	sbiw	r24, 0x00	; 0
    27de:	69 f7       	brne	.-38     	; 0x27ba <main+0x350>
    27e0:	14 c0       	rjmp	.+40     	; 0x280a <main+0x3a0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    27e2:	6b a1       	ldd	r22, Y+35	; 0x23
    27e4:	7c a1       	ldd	r23, Y+36	; 0x24
    27e6:	8d a1       	ldd	r24, Y+37	; 0x25
    27e8:	9e a1       	ldd	r25, Y+38	; 0x26
    27ea:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    27ee:	dc 01       	movw	r26, r24
    27f0:	cb 01       	movw	r24, r22
    27f2:	9a a3       	std	Y+34, r25	; 0x22
    27f4:	89 a3       	std	Y+33, r24	; 0x21
    27f6:	89 a1       	ldd	r24, Y+33	; 0x21
    27f8:	9a a1       	ldd	r25, Y+34	; 0x22
    27fa:	9e 8f       	std	Y+30, r25	; 0x1e
    27fc:	8d 8f       	std	Y+29, r24	; 0x1d
    27fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2800:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2802:	01 97       	sbiw	r24, 0x01	; 1
    2804:	f1 f7       	brne	.-4      	; 0x2802 <main+0x398>
    2806:	9e 8f       	std	Y+30, r25	; 0x1e
    2808:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(MEDIUM_DELAY);

		/*Step 1 part 3: Receive a signal from M2 to indicate the state of the two entered passwords*/
		UART_sendByte(UART_CHECKING_PASS);
    280a:	85 e0       	ldi	r24, 0x05	; 5
    280c:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
		matchedFlag = UART_recieveByte();
    2810:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    2814:	fe 01       	movw	r30, r28
    2816:	e9 5b       	subi	r30, 0xB9	; 185
    2818:	ff 4f       	sbci	r31, 0xFF	; 255
    281a:	80 83       	st	Z, r24

		/*Step 1 part 4: In case received signal is correct will go to step 2 if not go to step 1 */
		switch (matchedFlag) {
    281c:	fe 01       	movw	r30, r28
    281e:	e9 5b       	subi	r30, 0xB9	; 185
    2820:	ff 4f       	sbci	r31, 0xFF	; 255
    2822:	80 81       	ld	r24, Z
    2824:	28 2f       	mov	r18, r24
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	6b 96       	adiw	r28, 0x1b	; 27
    282a:	3f af       	std	Y+63, r19	; 0x3f
    282c:	2e af       	std	Y+62, r18	; 0x3e
    282e:	6b 97       	sbiw	r28, 0x1b	; 27
    2830:	6b 96       	adiw	r28, 0x1b	; 27
    2832:	8e ad       	ldd	r24, Y+62	; 0x3e
    2834:	9f ad       	ldd	r25, Y+63	; 0x3f
    2836:	6b 97       	sbiw	r28, 0x1b	; 27
    2838:	82 30       	cpi	r24, 0x02	; 2
    283a:	91 05       	cpc	r25, r1
    283c:	09 f4       	brne	.+2      	; 0x2840 <main+0x3d6>
    283e:	89 c0       	rjmp	.+274    	; 0x2952 <main+0x4e8>
    2840:	6b 96       	adiw	r28, 0x1b	; 27
    2842:	ee ad       	ldd	r30, Y+62	; 0x3e
    2844:	ff ad       	ldd	r31, Y+63	; 0x3f
    2846:	6b 97       	sbiw	r28, 0x1b	; 27
    2848:	e3 30       	cpi	r30, 0x03	; 3
    284a:	f1 05       	cpc	r31, r1
    284c:	09 f0       	breq	.+2      	; 0x2850 <main+0x3e6>
    284e:	61 ce       	rjmp	.-830    	; 0x2512 <main+0xa8>
		case CORRECT_PASSWORD:
			LCD_clearScreen();
    2850:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
			LCD_displayStringRowColumn(0, 0, "Pass Matched!");
    2854:	20 e6       	ldi	r18, 0x60	; 96
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	60 e0       	ldi	r22, 0x00	; 0
    285c:	a9 01       	movw	r20, r18
    285e:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
    2862:	80 e0       	ldi	r24, 0x00	; 0
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	a6 e9       	ldi	r26, 0x96	; 150
    2868:	b3 e4       	ldi	r27, 0x43	; 67
    286a:	89 8f       	std	Y+25, r24	; 0x19
    286c:	9a 8f       	std	Y+26, r25	; 0x1a
    286e:	ab 8f       	std	Y+27, r26	; 0x1b
    2870:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2872:	69 8d       	ldd	r22, Y+25	; 0x19
    2874:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2876:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2878:	9c 8d       	ldd	r25, Y+28	; 0x1c
    287a:	20 e0       	ldi	r18, 0x00	; 0
    287c:	30 e0       	ldi	r19, 0x00	; 0
    287e:	4a ef       	ldi	r20, 0xFA	; 250
    2880:	54 e4       	ldi	r21, 0x44	; 68
    2882:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2886:	dc 01       	movw	r26, r24
    2888:	cb 01       	movw	r24, r22
    288a:	8d 8b       	std	Y+21, r24	; 0x15
    288c:	9e 8b       	std	Y+22, r25	; 0x16
    288e:	af 8b       	std	Y+23, r26	; 0x17
    2890:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2892:	6d 89       	ldd	r22, Y+21	; 0x15
    2894:	7e 89       	ldd	r23, Y+22	; 0x16
    2896:	8f 89       	ldd	r24, Y+23	; 0x17
    2898:	98 8d       	ldd	r25, Y+24	; 0x18
    289a:	20 e0       	ldi	r18, 0x00	; 0
    289c:	30 e0       	ldi	r19, 0x00	; 0
    289e:	40 e8       	ldi	r20, 0x80	; 128
    28a0:	5f e3       	ldi	r21, 0x3F	; 63
    28a2:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    28a6:	88 23       	and	r24, r24
    28a8:	2c f4       	brge	.+10     	; 0x28b4 <main+0x44a>
		__ticks = 1;
    28aa:	81 e0       	ldi	r24, 0x01	; 1
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	9c 8b       	std	Y+20, r25	; 0x14
    28b0:	8b 8b       	std	Y+19, r24	; 0x13
    28b2:	3f c0       	rjmp	.+126    	; 0x2932 <main+0x4c8>
	else if (__tmp > 65535)
    28b4:	6d 89       	ldd	r22, Y+21	; 0x15
    28b6:	7e 89       	ldd	r23, Y+22	; 0x16
    28b8:	8f 89       	ldd	r24, Y+23	; 0x17
    28ba:	98 8d       	ldd	r25, Y+24	; 0x18
    28bc:	20 e0       	ldi	r18, 0x00	; 0
    28be:	3f ef       	ldi	r19, 0xFF	; 255
    28c0:	4f e7       	ldi	r20, 0x7F	; 127
    28c2:	57 e4       	ldi	r21, 0x47	; 71
    28c4:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    28c8:	18 16       	cp	r1, r24
    28ca:	4c f5       	brge	.+82     	; 0x291e <main+0x4b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    28cc:	69 8d       	ldd	r22, Y+25	; 0x19
    28ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    28d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    28d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    28d4:	20 e0       	ldi	r18, 0x00	; 0
    28d6:	30 e0       	ldi	r19, 0x00	; 0
    28d8:	40 e2       	ldi	r20, 0x20	; 32
    28da:	51 e4       	ldi	r21, 0x41	; 65
    28dc:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    28e0:	dc 01       	movw	r26, r24
    28e2:	cb 01       	movw	r24, r22
    28e4:	bc 01       	movw	r22, r24
    28e6:	cd 01       	movw	r24, r26
    28e8:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    28ec:	dc 01       	movw	r26, r24
    28ee:	cb 01       	movw	r24, r22
    28f0:	9c 8b       	std	Y+20, r25	; 0x14
    28f2:	8b 8b       	std	Y+19, r24	; 0x13
    28f4:	0f c0       	rjmp	.+30     	; 0x2914 <main+0x4aa>
    28f6:	88 ec       	ldi	r24, 0xC8	; 200
    28f8:	90 e0       	ldi	r25, 0x00	; 0
    28fa:	9a 8b       	std	Y+18, r25	; 0x12
    28fc:	89 8b       	std	Y+17, r24	; 0x11
    28fe:	89 89       	ldd	r24, Y+17	; 0x11
    2900:	9a 89       	ldd	r25, Y+18	; 0x12
    2902:	01 97       	sbiw	r24, 0x01	; 1
    2904:	f1 f7       	brne	.-4      	; 0x2902 <main+0x498>
    2906:	9a 8b       	std	Y+18, r25	; 0x12
    2908:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    290a:	8b 89       	ldd	r24, Y+19	; 0x13
    290c:	9c 89       	ldd	r25, Y+20	; 0x14
    290e:	01 97       	sbiw	r24, 0x01	; 1
    2910:	9c 8b       	std	Y+20, r25	; 0x14
    2912:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2914:	8b 89       	ldd	r24, Y+19	; 0x13
    2916:	9c 89       	ldd	r25, Y+20	; 0x14
    2918:	00 97       	sbiw	r24, 0x00	; 0
    291a:	69 f7       	brne	.-38     	; 0x28f6 <main+0x48c>
    291c:	14 c0       	rjmp	.+40     	; 0x2946 <main+0x4dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    291e:	6d 89       	ldd	r22, Y+21	; 0x15
    2920:	7e 89       	ldd	r23, Y+22	; 0x16
    2922:	8f 89       	ldd	r24, Y+23	; 0x17
    2924:	98 8d       	ldd	r25, Y+24	; 0x18
    2926:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    292a:	dc 01       	movw	r26, r24
    292c:	cb 01       	movw	r24, r22
    292e:	9c 8b       	std	Y+20, r25	; 0x14
    2930:	8b 8b       	std	Y+19, r24	; 0x13
    2932:	8b 89       	ldd	r24, Y+19	; 0x13
    2934:	9c 89       	ldd	r25, Y+20	; 0x14
    2936:	98 8b       	std	Y+16, r25	; 0x10
    2938:	8f 87       	std	Y+15, r24	; 0x0f
    293a:	8f 85       	ldd	r24, Y+15	; 0x0f
    293c:	98 89       	ldd	r25, Y+16	; 0x10
    293e:	01 97       	sbiw	r24, 0x01	; 1
    2940:	f1 f7       	brne	.-4      	; 0x293e <main+0x4d4>
    2942:	98 8b       	std	Y+16, r25	; 0x10
    2944:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(MEDIUM_DELAY);

			/*Step 2 part 1: go to main options of the system + open door , - change password*/
			MainSystemOptions(password1);
    2946:	ce 01       	movw	r24, r28
    2948:	88 5b       	subi	r24, 0xB8	; 184
    294a:	9f 4f       	sbci	r25, 0xFF	; 255
    294c:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <MainSystemOptions>
    2950:	e0 cd       	rjmp	.-1088   	; 0x2512 <main+0xa8>

			break;
		case INCORRECT_PASSWORD:
			LCD_clearScreen();
    2952:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
			LCD_displayStringRowColumn(0, 0, "Pass Not Matched!");
    2956:	2e e6       	ldi	r18, 0x6E	; 110
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	80 e0       	ldi	r24, 0x00	; 0
    295c:	60 e0       	ldi	r22, 0x00	; 0
    295e:	a9 01       	movw	r20, r18
    2960:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
    2964:	80 e0       	ldi	r24, 0x00	; 0
    2966:	90 e0       	ldi	r25, 0x00	; 0
    2968:	a6 e9       	ldi	r26, 0x96	; 150
    296a:	b3 e4       	ldi	r27, 0x43	; 67
    296c:	8b 87       	std	Y+11, r24	; 0x0b
    296e:	9c 87       	std	Y+12, r25	; 0x0c
    2970:	ad 87       	std	Y+13, r26	; 0x0d
    2972:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2974:	6b 85       	ldd	r22, Y+11	; 0x0b
    2976:	7c 85       	ldd	r23, Y+12	; 0x0c
    2978:	8d 85       	ldd	r24, Y+13	; 0x0d
    297a:	9e 85       	ldd	r25, Y+14	; 0x0e
    297c:	20 e0       	ldi	r18, 0x00	; 0
    297e:	30 e0       	ldi	r19, 0x00	; 0
    2980:	4a ef       	ldi	r20, 0xFA	; 250
    2982:	54 e4       	ldi	r21, 0x44	; 68
    2984:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2988:	dc 01       	movw	r26, r24
    298a:	cb 01       	movw	r24, r22
    298c:	8f 83       	std	Y+7, r24	; 0x07
    298e:	98 87       	std	Y+8, r25	; 0x08
    2990:	a9 87       	std	Y+9, r26	; 0x09
    2992:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2994:	6f 81       	ldd	r22, Y+7	; 0x07
    2996:	78 85       	ldd	r23, Y+8	; 0x08
    2998:	89 85       	ldd	r24, Y+9	; 0x09
    299a:	9a 85       	ldd	r25, Y+10	; 0x0a
    299c:	20 e0       	ldi	r18, 0x00	; 0
    299e:	30 e0       	ldi	r19, 0x00	; 0
    29a0:	40 e8       	ldi	r20, 0x80	; 128
    29a2:	5f e3       	ldi	r21, 0x3F	; 63
    29a4:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    29a8:	88 23       	and	r24, r24
    29aa:	2c f4       	brge	.+10     	; 0x29b6 <main+0x54c>
		__ticks = 1;
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	9e 83       	std	Y+6, r25	; 0x06
    29b2:	8d 83       	std	Y+5, r24	; 0x05
    29b4:	3f c0       	rjmp	.+126    	; 0x2a34 <main+0x5ca>
	else if (__tmp > 65535)
    29b6:	6f 81       	ldd	r22, Y+7	; 0x07
    29b8:	78 85       	ldd	r23, Y+8	; 0x08
    29ba:	89 85       	ldd	r24, Y+9	; 0x09
    29bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    29be:	20 e0       	ldi	r18, 0x00	; 0
    29c0:	3f ef       	ldi	r19, 0xFF	; 255
    29c2:	4f e7       	ldi	r20, 0x7F	; 127
    29c4:	57 e4       	ldi	r21, 0x47	; 71
    29c6:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    29ca:	18 16       	cp	r1, r24
    29cc:	4c f5       	brge	.+82     	; 0x2a20 <main+0x5b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29ce:	6b 85       	ldd	r22, Y+11	; 0x0b
    29d0:	7c 85       	ldd	r23, Y+12	; 0x0c
    29d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    29d4:	9e 85       	ldd	r25, Y+14	; 0x0e
    29d6:	20 e0       	ldi	r18, 0x00	; 0
    29d8:	30 e0       	ldi	r19, 0x00	; 0
    29da:	40 e2       	ldi	r20, 0x20	; 32
    29dc:	51 e4       	ldi	r21, 0x41	; 65
    29de:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    29e2:	dc 01       	movw	r26, r24
    29e4:	cb 01       	movw	r24, r22
    29e6:	bc 01       	movw	r22, r24
    29e8:	cd 01       	movw	r24, r26
    29ea:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    29ee:	dc 01       	movw	r26, r24
    29f0:	cb 01       	movw	r24, r22
    29f2:	9e 83       	std	Y+6, r25	; 0x06
    29f4:	8d 83       	std	Y+5, r24	; 0x05
    29f6:	0f c0       	rjmp	.+30     	; 0x2a16 <main+0x5ac>
    29f8:	88 ec       	ldi	r24, 0xC8	; 200
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	9c 83       	std	Y+4, r25	; 0x04
    29fe:	8b 83       	std	Y+3, r24	; 0x03
    2a00:	8b 81       	ldd	r24, Y+3	; 0x03
    2a02:	9c 81       	ldd	r25, Y+4	; 0x04
    2a04:	01 97       	sbiw	r24, 0x01	; 1
    2a06:	f1 f7       	brne	.-4      	; 0x2a04 <main+0x59a>
    2a08:	9c 83       	std	Y+4, r25	; 0x04
    2a0a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a10:	01 97       	sbiw	r24, 0x01	; 1
    2a12:	9e 83       	std	Y+6, r25	; 0x06
    2a14:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a16:	8d 81       	ldd	r24, Y+5	; 0x05
    2a18:	9e 81       	ldd	r25, Y+6	; 0x06
    2a1a:	00 97       	sbiw	r24, 0x00	; 0
    2a1c:	69 f7       	brne	.-38     	; 0x29f8 <main+0x58e>
    2a1e:	79 cd       	rjmp	.-1294   	; 0x2512 <main+0xa8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a20:	6f 81       	ldd	r22, Y+7	; 0x07
    2a22:	78 85       	ldd	r23, Y+8	; 0x08
    2a24:	89 85       	ldd	r24, Y+9	; 0x09
    2a26:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a28:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2a2c:	dc 01       	movw	r26, r24
    2a2e:	cb 01       	movw	r24, r22
    2a30:	9e 83       	std	Y+6, r25	; 0x06
    2a32:	8d 83       	std	Y+5, r24	; 0x05
    2a34:	8d 81       	ldd	r24, Y+5	; 0x05
    2a36:	9e 81       	ldd	r25, Y+6	; 0x06
    2a38:	9a 83       	std	Y+2, r25	; 0x02
    2a3a:	89 83       	std	Y+1, r24	; 0x01
    2a3c:	89 81       	ldd	r24, Y+1	; 0x01
    2a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a40:	01 97       	sbiw	r24, 0x01	; 1
    2a42:	f1 f7       	brne	.-4      	; 0x2a40 <main+0x5d6>
    2a44:	9a 83       	std	Y+2, r25	; 0x02
    2a46:	89 83       	std	Y+1, r24	; 0x01
    2a48:	64 cd       	rjmp	.-1336   	; 0x2512 <main+0xa8>

00002a4a <timer1_tick>:
 *                    FUNCTION DEFINITION FOR TIMER                            *
 *******************************************************************************/
/*
 * Timer 1 handling the delay , in order to avoid any delay that might happened due to context switch
 */
void timer1_tick(void) {
    2a4a:	df 93       	push	r29
    2a4c:	cf 93       	push	r28
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
	timer1_Ticks++;
    2a52:	80 91 2a 01 	lds	r24, 0x012A
    2a56:	8f 5f       	subi	r24, 0xFF	; 255
    2a58:	80 93 2a 01 	sts	0x012A, r24
}
    2a5c:	cf 91       	pop	r28
    2a5e:	df 91       	pop	r29
    2a60:	08 95       	ret

00002a62 <timer1_delay>:

void timer1_delay(uint8 seconds) {
    2a62:	df 93       	push	r29
    2a64:	cf 93       	push	r28
    2a66:	cd b7       	in	r28, 0x3d	; 61
    2a68:	de b7       	in	r29, 0x3e	; 62
    2a6a:	2c 97       	sbiw	r28, 0x0c	; 12
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	cd bf       	out	0x3d, r28	; 61
    2a76:	8f 83       	std	Y+7, r24	; 0x07
	timer1_Ticks = 0; // Reset the timer
    2a78:	10 92 2a 01 	sts	0x012A, r1
	 * Operation mode: 	Compare mode
	 * OCR1A = 31250	Compare value
	 * Generates an interrupt every 1 second
	 */

	Timer1_ConfigType TIMER1_Config = { 0, 31250, CLK_256, Compare_Mode };
    2a7c:	ce 01       	movw	r24, r28
    2a7e:	01 96       	adiw	r24, 0x01	; 1
    2a80:	99 87       	std	Y+9, r25	; 0x09
    2a82:	88 87       	std	Y+8, r24	; 0x08
    2a84:	e2 e2       	ldi	r30, 0x22	; 34
    2a86:	f1 e0       	ldi	r31, 0x01	; 1
    2a88:	fb 87       	std	Y+11, r31	; 0x0b
    2a8a:	ea 87       	std	Y+10, r30	; 0x0a
    2a8c:	f6 e0       	ldi	r31, 0x06	; 6
    2a8e:	fc 87       	std	Y+12, r31	; 0x0c
    2a90:	ea 85       	ldd	r30, Y+10	; 0x0a
    2a92:	fb 85       	ldd	r31, Y+11	; 0x0b
    2a94:	00 80       	ld	r0, Z
    2a96:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a98:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a9a:	01 96       	adiw	r24, 0x01	; 1
    2a9c:	9b 87       	std	Y+11, r25	; 0x0b
    2a9e:	8a 87       	std	Y+10, r24	; 0x0a
    2aa0:	e8 85       	ldd	r30, Y+8	; 0x08
    2aa2:	f9 85       	ldd	r31, Y+9	; 0x09
    2aa4:	00 82       	st	Z, r0
    2aa6:	88 85       	ldd	r24, Y+8	; 0x08
    2aa8:	99 85       	ldd	r25, Y+9	; 0x09
    2aaa:	01 96       	adiw	r24, 0x01	; 1
    2aac:	99 87       	std	Y+9, r25	; 0x09
    2aae:	88 87       	std	Y+8, r24	; 0x08
    2ab0:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ab2:	91 50       	subi	r25, 0x01	; 1
    2ab4:	9c 87       	std	Y+12, r25	; 0x0c
    2ab6:	ec 85       	ldd	r30, Y+12	; 0x0c
    2ab8:	ee 23       	and	r30, r30
    2aba:	51 f7       	brne	.-44     	; 0x2a90 <timer1_delay+0x2e>
	/* Reinitialize the timer */
	Timer1_init(&TIMER1_Config);
    2abc:	ce 01       	movw	r24, r28
    2abe:	01 96       	adiw	r24, 0x01	; 1
    2ac0:	0e 94 99 07 	call	0xf32	; 0xf32 <Timer1_init>
	Timer1_setCallBack(timer1_tick);
    2ac4:	85 e2       	ldi	r24, 0x25	; 37
    2ac6:	95 e1       	ldi	r25, 0x15	; 21
    2ac8:	0e 94 01 08 	call	0x1002	; 0x1002 <Timer1_setCallBack>
	while (timer1_Ticks != seconds);
    2acc:	90 91 2a 01 	lds	r25, 0x012A
    2ad0:	8f 81       	ldd	r24, Y+7	; 0x07
    2ad2:	98 17       	cp	r25, r24
    2ad4:	d9 f7       	brne	.-10     	; 0x2acc <timer1_delay+0x6a>
	Timer1_deInit();
    2ad6:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <Timer1_deInit>
}
    2ada:	2c 96       	adiw	r28, 0x0c	; 12
    2adc:	0f b6       	in	r0, 0x3f	; 63
    2ade:	f8 94       	cli
    2ae0:	de bf       	out	0x3e, r29	; 62
    2ae2:	0f be       	out	0x3f, r0	; 63
    2ae4:	cd bf       	out	0x3d, r28	; 61
    2ae6:	cf 91       	pop	r28
    2ae8:	df 91       	pop	r29
    2aea:	08 95       	ret

00002aec <EnterPassword>:

/*
 * EnterPassword function takes a password of 5 digits from the user and
 * saves it in an array.
 */
void EnterPassword(uint8 *password) {
    2aec:	df 93       	push	r29
    2aee:	cf 93       	push	r28
    2af0:	cd b7       	in	r28, 0x3d	; 61
    2af2:	de b7       	in	r29, 0x3e	; 62
    2af4:	a0 97       	sbiw	r28, 0x20	; 32
    2af6:	0f b6       	in	r0, 0x3f	; 63
    2af8:	f8 94       	cli
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	0f be       	out	0x3f, r0	; 63
    2afe:	cd bf       	out	0x3d, r28	; 61
    2b00:	98 a3       	std	Y+32, r25	; 0x20
    2b02:	8f 8f       	std	Y+31, r24	; 0x1f
	uint8 i, key;
	LCD_clearScreen();
    2b04:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Plz enter pass:");
    2b08:	20 e8       	ldi	r18, 0x80	; 128
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	80 e0       	ldi	r24, 0x00	; 0
    2b0e:	60 e0       	ldi	r22, 0x00	; 0
    2b10:	a9 01       	movw	r20, r18
    2b12:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
    2b16:	81 e0       	ldi	r24, 0x01	; 1
    2b18:	60 e0       	ldi	r22, 0x00	; 0
    2b1a:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>
	i = 0; /* Reset 'i' when starting a new password entry */
    2b1e:	1e 8e       	std	Y+30, r1	; 0x1e
    2b20:	88 c0       	rjmp	.+272    	; 0x2c32 <EnterPassword+0x146>

	while (i < PASSWORD_SIZE) {
		key = KEYPAD_getPressedKey();
    2b22:	0e 94 aa 10 	call	0x2154	; 0x2154 <KEYPAD_getPressedKey>
    2b26:	8d 8f       	std	Y+29, r24	; 0x1d
		if ((key >= 0) && (key <= 9)) {
    2b28:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2b2a:	8a 30       	cpi	r24, 0x0A	; 10
    2b2c:	80 f4       	brcc	.+32     	; 0x2b4e <EnterPassword+0x62>
			password[i] = key;
    2b2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2b30:	28 2f       	mov	r18, r24
    2b32:	30 e0       	ldi	r19, 0x00	; 0
    2b34:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2b36:	98 a1       	ldd	r25, Y+32	; 0x20
    2b38:	fc 01       	movw	r30, r24
    2b3a:	e2 0f       	add	r30, r18
    2b3c:	f3 1f       	adc	r31, r19
    2b3e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2b40:	80 83       	st	Z, r24
			LCD_displayCharacter('*'); /* Display an asterisk for each character entered */
    2b42:	8a e2       	ldi	r24, 0x2A	; 42
    2b44:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <LCD_displayCharacter>
			i++; /* Only increment when a valid key is pressed*/
    2b48:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2b4a:	8f 5f       	subi	r24, 0xFF	; 255
    2b4c:	8e 8f       	std	Y+30, r24	; 0x1e
    2b4e:	80 e0       	ldi	r24, 0x00	; 0
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	aa ef       	ldi	r26, 0xFA	; 250
    2b54:	b3 e4       	ldi	r27, 0x43	; 67
    2b56:	89 8f       	std	Y+25, r24	; 0x19
    2b58:	9a 8f       	std	Y+26, r25	; 0x1a
    2b5a:	ab 8f       	std	Y+27, r26	; 0x1b
    2b5c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2b5e:	69 8d       	ldd	r22, Y+25	; 0x19
    2b60:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2b62:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2b64:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	4a ef       	ldi	r20, 0xFA	; 250
    2b6c:	54 e4       	ldi	r21, 0x44	; 68
    2b6e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2b72:	dc 01       	movw	r26, r24
    2b74:	cb 01       	movw	r24, r22
    2b76:	8d 8b       	std	Y+21, r24	; 0x15
    2b78:	9e 8b       	std	Y+22, r25	; 0x16
    2b7a:	af 8b       	std	Y+23, r26	; 0x17
    2b7c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2b7e:	6d 89       	ldd	r22, Y+21	; 0x15
    2b80:	7e 89       	ldd	r23, Y+22	; 0x16
    2b82:	8f 89       	ldd	r24, Y+23	; 0x17
    2b84:	98 8d       	ldd	r25, Y+24	; 0x18
    2b86:	20 e0       	ldi	r18, 0x00	; 0
    2b88:	30 e0       	ldi	r19, 0x00	; 0
    2b8a:	40 e8       	ldi	r20, 0x80	; 128
    2b8c:	5f e3       	ldi	r21, 0x3F	; 63
    2b8e:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2b92:	88 23       	and	r24, r24
    2b94:	2c f4       	brge	.+10     	; 0x2ba0 <EnterPassword+0xb4>
		__ticks = 1;
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	90 e0       	ldi	r25, 0x00	; 0
    2b9a:	9c 8b       	std	Y+20, r25	; 0x14
    2b9c:	8b 8b       	std	Y+19, r24	; 0x13
    2b9e:	3f c0       	rjmp	.+126    	; 0x2c1e <EnterPassword+0x132>
	else if (__tmp > 65535)
    2ba0:	6d 89       	ldd	r22, Y+21	; 0x15
    2ba2:	7e 89       	ldd	r23, Y+22	; 0x16
    2ba4:	8f 89       	ldd	r24, Y+23	; 0x17
    2ba6:	98 8d       	ldd	r25, Y+24	; 0x18
    2ba8:	20 e0       	ldi	r18, 0x00	; 0
    2baa:	3f ef       	ldi	r19, 0xFF	; 255
    2bac:	4f e7       	ldi	r20, 0x7F	; 127
    2bae:	57 e4       	ldi	r21, 0x47	; 71
    2bb0:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    2bb4:	18 16       	cp	r1, r24
    2bb6:	4c f5       	brge	.+82     	; 0x2c0a <EnterPassword+0x11e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2bb8:	69 8d       	ldd	r22, Y+25	; 0x19
    2bba:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2bbc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2bbe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2bc0:	20 e0       	ldi	r18, 0x00	; 0
    2bc2:	30 e0       	ldi	r19, 0x00	; 0
    2bc4:	40 e2       	ldi	r20, 0x20	; 32
    2bc6:	51 e4       	ldi	r21, 0x41	; 65
    2bc8:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2bcc:	dc 01       	movw	r26, r24
    2bce:	cb 01       	movw	r24, r22
    2bd0:	bc 01       	movw	r22, r24
    2bd2:	cd 01       	movw	r24, r26
    2bd4:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2bd8:	dc 01       	movw	r26, r24
    2bda:	cb 01       	movw	r24, r22
    2bdc:	9c 8b       	std	Y+20, r25	; 0x14
    2bde:	8b 8b       	std	Y+19, r24	; 0x13
    2be0:	0f c0       	rjmp	.+30     	; 0x2c00 <EnterPassword+0x114>
    2be2:	88 ec       	ldi	r24, 0xC8	; 200
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	9a 8b       	std	Y+18, r25	; 0x12
    2be8:	89 8b       	std	Y+17, r24	; 0x11
    2bea:	89 89       	ldd	r24, Y+17	; 0x11
    2bec:	9a 89       	ldd	r25, Y+18	; 0x12
    2bee:	01 97       	sbiw	r24, 0x01	; 1
    2bf0:	f1 f7       	brne	.-4      	; 0x2bee <EnterPassword+0x102>
    2bf2:	9a 8b       	std	Y+18, r25	; 0x12
    2bf4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2bf6:	8b 89       	ldd	r24, Y+19	; 0x13
    2bf8:	9c 89       	ldd	r25, Y+20	; 0x14
    2bfa:	01 97       	sbiw	r24, 0x01	; 1
    2bfc:	9c 8b       	std	Y+20, r25	; 0x14
    2bfe:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c00:	8b 89       	ldd	r24, Y+19	; 0x13
    2c02:	9c 89       	ldd	r25, Y+20	; 0x14
    2c04:	00 97       	sbiw	r24, 0x00	; 0
    2c06:	69 f7       	brne	.-38     	; 0x2be2 <EnterPassword+0xf6>
    2c08:	14 c0       	rjmp	.+40     	; 0x2c32 <EnterPassword+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c0a:	6d 89       	ldd	r22, Y+21	; 0x15
    2c0c:	7e 89       	ldd	r23, Y+22	; 0x16
    2c0e:	8f 89       	ldd	r24, Y+23	; 0x17
    2c10:	98 8d       	ldd	r25, Y+24	; 0x18
    2c12:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2c16:	dc 01       	movw	r26, r24
    2c18:	cb 01       	movw	r24, r22
    2c1a:	9c 8b       	std	Y+20, r25	; 0x14
    2c1c:	8b 8b       	std	Y+19, r24	; 0x13
    2c1e:	8b 89       	ldd	r24, Y+19	; 0x13
    2c20:	9c 89       	ldd	r25, Y+20	; 0x14
    2c22:	98 8b       	std	Y+16, r25	; 0x10
    2c24:	8f 87       	std	Y+15, r24	; 0x0f
    2c26:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c28:	98 89       	ldd	r25, Y+16	; 0x10
    2c2a:	01 97       	sbiw	r24, 0x01	; 1
    2c2c:	f1 f7       	brne	.-4      	; 0x2c2a <EnterPassword+0x13e>
    2c2e:	98 8b       	std	Y+16, r25	; 0x10
    2c30:	8f 87       	std	Y+15, r24	; 0x0f
	LCD_clearScreen();
	LCD_displayStringRowColumn(0, 0, "Plz enter pass:");
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
	i = 0; /* Reset 'i' when starting a new password entry */

	while (i < PASSWORD_SIZE) {
    2c32:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2c34:	85 30       	cpi	r24, 0x05	; 5
    2c36:	08 f4       	brcc	.+2      	; 0x2c3a <EnterPassword+0x14e>
    2c38:	74 cf       	rjmp	.-280    	; 0x2b22 <EnterPassword+0x36>
			LCD_displayCharacter('*'); /* Display an asterisk for each character entered */
			i++; /* Only increment when a valid key is pressed*/
		}
		_delay_ms(KEY_PRESSED_DELAY); /* Delay between key presses*/
	}
	while (KEYPAD_getPressedKey() != '=');
    2c3a:	0e 94 aa 10 	call	0x2154	; 0x2154 <KEYPAD_getPressedKey>
    2c3e:	8d 33       	cpi	r24, 0x3D	; 61
    2c40:	e1 f7       	brne	.-8      	; 0x2c3a <EnterPassword+0x14e>
    2c42:	80 e0       	ldi	r24, 0x00	; 0
    2c44:	90 e0       	ldi	r25, 0x00	; 0
    2c46:	aa ef       	ldi	r26, 0xFA	; 250
    2c48:	b3 e4       	ldi	r27, 0x43	; 67
    2c4a:	8b 87       	std	Y+11, r24	; 0x0b
    2c4c:	9c 87       	std	Y+12, r25	; 0x0c
    2c4e:	ad 87       	std	Y+13, r26	; 0x0d
    2c50:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2c52:	6b 85       	ldd	r22, Y+11	; 0x0b
    2c54:	7c 85       	ldd	r23, Y+12	; 0x0c
    2c56:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c58:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c5a:	20 e0       	ldi	r18, 0x00	; 0
    2c5c:	30 e0       	ldi	r19, 0x00	; 0
    2c5e:	4a ef       	ldi	r20, 0xFA	; 250
    2c60:	54 e4       	ldi	r21, 0x44	; 68
    2c62:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2c66:	dc 01       	movw	r26, r24
    2c68:	cb 01       	movw	r24, r22
    2c6a:	8f 83       	std	Y+7, r24	; 0x07
    2c6c:	98 87       	std	Y+8, r25	; 0x08
    2c6e:	a9 87       	std	Y+9, r26	; 0x09
    2c70:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2c72:	6f 81       	ldd	r22, Y+7	; 0x07
    2c74:	78 85       	ldd	r23, Y+8	; 0x08
    2c76:	89 85       	ldd	r24, Y+9	; 0x09
    2c78:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c7a:	20 e0       	ldi	r18, 0x00	; 0
    2c7c:	30 e0       	ldi	r19, 0x00	; 0
    2c7e:	40 e8       	ldi	r20, 0x80	; 128
    2c80:	5f e3       	ldi	r21, 0x3F	; 63
    2c82:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2c86:	88 23       	and	r24, r24
    2c88:	2c f4       	brge	.+10     	; 0x2c94 <EnterPassword+0x1a8>
		__ticks = 1;
    2c8a:	81 e0       	ldi	r24, 0x01	; 1
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	9e 83       	std	Y+6, r25	; 0x06
    2c90:	8d 83       	std	Y+5, r24	; 0x05
    2c92:	3f c0       	rjmp	.+126    	; 0x2d12 <EnterPassword+0x226>
	else if (__tmp > 65535)
    2c94:	6f 81       	ldd	r22, Y+7	; 0x07
    2c96:	78 85       	ldd	r23, Y+8	; 0x08
    2c98:	89 85       	ldd	r24, Y+9	; 0x09
    2c9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c9c:	20 e0       	ldi	r18, 0x00	; 0
    2c9e:	3f ef       	ldi	r19, 0xFF	; 255
    2ca0:	4f e7       	ldi	r20, 0x7F	; 127
    2ca2:	57 e4       	ldi	r21, 0x47	; 71
    2ca4:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    2ca8:	18 16       	cp	r1, r24
    2caa:	4c f5       	brge	.+82     	; 0x2cfe <EnterPassword+0x212>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2cac:	6b 85       	ldd	r22, Y+11	; 0x0b
    2cae:	7c 85       	ldd	r23, Y+12	; 0x0c
    2cb0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cb2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cb4:	20 e0       	ldi	r18, 0x00	; 0
    2cb6:	30 e0       	ldi	r19, 0x00	; 0
    2cb8:	40 e2       	ldi	r20, 0x20	; 32
    2cba:	51 e4       	ldi	r21, 0x41	; 65
    2cbc:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2cc0:	dc 01       	movw	r26, r24
    2cc2:	cb 01       	movw	r24, r22
    2cc4:	bc 01       	movw	r22, r24
    2cc6:	cd 01       	movw	r24, r26
    2cc8:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2ccc:	dc 01       	movw	r26, r24
    2cce:	cb 01       	movw	r24, r22
    2cd0:	9e 83       	std	Y+6, r25	; 0x06
    2cd2:	8d 83       	std	Y+5, r24	; 0x05
    2cd4:	0f c0       	rjmp	.+30     	; 0x2cf4 <EnterPassword+0x208>
    2cd6:	88 ec       	ldi	r24, 0xC8	; 200
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	9c 83       	std	Y+4, r25	; 0x04
    2cdc:	8b 83       	std	Y+3, r24	; 0x03
    2cde:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce2:	01 97       	sbiw	r24, 0x01	; 1
    2ce4:	f1 f7       	brne	.-4      	; 0x2ce2 <EnterPassword+0x1f6>
    2ce6:	9c 83       	std	Y+4, r25	; 0x04
    2ce8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2cea:	8d 81       	ldd	r24, Y+5	; 0x05
    2cec:	9e 81       	ldd	r25, Y+6	; 0x06
    2cee:	01 97       	sbiw	r24, 0x01	; 1
    2cf0:	9e 83       	std	Y+6, r25	; 0x06
    2cf2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cf4:	8d 81       	ldd	r24, Y+5	; 0x05
    2cf6:	9e 81       	ldd	r25, Y+6	; 0x06
    2cf8:	00 97       	sbiw	r24, 0x00	; 0
    2cfa:	69 f7       	brne	.-38     	; 0x2cd6 <EnterPassword+0x1ea>
    2cfc:	14 c0       	rjmp	.+40     	; 0x2d26 <EnterPassword+0x23a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2cfe:	6f 81       	ldd	r22, Y+7	; 0x07
    2d00:	78 85       	ldd	r23, Y+8	; 0x08
    2d02:	89 85       	ldd	r24, Y+9	; 0x09
    2d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d06:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2d0a:	dc 01       	movw	r26, r24
    2d0c:	cb 01       	movw	r24, r22
    2d0e:	9e 83       	std	Y+6, r25	; 0x06
    2d10:	8d 83       	std	Y+5, r24	; 0x05
    2d12:	8d 81       	ldd	r24, Y+5	; 0x05
    2d14:	9e 81       	ldd	r25, Y+6	; 0x06
    2d16:	9a 83       	std	Y+2, r25	; 0x02
    2d18:	89 83       	std	Y+1, r24	; 0x01
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
    2d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1e:	01 97       	sbiw	r24, 0x01	; 1
    2d20:	f1 f7       	brne	.-4      	; 0x2d1e <EnterPassword+0x232>
    2d22:	9a 83       	std	Y+2, r25	; 0x02
    2d24:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(KEY_PRESSED_DELAY);
}
    2d26:	a0 96       	adiw	r28, 0x20	; 32
    2d28:	0f b6       	in	r0, 0x3f	; 63
    2d2a:	f8 94       	cli
    2d2c:	de bf       	out	0x3e, r29	; 62
    2d2e:	0f be       	out	0x3f, r0	; 63
    2d30:	cd bf       	out	0x3d, r28	; 61
    2d32:	cf 91       	pop	r28
    2d34:	df 91       	pop	r29
    2d36:	08 95       	ret

00002d38 <ReEnterSamePassword>:

/*
 * ReEnterSamePassword function re-enters the same password to confirm it.
 * It checks if the re-entered password matches the first password.
 */
void ReEnterSamePassword(uint8 *password) {
    2d38:	df 93       	push	r29
    2d3a:	cf 93       	push	r28
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	a0 97       	sbiw	r28, 0x20	; 32
    2d42:	0f b6       	in	r0, 0x3f	; 63
    2d44:	f8 94       	cli
    2d46:	de bf       	out	0x3e, r29	; 62
    2d48:	0f be       	out	0x3f, r0	; 63
    2d4a:	cd bf       	out	0x3d, r28	; 61
    2d4c:	98 a3       	std	Y+32, r25	; 0x20
    2d4e:	8f 8f       	std	Y+31, r24	; 0x1f
	uint8 i, key;
	LCD_clearScreen();
    2d50:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Plz re-enter the");
    2d54:	20 e9       	ldi	r18, 0x90	; 144
    2d56:	30 e0       	ldi	r19, 0x00	; 0
    2d58:	80 e0       	ldi	r24, 0x00	; 0
    2d5a:	60 e0       	ldi	r22, 0x00	; 0
    2d5c:	a9 01       	movw	r20, r18
    2d5e:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
    2d62:	81 e0       	ldi	r24, 0x01	; 1
    2d64:	60 e0       	ldi	r22, 0x00	; 0
    2d66:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>
	LCD_displayStringRowColumn(1, 0, "same pass:");
    2d6a:	21 ea       	ldi	r18, 0xA1	; 161
    2d6c:	30 e0       	ldi	r19, 0x00	; 0
    2d6e:	81 e0       	ldi	r24, 0x01	; 1
    2d70:	60 e0       	ldi	r22, 0x00	; 0
    2d72:	a9 01       	movw	r20, r18
    2d74:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 10);
    2d78:	81 e0       	ldi	r24, 0x01	; 1
    2d7a:	6a e0       	ldi	r22, 0x0A	; 10
    2d7c:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>
	i = 0; /* Reset 'i' when starting a new password entry */
    2d80:	1e 8e       	std	Y+30, r1	; 0x1e
    2d82:	88 c0       	rjmp	.+272    	; 0x2e94 <ReEnterSamePassword+0x15c>

	while (i < PASSWORD_SIZE) {
		key = KEYPAD_getPressedKey();
    2d84:	0e 94 aa 10 	call	0x2154	; 0x2154 <KEYPAD_getPressedKey>
    2d88:	8d 8f       	std	Y+29, r24	; 0x1d
		if ((key >= 0) && (key <= 9)) {
    2d8a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2d8c:	8a 30       	cpi	r24, 0x0A	; 10
    2d8e:	80 f4       	brcc	.+32     	; 0x2db0 <ReEnterSamePassword+0x78>
			password[i] = key;
    2d90:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2d92:	28 2f       	mov	r18, r24
    2d94:	30 e0       	ldi	r19, 0x00	; 0
    2d96:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2d98:	98 a1       	ldd	r25, Y+32	; 0x20
    2d9a:	fc 01       	movw	r30, r24
    2d9c:	e2 0f       	add	r30, r18
    2d9e:	f3 1f       	adc	r31, r19
    2da0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2da2:	80 83       	st	Z, r24
			LCD_displayCharacter('*'); /* Display an asterisk for each character entered */
    2da4:	8a e2       	ldi	r24, 0x2A	; 42
    2da6:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <LCD_displayCharacter>
			i++; /* Only increment when a valid key is pressed*/
    2daa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2dac:	8f 5f       	subi	r24, 0xFF	; 255
    2dae:	8e 8f       	std	Y+30, r24	; 0x1e
    2db0:	80 e0       	ldi	r24, 0x00	; 0
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	aa ef       	ldi	r26, 0xFA	; 250
    2db6:	b3 e4       	ldi	r27, 0x43	; 67
    2db8:	89 8f       	std	Y+25, r24	; 0x19
    2dba:	9a 8f       	std	Y+26, r25	; 0x1a
    2dbc:	ab 8f       	std	Y+27, r26	; 0x1b
    2dbe:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2dc0:	69 8d       	ldd	r22, Y+25	; 0x19
    2dc2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2dc4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2dc6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2dc8:	20 e0       	ldi	r18, 0x00	; 0
    2dca:	30 e0       	ldi	r19, 0x00	; 0
    2dcc:	4a ef       	ldi	r20, 0xFA	; 250
    2dce:	54 e4       	ldi	r21, 0x44	; 68
    2dd0:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2dd4:	dc 01       	movw	r26, r24
    2dd6:	cb 01       	movw	r24, r22
    2dd8:	8d 8b       	std	Y+21, r24	; 0x15
    2dda:	9e 8b       	std	Y+22, r25	; 0x16
    2ddc:	af 8b       	std	Y+23, r26	; 0x17
    2dde:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2de0:	6d 89       	ldd	r22, Y+21	; 0x15
    2de2:	7e 89       	ldd	r23, Y+22	; 0x16
    2de4:	8f 89       	ldd	r24, Y+23	; 0x17
    2de6:	98 8d       	ldd	r25, Y+24	; 0x18
    2de8:	20 e0       	ldi	r18, 0x00	; 0
    2dea:	30 e0       	ldi	r19, 0x00	; 0
    2dec:	40 e8       	ldi	r20, 0x80	; 128
    2dee:	5f e3       	ldi	r21, 0x3F	; 63
    2df0:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2df4:	88 23       	and	r24, r24
    2df6:	2c f4       	brge	.+10     	; 0x2e02 <ReEnterSamePassword+0xca>
		__ticks = 1;
    2df8:	81 e0       	ldi	r24, 0x01	; 1
    2dfa:	90 e0       	ldi	r25, 0x00	; 0
    2dfc:	9c 8b       	std	Y+20, r25	; 0x14
    2dfe:	8b 8b       	std	Y+19, r24	; 0x13
    2e00:	3f c0       	rjmp	.+126    	; 0x2e80 <ReEnterSamePassword+0x148>
	else if (__tmp > 65535)
    2e02:	6d 89       	ldd	r22, Y+21	; 0x15
    2e04:	7e 89       	ldd	r23, Y+22	; 0x16
    2e06:	8f 89       	ldd	r24, Y+23	; 0x17
    2e08:	98 8d       	ldd	r25, Y+24	; 0x18
    2e0a:	20 e0       	ldi	r18, 0x00	; 0
    2e0c:	3f ef       	ldi	r19, 0xFF	; 255
    2e0e:	4f e7       	ldi	r20, 0x7F	; 127
    2e10:	57 e4       	ldi	r21, 0x47	; 71
    2e12:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    2e16:	18 16       	cp	r1, r24
    2e18:	4c f5       	brge	.+82     	; 0x2e6c <ReEnterSamePassword+0x134>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2e1a:	69 8d       	ldd	r22, Y+25	; 0x19
    2e1c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2e1e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2e20:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2e22:	20 e0       	ldi	r18, 0x00	; 0
    2e24:	30 e0       	ldi	r19, 0x00	; 0
    2e26:	40 e2       	ldi	r20, 0x20	; 32
    2e28:	51 e4       	ldi	r21, 0x41	; 65
    2e2a:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2e2e:	dc 01       	movw	r26, r24
    2e30:	cb 01       	movw	r24, r22
    2e32:	bc 01       	movw	r22, r24
    2e34:	cd 01       	movw	r24, r26
    2e36:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2e3a:	dc 01       	movw	r26, r24
    2e3c:	cb 01       	movw	r24, r22
    2e3e:	9c 8b       	std	Y+20, r25	; 0x14
    2e40:	8b 8b       	std	Y+19, r24	; 0x13
    2e42:	0f c0       	rjmp	.+30     	; 0x2e62 <ReEnterSamePassword+0x12a>
    2e44:	88 ec       	ldi	r24, 0xC8	; 200
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	9a 8b       	std	Y+18, r25	; 0x12
    2e4a:	89 8b       	std	Y+17, r24	; 0x11
    2e4c:	89 89       	ldd	r24, Y+17	; 0x11
    2e4e:	9a 89       	ldd	r25, Y+18	; 0x12
    2e50:	01 97       	sbiw	r24, 0x01	; 1
    2e52:	f1 f7       	brne	.-4      	; 0x2e50 <ReEnterSamePassword+0x118>
    2e54:	9a 8b       	std	Y+18, r25	; 0x12
    2e56:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e58:	8b 89       	ldd	r24, Y+19	; 0x13
    2e5a:	9c 89       	ldd	r25, Y+20	; 0x14
    2e5c:	01 97       	sbiw	r24, 0x01	; 1
    2e5e:	9c 8b       	std	Y+20, r25	; 0x14
    2e60:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e62:	8b 89       	ldd	r24, Y+19	; 0x13
    2e64:	9c 89       	ldd	r25, Y+20	; 0x14
    2e66:	00 97       	sbiw	r24, 0x00	; 0
    2e68:	69 f7       	brne	.-38     	; 0x2e44 <ReEnterSamePassword+0x10c>
    2e6a:	14 c0       	rjmp	.+40     	; 0x2e94 <ReEnterSamePassword+0x15c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e6c:	6d 89       	ldd	r22, Y+21	; 0x15
    2e6e:	7e 89       	ldd	r23, Y+22	; 0x16
    2e70:	8f 89       	ldd	r24, Y+23	; 0x17
    2e72:	98 8d       	ldd	r25, Y+24	; 0x18
    2e74:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2e78:	dc 01       	movw	r26, r24
    2e7a:	cb 01       	movw	r24, r22
    2e7c:	9c 8b       	std	Y+20, r25	; 0x14
    2e7e:	8b 8b       	std	Y+19, r24	; 0x13
    2e80:	8b 89       	ldd	r24, Y+19	; 0x13
    2e82:	9c 89       	ldd	r25, Y+20	; 0x14
    2e84:	98 8b       	std	Y+16, r25	; 0x10
    2e86:	8f 87       	std	Y+15, r24	; 0x0f
    2e88:	8f 85       	ldd	r24, Y+15	; 0x0f
    2e8a:	98 89       	ldd	r25, Y+16	; 0x10
    2e8c:	01 97       	sbiw	r24, 0x01	; 1
    2e8e:	f1 f7       	brne	.-4      	; 0x2e8c <ReEnterSamePassword+0x154>
    2e90:	98 8b       	std	Y+16, r25	; 0x10
    2e92:	8f 87       	std	Y+15, r24	; 0x0f
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
	LCD_displayStringRowColumn(1, 0, "same pass:");
	LCD_moveCursor(1, 10);
	i = 0; /* Reset 'i' when starting a new password entry */

	while (i < PASSWORD_SIZE) {
    2e94:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2e96:	85 30       	cpi	r24, 0x05	; 5
    2e98:	08 f4       	brcc	.+2      	; 0x2e9c <ReEnterSamePassword+0x164>
    2e9a:	74 cf       	rjmp	.-280    	; 0x2d84 <ReEnterSamePassword+0x4c>
			LCD_displayCharacter('*'); /* Display an asterisk for each character entered */
			i++; /* Only increment when a valid key is pressed*/
		}
		_delay_ms(KEY_PRESSED_DELAY); /* Delay between key presses*/
	}
	while (KEYPAD_getPressedKey() != '=');
    2e9c:	0e 94 aa 10 	call	0x2154	; 0x2154 <KEYPAD_getPressedKey>
    2ea0:	8d 33       	cpi	r24, 0x3D	; 61
    2ea2:	e1 f7       	brne	.-8      	; 0x2e9c <ReEnterSamePassword+0x164>
    2ea4:	80 e0       	ldi	r24, 0x00	; 0
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	aa ef       	ldi	r26, 0xFA	; 250
    2eaa:	b3 e4       	ldi	r27, 0x43	; 67
    2eac:	8b 87       	std	Y+11, r24	; 0x0b
    2eae:	9c 87       	std	Y+12, r25	; 0x0c
    2eb0:	ad 87       	std	Y+13, r26	; 0x0d
    2eb2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2eb4:	6b 85       	ldd	r22, Y+11	; 0x0b
    2eb6:	7c 85       	ldd	r23, Y+12	; 0x0c
    2eb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2eba:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ebc:	20 e0       	ldi	r18, 0x00	; 0
    2ebe:	30 e0       	ldi	r19, 0x00	; 0
    2ec0:	4a ef       	ldi	r20, 0xFA	; 250
    2ec2:	54 e4       	ldi	r21, 0x44	; 68
    2ec4:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2ec8:	dc 01       	movw	r26, r24
    2eca:	cb 01       	movw	r24, r22
    2ecc:	8f 83       	std	Y+7, r24	; 0x07
    2ece:	98 87       	std	Y+8, r25	; 0x08
    2ed0:	a9 87       	std	Y+9, r26	; 0x09
    2ed2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2ed4:	6f 81       	ldd	r22, Y+7	; 0x07
    2ed6:	78 85       	ldd	r23, Y+8	; 0x08
    2ed8:	89 85       	ldd	r24, Y+9	; 0x09
    2eda:	9a 85       	ldd	r25, Y+10	; 0x0a
    2edc:	20 e0       	ldi	r18, 0x00	; 0
    2ede:	30 e0       	ldi	r19, 0x00	; 0
    2ee0:	40 e8       	ldi	r20, 0x80	; 128
    2ee2:	5f e3       	ldi	r21, 0x3F	; 63
    2ee4:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    2ee8:	88 23       	and	r24, r24
    2eea:	2c f4       	brge	.+10     	; 0x2ef6 <ReEnterSamePassword+0x1be>
		__ticks = 1;
    2eec:	81 e0       	ldi	r24, 0x01	; 1
    2eee:	90 e0       	ldi	r25, 0x00	; 0
    2ef0:	9e 83       	std	Y+6, r25	; 0x06
    2ef2:	8d 83       	std	Y+5, r24	; 0x05
    2ef4:	3f c0       	rjmp	.+126    	; 0x2f74 <ReEnterSamePassword+0x23c>
	else if (__tmp > 65535)
    2ef6:	6f 81       	ldd	r22, Y+7	; 0x07
    2ef8:	78 85       	ldd	r23, Y+8	; 0x08
    2efa:	89 85       	ldd	r24, Y+9	; 0x09
    2efc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2efe:	20 e0       	ldi	r18, 0x00	; 0
    2f00:	3f ef       	ldi	r19, 0xFF	; 255
    2f02:	4f e7       	ldi	r20, 0x7F	; 127
    2f04:	57 e4       	ldi	r21, 0x47	; 71
    2f06:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    2f0a:	18 16       	cp	r1, r24
    2f0c:	4c f5       	brge	.+82     	; 0x2f60 <ReEnterSamePassword+0x228>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2f10:	7c 85       	ldd	r23, Y+12	; 0x0c
    2f12:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f14:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f16:	20 e0       	ldi	r18, 0x00	; 0
    2f18:	30 e0       	ldi	r19, 0x00	; 0
    2f1a:	40 e2       	ldi	r20, 0x20	; 32
    2f1c:	51 e4       	ldi	r21, 0x41	; 65
    2f1e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    2f22:	dc 01       	movw	r26, r24
    2f24:	cb 01       	movw	r24, r22
    2f26:	bc 01       	movw	r22, r24
    2f28:	cd 01       	movw	r24, r26
    2f2a:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2f2e:	dc 01       	movw	r26, r24
    2f30:	cb 01       	movw	r24, r22
    2f32:	9e 83       	std	Y+6, r25	; 0x06
    2f34:	8d 83       	std	Y+5, r24	; 0x05
    2f36:	0f c0       	rjmp	.+30     	; 0x2f56 <ReEnterSamePassword+0x21e>
    2f38:	88 ec       	ldi	r24, 0xC8	; 200
    2f3a:	90 e0       	ldi	r25, 0x00	; 0
    2f3c:	9c 83       	std	Y+4, r25	; 0x04
    2f3e:	8b 83       	std	Y+3, r24	; 0x03
    2f40:	8b 81       	ldd	r24, Y+3	; 0x03
    2f42:	9c 81       	ldd	r25, Y+4	; 0x04
    2f44:	01 97       	sbiw	r24, 0x01	; 1
    2f46:	f1 f7       	brne	.-4      	; 0x2f44 <ReEnterSamePassword+0x20c>
    2f48:	9c 83       	std	Y+4, r25	; 0x04
    2f4a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    2f50:	01 97       	sbiw	r24, 0x01	; 1
    2f52:	9e 83       	std	Y+6, r25	; 0x06
    2f54:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f56:	8d 81       	ldd	r24, Y+5	; 0x05
    2f58:	9e 81       	ldd	r25, Y+6	; 0x06
    2f5a:	00 97       	sbiw	r24, 0x00	; 0
    2f5c:	69 f7       	brne	.-38     	; 0x2f38 <ReEnterSamePassword+0x200>
    2f5e:	14 c0       	rjmp	.+40     	; 0x2f88 <ReEnterSamePassword+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2f60:	6f 81       	ldd	r22, Y+7	; 0x07
    2f62:	78 85       	ldd	r23, Y+8	; 0x08
    2f64:	89 85       	ldd	r24, Y+9	; 0x09
    2f66:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f68:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    2f6c:	dc 01       	movw	r26, r24
    2f6e:	cb 01       	movw	r24, r22
    2f70:	9e 83       	std	Y+6, r25	; 0x06
    2f72:	8d 83       	std	Y+5, r24	; 0x05
    2f74:	8d 81       	ldd	r24, Y+5	; 0x05
    2f76:	9e 81       	ldd	r25, Y+6	; 0x06
    2f78:	9a 83       	std	Y+2, r25	; 0x02
    2f7a:	89 83       	std	Y+1, r24	; 0x01
    2f7c:	89 81       	ldd	r24, Y+1	; 0x01
    2f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f80:	01 97       	sbiw	r24, 0x01	; 1
    2f82:	f1 f7       	brne	.-4      	; 0x2f80 <ReEnterSamePassword+0x248>
    2f84:	9a 83       	std	Y+2, r25	; 0x02
    2f86:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(KEY_PRESSED_DELAY);
}
    2f88:	a0 96       	adiw	r28, 0x20	; 32
    2f8a:	0f b6       	in	r0, 0x3f	; 63
    2f8c:	f8 94       	cli
    2f8e:	de bf       	out	0x3e, r29	; 62
    2f90:	0f be       	out	0x3f, r0	; 63
    2f92:	cd bf       	out	0x3d, r28	; 61
    2f94:	cf 91       	pop	r28
    2f96:	df 91       	pop	r29
    2f98:	08 95       	ret

00002f9a <SendTwoPasswords>:
 *******************************************************************************/

/*
 * SendTwoPasswords function sends two passwords via UART.
 */
void SendTwoPasswords(uint8 *password1, uint8 *password2) {
    2f9a:	df 93       	push	r29
    2f9c:	cf 93       	push	r28
    2f9e:	cd b7       	in	r28, 0x3d	; 61
    2fa0:	de b7       	in	r29, 0x3e	; 62
    2fa2:	e0 97       	sbiw	r28, 0x30	; 48
    2fa4:	0f b6       	in	r0, 0x3f	; 63
    2fa6:	f8 94       	cli
    2fa8:	de bf       	out	0x3e, r29	; 62
    2faa:	0f be       	out	0x3f, r0	; 63
    2fac:	cd bf       	out	0x3d, r28	; 61
    2fae:	9e a7       	std	Y+46, r25	; 0x2e
    2fb0:	8d a7       	std	Y+45, r24	; 0x2d
    2fb2:	78 ab       	std	Y+48, r23	; 0x30
    2fb4:	6f a7       	std	Y+47, r22	; 0x2f
	LCD_clearScreen();
    2fb6:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Send...");
    2fba:	2c ea       	ldi	r18, 0xAC	; 172
    2fbc:	30 e0       	ldi	r19, 0x00	; 0
    2fbe:	80 e0       	ldi	r24, 0x00	; 0
    2fc0:	60 e0       	ldi	r22, 0x00	; 0
    2fc2:	a9 01       	movw	r20, r18
    2fc4:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	60 e0       	ldi	r22, 0x00	; 0
    2fcc:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>

	/* Wait until MC2 is ready to receive the string */
	while (UART_recieveByte() != UART_START) {
    2fd0:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    2fd4:	81 30       	cpi	r24, 0x01	; 1
    2fd6:	e1 f7       	brne	.-8      	; 0x2fd0 <SendTwoPasswords+0x36>
	}

	/* Send password1 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    2fd8:	1c a6       	std	Y+44, r1	; 0x2c
    2fda:	80 c0       	rjmp	.+256    	; 0x30dc <SendTwoPasswords+0x142>
		UART_sendByte(password1[i]);
    2fdc:	8c a5       	ldd	r24, Y+44	; 0x2c
    2fde:	28 2f       	mov	r18, r24
    2fe0:	30 e0       	ldi	r19, 0x00	; 0
    2fe2:	8d a5       	ldd	r24, Y+45	; 0x2d
    2fe4:	9e a5       	ldd	r25, Y+46	; 0x2e
    2fe6:	fc 01       	movw	r30, r24
    2fe8:	e2 0f       	add	r30, r18
    2fea:	f3 1f       	adc	r31, r19
    2fec:	80 81       	ld	r24, Z
    2fee:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
    2ff2:	80 e0       	ldi	r24, 0x00	; 0
    2ff4:	90 e0       	ldi	r25, 0x00	; 0
    2ff6:	a0 e2       	ldi	r26, 0x20	; 32
    2ff8:	b1 e4       	ldi	r27, 0x41	; 65
    2ffa:	8f a3       	std	Y+39, r24	; 0x27
    2ffc:	98 a7       	std	Y+40, r25	; 0x28
    2ffe:	a9 a7       	std	Y+41, r26	; 0x29
    3000:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3002:	6f a1       	ldd	r22, Y+39	; 0x27
    3004:	78 a5       	ldd	r23, Y+40	; 0x28
    3006:	89 a5       	ldd	r24, Y+41	; 0x29
    3008:	9a a5       	ldd	r25, Y+42	; 0x2a
    300a:	20 e0       	ldi	r18, 0x00	; 0
    300c:	30 e0       	ldi	r19, 0x00	; 0
    300e:	4a ef       	ldi	r20, 0xFA	; 250
    3010:	54 e4       	ldi	r21, 0x44	; 68
    3012:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3016:	dc 01       	movw	r26, r24
    3018:	cb 01       	movw	r24, r22
    301a:	8b a3       	std	Y+35, r24	; 0x23
    301c:	9c a3       	std	Y+36, r25	; 0x24
    301e:	ad a3       	std	Y+37, r26	; 0x25
    3020:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3022:	6b a1       	ldd	r22, Y+35	; 0x23
    3024:	7c a1       	ldd	r23, Y+36	; 0x24
    3026:	8d a1       	ldd	r24, Y+37	; 0x25
    3028:	9e a1       	ldd	r25, Y+38	; 0x26
    302a:	20 e0       	ldi	r18, 0x00	; 0
    302c:	30 e0       	ldi	r19, 0x00	; 0
    302e:	40 e8       	ldi	r20, 0x80	; 128
    3030:	5f e3       	ldi	r21, 0x3F	; 63
    3032:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    3036:	88 23       	and	r24, r24
    3038:	2c f4       	brge	.+10     	; 0x3044 <SendTwoPasswords+0xaa>
		__ticks = 1;
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	90 e0       	ldi	r25, 0x00	; 0
    303e:	9a a3       	std	Y+34, r25	; 0x22
    3040:	89 a3       	std	Y+33, r24	; 0x21
    3042:	3f c0       	rjmp	.+126    	; 0x30c2 <SendTwoPasswords+0x128>
	else if (__tmp > 65535)
    3044:	6b a1       	ldd	r22, Y+35	; 0x23
    3046:	7c a1       	ldd	r23, Y+36	; 0x24
    3048:	8d a1       	ldd	r24, Y+37	; 0x25
    304a:	9e a1       	ldd	r25, Y+38	; 0x26
    304c:	20 e0       	ldi	r18, 0x00	; 0
    304e:	3f ef       	ldi	r19, 0xFF	; 255
    3050:	4f e7       	ldi	r20, 0x7F	; 127
    3052:	57 e4       	ldi	r21, 0x47	; 71
    3054:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    3058:	18 16       	cp	r1, r24
    305a:	4c f5       	brge	.+82     	; 0x30ae <SendTwoPasswords+0x114>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    305c:	6f a1       	ldd	r22, Y+39	; 0x27
    305e:	78 a5       	ldd	r23, Y+40	; 0x28
    3060:	89 a5       	ldd	r24, Y+41	; 0x29
    3062:	9a a5       	ldd	r25, Y+42	; 0x2a
    3064:	20 e0       	ldi	r18, 0x00	; 0
    3066:	30 e0       	ldi	r19, 0x00	; 0
    3068:	40 e2       	ldi	r20, 0x20	; 32
    306a:	51 e4       	ldi	r21, 0x41	; 65
    306c:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3070:	dc 01       	movw	r26, r24
    3072:	cb 01       	movw	r24, r22
    3074:	bc 01       	movw	r22, r24
    3076:	cd 01       	movw	r24, r26
    3078:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    307c:	dc 01       	movw	r26, r24
    307e:	cb 01       	movw	r24, r22
    3080:	9a a3       	std	Y+34, r25	; 0x22
    3082:	89 a3       	std	Y+33, r24	; 0x21
    3084:	0f c0       	rjmp	.+30     	; 0x30a4 <SendTwoPasswords+0x10a>
    3086:	88 ec       	ldi	r24, 0xC8	; 200
    3088:	90 e0       	ldi	r25, 0x00	; 0
    308a:	98 a3       	std	Y+32, r25	; 0x20
    308c:	8f 8f       	std	Y+31, r24	; 0x1f
    308e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3090:	98 a1       	ldd	r25, Y+32	; 0x20
    3092:	01 97       	sbiw	r24, 0x01	; 1
    3094:	f1 f7       	brne	.-4      	; 0x3092 <SendTwoPasswords+0xf8>
    3096:	98 a3       	std	Y+32, r25	; 0x20
    3098:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    309a:	89 a1       	ldd	r24, Y+33	; 0x21
    309c:	9a a1       	ldd	r25, Y+34	; 0x22
    309e:	01 97       	sbiw	r24, 0x01	; 1
    30a0:	9a a3       	std	Y+34, r25	; 0x22
    30a2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    30a4:	89 a1       	ldd	r24, Y+33	; 0x21
    30a6:	9a a1       	ldd	r25, Y+34	; 0x22
    30a8:	00 97       	sbiw	r24, 0x00	; 0
    30aa:	69 f7       	brne	.-38     	; 0x3086 <SendTwoPasswords+0xec>
    30ac:	14 c0       	rjmp	.+40     	; 0x30d6 <SendTwoPasswords+0x13c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    30ae:	6b a1       	ldd	r22, Y+35	; 0x23
    30b0:	7c a1       	ldd	r23, Y+36	; 0x24
    30b2:	8d a1       	ldd	r24, Y+37	; 0x25
    30b4:	9e a1       	ldd	r25, Y+38	; 0x26
    30b6:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    30ba:	dc 01       	movw	r26, r24
    30bc:	cb 01       	movw	r24, r22
    30be:	9a a3       	std	Y+34, r25	; 0x22
    30c0:	89 a3       	std	Y+33, r24	; 0x21
    30c2:	89 a1       	ldd	r24, Y+33	; 0x21
    30c4:	9a a1       	ldd	r25, Y+34	; 0x22
    30c6:	9e 8f       	std	Y+30, r25	; 0x1e
    30c8:	8d 8f       	std	Y+29, r24	; 0x1d
    30ca:	8d 8d       	ldd	r24, Y+29	; 0x1d
    30cc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    30ce:	01 97       	sbiw	r24, 0x01	; 1
    30d0:	f1 f7       	brne	.-4      	; 0x30ce <SendTwoPasswords+0x134>
    30d2:	9e 8f       	std	Y+30, r25	; 0x1e
    30d4:	8d 8f       	std	Y+29, r24	; 0x1d
	/* Wait until MC2 is ready to receive the string */
	while (UART_recieveByte() != UART_START) {
	}

	/* Send password1 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    30d6:	8c a5       	ldd	r24, Y+44	; 0x2c
    30d8:	8f 5f       	subi	r24, 0xFF	; 255
    30da:	8c a7       	std	Y+44, r24	; 0x2c
    30dc:	8c a5       	ldd	r24, Y+44	; 0x2c
    30de:	85 30       	cpi	r24, 0x05	; 5
    30e0:	08 f4       	brcc	.+2      	; 0x30e4 <SendTwoPasswords+0x14a>
    30e2:	7c cf       	rjmp	.-264    	; 0x2fdc <SendTwoPasswords+0x42>
    30e4:	80 e0       	ldi	r24, 0x00	; 0
    30e6:	90 e0       	ldi	r25, 0x00	; 0
    30e8:	aa ef       	ldi	r26, 0xFA	; 250
    30ea:	b3 e4       	ldi	r27, 0x43	; 67
    30ec:	89 8f       	std	Y+25, r24	; 0x19
    30ee:	9a 8f       	std	Y+26, r25	; 0x1a
    30f0:	ab 8f       	std	Y+27, r26	; 0x1b
    30f2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30f4:	69 8d       	ldd	r22, Y+25	; 0x19
    30f6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    30f8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    30fa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    30fc:	20 e0       	ldi	r18, 0x00	; 0
    30fe:	30 e0       	ldi	r19, 0x00	; 0
    3100:	4a ef       	ldi	r20, 0xFA	; 250
    3102:	54 e4       	ldi	r21, 0x44	; 68
    3104:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3108:	dc 01       	movw	r26, r24
    310a:	cb 01       	movw	r24, r22
    310c:	8d 8b       	std	Y+21, r24	; 0x15
    310e:	9e 8b       	std	Y+22, r25	; 0x16
    3110:	af 8b       	std	Y+23, r26	; 0x17
    3112:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3114:	6d 89       	ldd	r22, Y+21	; 0x15
    3116:	7e 89       	ldd	r23, Y+22	; 0x16
    3118:	8f 89       	ldd	r24, Y+23	; 0x17
    311a:	98 8d       	ldd	r25, Y+24	; 0x18
    311c:	20 e0       	ldi	r18, 0x00	; 0
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	40 e8       	ldi	r20, 0x80	; 128
    3122:	5f e3       	ldi	r21, 0x3F	; 63
    3124:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    3128:	88 23       	and	r24, r24
    312a:	2c f4       	brge	.+10     	; 0x3136 <SendTwoPasswords+0x19c>
		__ticks = 1;
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	9c 8b       	std	Y+20, r25	; 0x14
    3132:	8b 8b       	std	Y+19, r24	; 0x13
    3134:	3f c0       	rjmp	.+126    	; 0x31b4 <SendTwoPasswords+0x21a>
	else if (__tmp > 65535)
    3136:	6d 89       	ldd	r22, Y+21	; 0x15
    3138:	7e 89       	ldd	r23, Y+22	; 0x16
    313a:	8f 89       	ldd	r24, Y+23	; 0x17
    313c:	98 8d       	ldd	r25, Y+24	; 0x18
    313e:	20 e0       	ldi	r18, 0x00	; 0
    3140:	3f ef       	ldi	r19, 0xFF	; 255
    3142:	4f e7       	ldi	r20, 0x7F	; 127
    3144:	57 e4       	ldi	r21, 0x47	; 71
    3146:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    314a:	18 16       	cp	r1, r24
    314c:	4c f5       	brge	.+82     	; 0x31a0 <SendTwoPasswords+0x206>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    314e:	69 8d       	ldd	r22, Y+25	; 0x19
    3150:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3152:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3154:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3156:	20 e0       	ldi	r18, 0x00	; 0
    3158:	30 e0       	ldi	r19, 0x00	; 0
    315a:	40 e2       	ldi	r20, 0x20	; 32
    315c:	51 e4       	ldi	r21, 0x41	; 65
    315e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3162:	dc 01       	movw	r26, r24
    3164:	cb 01       	movw	r24, r22
    3166:	bc 01       	movw	r22, r24
    3168:	cd 01       	movw	r24, r26
    316a:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    316e:	dc 01       	movw	r26, r24
    3170:	cb 01       	movw	r24, r22
    3172:	9c 8b       	std	Y+20, r25	; 0x14
    3174:	8b 8b       	std	Y+19, r24	; 0x13
    3176:	0f c0       	rjmp	.+30     	; 0x3196 <SendTwoPasswords+0x1fc>
    3178:	88 ec       	ldi	r24, 0xC8	; 200
    317a:	90 e0       	ldi	r25, 0x00	; 0
    317c:	9a 8b       	std	Y+18, r25	; 0x12
    317e:	89 8b       	std	Y+17, r24	; 0x11
    3180:	89 89       	ldd	r24, Y+17	; 0x11
    3182:	9a 89       	ldd	r25, Y+18	; 0x12
    3184:	01 97       	sbiw	r24, 0x01	; 1
    3186:	f1 f7       	brne	.-4      	; 0x3184 <SendTwoPasswords+0x1ea>
    3188:	9a 8b       	std	Y+18, r25	; 0x12
    318a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    318c:	8b 89       	ldd	r24, Y+19	; 0x13
    318e:	9c 89       	ldd	r25, Y+20	; 0x14
    3190:	01 97       	sbiw	r24, 0x01	; 1
    3192:	9c 8b       	std	Y+20, r25	; 0x14
    3194:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3196:	8b 89       	ldd	r24, Y+19	; 0x13
    3198:	9c 89       	ldd	r25, Y+20	; 0x14
    319a:	00 97       	sbiw	r24, 0x00	; 0
    319c:	69 f7       	brne	.-38     	; 0x3178 <SendTwoPasswords+0x1de>
    319e:	14 c0       	rjmp	.+40     	; 0x31c8 <SendTwoPasswords+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    31a0:	6d 89       	ldd	r22, Y+21	; 0x15
    31a2:	7e 89       	ldd	r23, Y+22	; 0x16
    31a4:	8f 89       	ldd	r24, Y+23	; 0x17
    31a6:	98 8d       	ldd	r25, Y+24	; 0x18
    31a8:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    31ac:	dc 01       	movw	r26, r24
    31ae:	cb 01       	movw	r24, r22
    31b0:	9c 8b       	std	Y+20, r25	; 0x14
    31b2:	8b 8b       	std	Y+19, r24	; 0x13
    31b4:	8b 89       	ldd	r24, Y+19	; 0x13
    31b6:	9c 89       	ldd	r25, Y+20	; 0x14
    31b8:	98 8b       	std	Y+16, r25	; 0x10
    31ba:	8f 87       	std	Y+15, r24	; 0x0f
    31bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    31be:	98 89       	ldd	r25, Y+16	; 0x10
    31c0:	01 97       	sbiw	r24, 0x01	; 1
    31c2:	f1 f7       	brne	.-4      	; 0x31c0 <SendTwoPasswords+0x226>
    31c4:	98 8b       	std	Y+16, r25	; 0x10
    31c6:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(SMALL_DELAY);
	}
	_delay_ms(KEY_PRESSED_DELAY); /* Add a short delay between passwords */

	/* Send password2 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    31c8:	1b a6       	std	Y+43, r1	; 0x2b
    31ca:	80 c0       	rjmp	.+256    	; 0x32cc <SendTwoPasswords+0x332>
		UART_sendByte(password2[i]);
    31cc:	8b a5       	ldd	r24, Y+43	; 0x2b
    31ce:	28 2f       	mov	r18, r24
    31d0:	30 e0       	ldi	r19, 0x00	; 0
    31d2:	8f a5       	ldd	r24, Y+47	; 0x2f
    31d4:	98 a9       	ldd	r25, Y+48	; 0x30
    31d6:	fc 01       	movw	r30, r24
    31d8:	e2 0f       	add	r30, r18
    31da:	f3 1f       	adc	r31, r19
    31dc:	80 81       	ld	r24, Z
    31de:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
    31e2:	80 e0       	ldi	r24, 0x00	; 0
    31e4:	90 e0       	ldi	r25, 0x00	; 0
    31e6:	a0 e2       	ldi	r26, 0x20	; 32
    31e8:	b1 e4       	ldi	r27, 0x41	; 65
    31ea:	8b 87       	std	Y+11, r24	; 0x0b
    31ec:	9c 87       	std	Y+12, r25	; 0x0c
    31ee:	ad 87       	std	Y+13, r26	; 0x0d
    31f0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    31f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    31f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    31f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    31fa:	20 e0       	ldi	r18, 0x00	; 0
    31fc:	30 e0       	ldi	r19, 0x00	; 0
    31fe:	4a ef       	ldi	r20, 0xFA	; 250
    3200:	54 e4       	ldi	r21, 0x44	; 68
    3202:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3206:	dc 01       	movw	r26, r24
    3208:	cb 01       	movw	r24, r22
    320a:	8f 83       	std	Y+7, r24	; 0x07
    320c:	98 87       	std	Y+8, r25	; 0x08
    320e:	a9 87       	std	Y+9, r26	; 0x09
    3210:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3212:	6f 81       	ldd	r22, Y+7	; 0x07
    3214:	78 85       	ldd	r23, Y+8	; 0x08
    3216:	89 85       	ldd	r24, Y+9	; 0x09
    3218:	9a 85       	ldd	r25, Y+10	; 0x0a
    321a:	20 e0       	ldi	r18, 0x00	; 0
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	40 e8       	ldi	r20, 0x80	; 128
    3220:	5f e3       	ldi	r21, 0x3F	; 63
    3222:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    3226:	88 23       	and	r24, r24
    3228:	2c f4       	brge	.+10     	; 0x3234 <SendTwoPasswords+0x29a>
		__ticks = 1;
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	90 e0       	ldi	r25, 0x00	; 0
    322e:	9e 83       	std	Y+6, r25	; 0x06
    3230:	8d 83       	std	Y+5, r24	; 0x05
    3232:	3f c0       	rjmp	.+126    	; 0x32b2 <SendTwoPasswords+0x318>
	else if (__tmp > 65535)
    3234:	6f 81       	ldd	r22, Y+7	; 0x07
    3236:	78 85       	ldd	r23, Y+8	; 0x08
    3238:	89 85       	ldd	r24, Y+9	; 0x09
    323a:	9a 85       	ldd	r25, Y+10	; 0x0a
    323c:	20 e0       	ldi	r18, 0x00	; 0
    323e:	3f ef       	ldi	r19, 0xFF	; 255
    3240:	4f e7       	ldi	r20, 0x7F	; 127
    3242:	57 e4       	ldi	r21, 0x47	; 71
    3244:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    3248:	18 16       	cp	r1, r24
    324a:	4c f5       	brge	.+82     	; 0x329e <SendTwoPasswords+0x304>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    324c:	6b 85       	ldd	r22, Y+11	; 0x0b
    324e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3250:	8d 85       	ldd	r24, Y+13	; 0x0d
    3252:	9e 85       	ldd	r25, Y+14	; 0x0e
    3254:	20 e0       	ldi	r18, 0x00	; 0
    3256:	30 e0       	ldi	r19, 0x00	; 0
    3258:	40 e2       	ldi	r20, 0x20	; 32
    325a:	51 e4       	ldi	r21, 0x41	; 65
    325c:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3260:	dc 01       	movw	r26, r24
    3262:	cb 01       	movw	r24, r22
    3264:	bc 01       	movw	r22, r24
    3266:	cd 01       	movw	r24, r26
    3268:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    326c:	dc 01       	movw	r26, r24
    326e:	cb 01       	movw	r24, r22
    3270:	9e 83       	std	Y+6, r25	; 0x06
    3272:	8d 83       	std	Y+5, r24	; 0x05
    3274:	0f c0       	rjmp	.+30     	; 0x3294 <SendTwoPasswords+0x2fa>
    3276:	88 ec       	ldi	r24, 0xC8	; 200
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	9c 83       	std	Y+4, r25	; 0x04
    327c:	8b 83       	std	Y+3, r24	; 0x03
    327e:	8b 81       	ldd	r24, Y+3	; 0x03
    3280:	9c 81       	ldd	r25, Y+4	; 0x04
    3282:	01 97       	sbiw	r24, 0x01	; 1
    3284:	f1 f7       	brne	.-4      	; 0x3282 <SendTwoPasswords+0x2e8>
    3286:	9c 83       	std	Y+4, r25	; 0x04
    3288:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    328a:	8d 81       	ldd	r24, Y+5	; 0x05
    328c:	9e 81       	ldd	r25, Y+6	; 0x06
    328e:	01 97       	sbiw	r24, 0x01	; 1
    3290:	9e 83       	std	Y+6, r25	; 0x06
    3292:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3294:	8d 81       	ldd	r24, Y+5	; 0x05
    3296:	9e 81       	ldd	r25, Y+6	; 0x06
    3298:	00 97       	sbiw	r24, 0x00	; 0
    329a:	69 f7       	brne	.-38     	; 0x3276 <SendTwoPasswords+0x2dc>
    329c:	14 c0       	rjmp	.+40     	; 0x32c6 <SendTwoPasswords+0x32c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    329e:	6f 81       	ldd	r22, Y+7	; 0x07
    32a0:	78 85       	ldd	r23, Y+8	; 0x08
    32a2:	89 85       	ldd	r24, Y+9	; 0x09
    32a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    32a6:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    32aa:	dc 01       	movw	r26, r24
    32ac:	cb 01       	movw	r24, r22
    32ae:	9e 83       	std	Y+6, r25	; 0x06
    32b0:	8d 83       	std	Y+5, r24	; 0x05
    32b2:	8d 81       	ldd	r24, Y+5	; 0x05
    32b4:	9e 81       	ldd	r25, Y+6	; 0x06
    32b6:	9a 83       	std	Y+2, r25	; 0x02
    32b8:	89 83       	std	Y+1, r24	; 0x01
    32ba:	89 81       	ldd	r24, Y+1	; 0x01
    32bc:	9a 81       	ldd	r25, Y+2	; 0x02
    32be:	01 97       	sbiw	r24, 0x01	; 1
    32c0:	f1 f7       	brne	.-4      	; 0x32be <SendTwoPasswords+0x324>
    32c2:	9a 83       	std	Y+2, r25	; 0x02
    32c4:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(SMALL_DELAY);
	}
	_delay_ms(KEY_PRESSED_DELAY); /* Add a short delay between passwords */

	/* Send password2 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    32c6:	8b a5       	ldd	r24, Y+43	; 0x2b
    32c8:	8f 5f       	subi	r24, 0xFF	; 255
    32ca:	8b a7       	std	Y+43, r24	; 0x2b
    32cc:	8b a5       	ldd	r24, Y+43	; 0x2b
    32ce:	85 30       	cpi	r24, 0x05	; 5
    32d0:	08 f4       	brcc	.+2      	; 0x32d4 <SendTwoPasswords+0x33a>
    32d2:	7c cf       	rjmp	.-264    	; 0x31cc <SendTwoPasswords+0x232>
		UART_sendByte(password2[i]);
		_delay_ms(SMALL_DELAY);
	}

}
    32d4:	e0 96       	adiw	r28, 0x30	; 48
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	de bf       	out	0x3e, r29	; 62
    32dc:	0f be       	out	0x3f, r0	; 63
    32de:	cd bf       	out	0x3d, r28	; 61
    32e0:	cf 91       	pop	r28
    32e2:	df 91       	pop	r29
    32e4:	08 95       	ret

000032e6 <SendPassword>:

/*
 * Send saved passwords function sends two passwords via UART to check.
 */
void SendPassword(uint8 *password1) {
    32e6:	df 93       	push	r29
    32e8:	cf 93       	push	r28
    32ea:	cd b7       	in	r28, 0x3d	; 61
    32ec:	de b7       	in	r29, 0x3e	; 62
    32ee:	61 97       	sbiw	r28, 0x11	; 17
    32f0:	0f b6       	in	r0, 0x3f	; 63
    32f2:	f8 94       	cli
    32f4:	de bf       	out	0x3e, r29	; 62
    32f6:	0f be       	out	0x3f, r0	; 63
    32f8:	cd bf       	out	0x3d, r28	; 61
    32fa:	99 8b       	std	Y+17, r25	; 0x11
    32fc:	88 8b       	std	Y+16, r24	; 0x10
	LCD_clearScreen();
    32fe:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Send...");
    3302:	2c ea       	ldi	r18, 0xAC	; 172
    3304:	30 e0       	ldi	r19, 0x00	; 0
    3306:	80 e0       	ldi	r24, 0x00	; 0
    3308:	60 e0       	ldi	r22, 0x00	; 0
    330a:	a9 01       	movw	r20, r18
    330c:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	60 e0       	ldi	r22, 0x00	; 0
    3314:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <LCD_moveCursor>
	/* Wait until MC2 is ready to receive the string */
	while (UART_recieveByte() != OPEN_DOOR_PASSWORD) {}
    3318:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    331c:	86 30       	cpi	r24, 0x06	; 6
    331e:	e1 f7       	brne	.-8      	; 0x3318 <SendPassword+0x32>

	/* Send password1 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    3320:	1f 86       	std	Y+15, r1	; 0x0f
    3322:	80 c0       	rjmp	.+256    	; 0x3424 <SendPassword+0x13e>
		UART_sendByte(password1[i]);
    3324:	8f 85       	ldd	r24, Y+15	; 0x0f
    3326:	28 2f       	mov	r18, r24
    3328:	30 e0       	ldi	r19, 0x00	; 0
    332a:	88 89       	ldd	r24, Y+16	; 0x10
    332c:	99 89       	ldd	r25, Y+17	; 0x11
    332e:	fc 01       	movw	r30, r24
    3330:	e2 0f       	add	r30, r18
    3332:	f3 1f       	adc	r31, r19
    3334:	80 81       	ld	r24, Z
    3336:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
    333a:	80 e0       	ldi	r24, 0x00	; 0
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	a0 e2       	ldi	r26, 0x20	; 32
    3340:	b1 e4       	ldi	r27, 0x41	; 65
    3342:	8b 87       	std	Y+11, r24	; 0x0b
    3344:	9c 87       	std	Y+12, r25	; 0x0c
    3346:	ad 87       	std	Y+13, r26	; 0x0d
    3348:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    334a:	6b 85       	ldd	r22, Y+11	; 0x0b
    334c:	7c 85       	ldd	r23, Y+12	; 0x0c
    334e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3350:	9e 85       	ldd	r25, Y+14	; 0x0e
    3352:	20 e0       	ldi	r18, 0x00	; 0
    3354:	30 e0       	ldi	r19, 0x00	; 0
    3356:	4a ef       	ldi	r20, 0xFA	; 250
    3358:	54 e4       	ldi	r21, 0x44	; 68
    335a:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    335e:	dc 01       	movw	r26, r24
    3360:	cb 01       	movw	r24, r22
    3362:	8f 83       	std	Y+7, r24	; 0x07
    3364:	98 87       	std	Y+8, r25	; 0x08
    3366:	a9 87       	std	Y+9, r26	; 0x09
    3368:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    336a:	6f 81       	ldd	r22, Y+7	; 0x07
    336c:	78 85       	ldd	r23, Y+8	; 0x08
    336e:	89 85       	ldd	r24, Y+9	; 0x09
    3370:	9a 85       	ldd	r25, Y+10	; 0x0a
    3372:	20 e0       	ldi	r18, 0x00	; 0
    3374:	30 e0       	ldi	r19, 0x00	; 0
    3376:	40 e8       	ldi	r20, 0x80	; 128
    3378:	5f e3       	ldi	r21, 0x3F	; 63
    337a:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    337e:	88 23       	and	r24, r24
    3380:	2c f4       	brge	.+10     	; 0x338c <SendPassword+0xa6>
		__ticks = 1;
    3382:	81 e0       	ldi	r24, 0x01	; 1
    3384:	90 e0       	ldi	r25, 0x00	; 0
    3386:	9e 83       	std	Y+6, r25	; 0x06
    3388:	8d 83       	std	Y+5, r24	; 0x05
    338a:	3f c0       	rjmp	.+126    	; 0x340a <SendPassword+0x124>
	else if (__tmp > 65535)
    338c:	6f 81       	ldd	r22, Y+7	; 0x07
    338e:	78 85       	ldd	r23, Y+8	; 0x08
    3390:	89 85       	ldd	r24, Y+9	; 0x09
    3392:	9a 85       	ldd	r25, Y+10	; 0x0a
    3394:	20 e0       	ldi	r18, 0x00	; 0
    3396:	3f ef       	ldi	r19, 0xFF	; 255
    3398:	4f e7       	ldi	r20, 0x7F	; 127
    339a:	57 e4       	ldi	r21, 0x47	; 71
    339c:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    33a0:	18 16       	cp	r1, r24
    33a2:	4c f5       	brge	.+82     	; 0x33f6 <SendPassword+0x110>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33a4:	6b 85       	ldd	r22, Y+11	; 0x0b
    33a6:	7c 85       	ldd	r23, Y+12	; 0x0c
    33a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    33aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    33ac:	20 e0       	ldi	r18, 0x00	; 0
    33ae:	30 e0       	ldi	r19, 0x00	; 0
    33b0:	40 e2       	ldi	r20, 0x20	; 32
    33b2:	51 e4       	ldi	r21, 0x41	; 65
    33b4:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    33b8:	dc 01       	movw	r26, r24
    33ba:	cb 01       	movw	r24, r22
    33bc:	bc 01       	movw	r22, r24
    33be:	cd 01       	movw	r24, r26
    33c0:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    33c4:	dc 01       	movw	r26, r24
    33c6:	cb 01       	movw	r24, r22
    33c8:	9e 83       	std	Y+6, r25	; 0x06
    33ca:	8d 83       	std	Y+5, r24	; 0x05
    33cc:	0f c0       	rjmp	.+30     	; 0x33ec <SendPassword+0x106>
    33ce:	88 ec       	ldi	r24, 0xC8	; 200
    33d0:	90 e0       	ldi	r25, 0x00	; 0
    33d2:	9c 83       	std	Y+4, r25	; 0x04
    33d4:	8b 83       	std	Y+3, r24	; 0x03
    33d6:	8b 81       	ldd	r24, Y+3	; 0x03
    33d8:	9c 81       	ldd	r25, Y+4	; 0x04
    33da:	01 97       	sbiw	r24, 0x01	; 1
    33dc:	f1 f7       	brne	.-4      	; 0x33da <SendPassword+0xf4>
    33de:	9c 83       	std	Y+4, r25	; 0x04
    33e0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    33e2:	8d 81       	ldd	r24, Y+5	; 0x05
    33e4:	9e 81       	ldd	r25, Y+6	; 0x06
    33e6:	01 97       	sbiw	r24, 0x01	; 1
    33e8:	9e 83       	std	Y+6, r25	; 0x06
    33ea:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    33ec:	8d 81       	ldd	r24, Y+5	; 0x05
    33ee:	9e 81       	ldd	r25, Y+6	; 0x06
    33f0:	00 97       	sbiw	r24, 0x00	; 0
    33f2:	69 f7       	brne	.-38     	; 0x33ce <SendPassword+0xe8>
    33f4:	14 c0       	rjmp	.+40     	; 0x341e <SendPassword+0x138>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    33f6:	6f 81       	ldd	r22, Y+7	; 0x07
    33f8:	78 85       	ldd	r23, Y+8	; 0x08
    33fa:	89 85       	ldd	r24, Y+9	; 0x09
    33fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    33fe:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    3402:	dc 01       	movw	r26, r24
    3404:	cb 01       	movw	r24, r22
    3406:	9e 83       	std	Y+6, r25	; 0x06
    3408:	8d 83       	std	Y+5, r24	; 0x05
    340a:	8d 81       	ldd	r24, Y+5	; 0x05
    340c:	9e 81       	ldd	r25, Y+6	; 0x06
    340e:	9a 83       	std	Y+2, r25	; 0x02
    3410:	89 83       	std	Y+1, r24	; 0x01
    3412:	89 81       	ldd	r24, Y+1	; 0x01
    3414:	9a 81       	ldd	r25, Y+2	; 0x02
    3416:	01 97       	sbiw	r24, 0x01	; 1
    3418:	f1 f7       	brne	.-4      	; 0x3416 <SendPassword+0x130>
    341a:	9a 83       	std	Y+2, r25	; 0x02
    341c:	89 83       	std	Y+1, r24	; 0x01
	LCD_moveCursor(1, 0); /* Move the cursor to the second row */
	/* Wait until MC2 is ready to receive the string */
	while (UART_recieveByte() != OPEN_DOOR_PASSWORD) {}

	/* Send password1 via UART */
	for (uint8 i = 0; i < PASSWORD_SIZE; i++) {
    341e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3420:	8f 5f       	subi	r24, 0xFF	; 255
    3422:	8f 87       	std	Y+15, r24	; 0x0f
    3424:	8f 85       	ldd	r24, Y+15	; 0x0f
    3426:	85 30       	cpi	r24, 0x05	; 5
    3428:	08 f4       	brcc	.+2      	; 0x342c <SendPassword+0x146>
    342a:	7c cf       	rjmp	.-264    	; 0x3324 <SendPassword+0x3e>
		UART_sendByte(password1[i]);
		_delay_ms(SMALL_DELAY);
	}
}
    342c:	61 96       	adiw	r28, 0x11	; 17
    342e:	0f b6       	in	r0, 0x3f	; 63
    3430:	f8 94       	cli
    3432:	de bf       	out	0x3e, r29	; 62
    3434:	0f be       	out	0x3f, r0	; 63
    3436:	cd bf       	out	0x3d, r28	; 61
    3438:	cf 91       	pop	r28
    343a:	df 91       	pop	r29
    343c:	08 95       	ret

0000343e <CorrectReceivedState>:
 *******************************************************************************/

/*
 * The sending message on screen for updating state of motor
 */
void CorrectReceivedState(void) {
    343e:	df 93       	push	r29
    3440:	cf 93       	push	r28
    3442:	cd b7       	in	r28, 0x3d	; 61
    3444:	de b7       	in	r29, 0x3e	; 62

	/* The door is unlocking*/
	LCD_clearScreen();
    3446:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 4, "Door is");
    344a:	24 eb       	ldi	r18, 0xB4	; 180
    344c:	30 e0       	ldi	r19, 0x00	; 0
    344e:	80 e0       	ldi	r24, 0x00	; 0
    3450:	64 e0       	ldi	r22, 0x04	; 4
    3452:	a9 01       	movw	r20, r18
    3454:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_displayStringRowColumn(1, 2, "Unlocking...");
    3458:	2c eb       	ldi	r18, 0xBC	; 188
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	81 e0       	ldi	r24, 0x01	; 1
    345e:	62 e0       	ldi	r22, 0x02	; 2
    3460:	a9 01       	movw	r20, r18
    3462:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	timer1_delay(CLK_WISE_SECONDS);
    3466:	8f e0       	ldi	r24, 0x0F	; 15
    3468:	0e 94 31 15 	call	0x2a62	; 0x2a62 <timer1_delay>

	/* idle state*/
	LCD_clearScreen();
    346c:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 3, "WAITING...");
    3470:	29 ec       	ldi	r18, 0xC9	; 201
    3472:	30 e0       	ldi	r19, 0x00	; 0
    3474:	80 e0       	ldi	r24, 0x00	; 0
    3476:	63 e0       	ldi	r22, 0x03	; 3
    3478:	a9 01       	movw	r20, r18
    347a:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	timer1_delay(IDLE_SECONDS);
    347e:	83 e0       	ldi	r24, 0x03	; 3
    3480:	0e 94 31 15 	call	0x2a62	; 0x2a62 <timer1_delay>

	/* The door is locking*/
	LCD_clearScreen();
    3484:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 4, "Door is");
    3488:	24 eb       	ldi	r18, 0xB4	; 180
    348a:	30 e0       	ldi	r19, 0x00	; 0
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	64 e0       	ldi	r22, 0x04	; 4
    3490:	a9 01       	movw	r20, r18
    3492:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	LCD_displayStringRowColumn(1, 3, "Locking...");
    3496:	24 ed       	ldi	r18, 0xD4	; 212
    3498:	30 e0       	ldi	r19, 0x00	; 0
    349a:	81 e0       	ldi	r24, 0x01	; 1
    349c:	63 e0       	ldi	r22, 0x03	; 3
    349e:	a9 01       	movw	r20, r18
    34a0:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
	timer1_delay(ANTI_CLK_WISE_SECONDS);
    34a4:	8f e0       	ldi	r24, 0x0F	; 15
    34a6:	0e 94 31 15 	call	0x2a62	; 0x2a62 <timer1_delay>

}
    34aa:	cf 91       	pop	r28
    34ac:	df 91       	pop	r29
    34ae:	08 95       	ret

000034b0 <MainSystemOptions>:
 *******************************************************************************/

/*
 * MainSystemOptions for handling system options
 */
void MainSystemOptions(uint8 *password) {
    34b0:	df 93       	push	r29
    34b2:	cf 93       	push	r28
    34b4:	cd b7       	in	r28, 0x3d	; 61
    34b6:	de b7       	in	r29, 0x3e	; 62
    34b8:	e5 97       	sbiw	r28, 0x35	; 53
    34ba:	0f b6       	in	r0, 0x3f	; 63
    34bc:	f8 94       	cli
    34be:	de bf       	out	0x3e, r29	; 62
    34c0:	0f be       	out	0x3f, r0	; 63
    34c2:	cd bf       	out	0x3d, r28	; 61
    34c4:	9f a7       	std	Y+47, r25	; 0x2f
    34c6:	8e a7       	std	Y+46, r24	; 0x2e
	uint8 key, stateReceivedBytePlus,stateReceivedByteMinus ;
	while (1) {
		LCD_clearScreen();
    34c8:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
		LCD_displayStringRowColumn(0, 1, "+ : Open Door");
    34cc:	2f ed       	ldi	r18, 0xDF	; 223
    34ce:	30 e0       	ldi	r19, 0x00	; 0
    34d0:	80 e0       	ldi	r24, 0x00	; 0
    34d2:	61 e0       	ldi	r22, 0x01	; 1
    34d4:	a9 01       	movw	r20, r18
    34d6:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
		LCD_displayStringRowColumn(1, 1, "- : Change pass");
    34da:	2d ee       	ldi	r18, 0xED	; 237
    34dc:	30 e0       	ldi	r19, 0x00	; 0
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	61 e0       	ldi	r22, 0x01	; 1
    34e2:	a9 01       	movw	r20, r18
    34e4:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>

		/* Step 3 part 1: + or - for main system options*/
		key = KEYPAD_getPressedKey();
    34e8:	0e 94 aa 10 	call	0x2154	; 0x2154 <KEYPAD_getPressedKey>
    34ec:	8d a7       	std	Y+45, r24	; 0x2d

		/* Wait until MC2 is ready to receive the string */
		while (UART_recieveByte() != CHOOSEN_OPTION ) {}
    34ee:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    34f2:	87 30       	cpi	r24, 0x07	; 7
    34f4:	e1 f7       	brne	.-8      	; 0x34ee <MainSystemOptions+0x3e>
    34f6:	8d c1       	rjmp	.+794    	; 0x3812 <MainSystemOptions+0x362>
		while( trial_flag > 0 ) { /* This while loop will insure the system will leave its state in case the user entered wrong password it
		                             will ask the user to enter password for certain of trails which is THREE TIMES as trail_flag is defined
		                             global at the beginning of the file */
			switch (key) {
    34f8:	8d a5       	ldd	r24, Y+45	; 0x2d
    34fa:	28 2f       	mov	r18, r24
    34fc:	30 e0       	ldi	r19, 0x00	; 0
    34fe:	3d ab       	std	Y+53, r19	; 0x35
    3500:	2c ab       	std	Y+52, r18	; 0x34
    3502:	8c a9       	ldd	r24, Y+52	; 0x34
    3504:	9d a9       	ldd	r25, Y+53	; 0x35
    3506:	8b 32       	cpi	r24, 0x2B	; 43
    3508:	91 05       	cpc	r25, r1
    350a:	39 f0       	breq	.+14     	; 0x351a <MainSystemOptions+0x6a>
    350c:	2c a9       	ldd	r18, Y+52	; 0x34
    350e:	3d a9       	ldd	r19, Y+53	; 0x35
    3510:	2d 32       	cpi	r18, 0x2D	; 45
    3512:	31 05       	cpc	r19, r1
    3514:	09 f4       	brne	.+2      	; 0x3518 <MainSystemOptions+0x68>
    3516:	ba c0       	rjmp	.+372    	; 0x368c <MainSystemOptions+0x1dc>
    3518:	6e c1       	rjmp	.+732    	; 0x37f6 <MainSystemOptions+0x346>
			/* Step 3 part 2 : Receive state of the password in case ( + ) */
			case '+':
				/* Receive state of the password */
				UART_sendByte(DOOR_PASSWORD_STATE);
    351a:	88 e0       	ldi	r24, 0x08	; 8
    351c:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>

				/* Step 3 part 3: Enter the saved password you have entered in the first step and send via UART*/
				EnterPassword(password);
    3520:	8e a5       	ldd	r24, Y+46	; 0x2e
    3522:	9f a5       	ldd	r25, Y+47	; 0x2f
    3524:	0e 94 76 15 	call	0x2aec	; 0x2aec <EnterPassword>
				SendPassword(password);
    3528:	8e a5       	ldd	r24, Y+46	; 0x2e
    352a:	9f a5       	ldd	r25, Y+47	; 0x2f
    352c:	0e 94 73 19 	call	0x32e6	; 0x32e6 <SendPassword>

				/* Receive state of the password */
				UART_sendByte(DOOR_STATE);
    3530:	84 e0       	ldi	r24, 0x04	; 4
    3532:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
				stateReceivedBytePlus = UART_recieveByte();
    3536:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    353a:	8c a7       	std	Y+44, r24	; 0x2c

				/* According to received state what will be shown */
				switch (stateReceivedBytePlus) {
    353c:	8c a5       	ldd	r24, Y+44	; 0x2c
    353e:	28 2f       	mov	r18, r24
    3540:	30 e0       	ldi	r19, 0x00	; 0
    3542:	3b ab       	std	Y+51, r19	; 0x33
    3544:	2a ab       	std	Y+50, r18	; 0x32
    3546:	8a a9       	ldd	r24, Y+50	; 0x32
    3548:	9b a9       	ldd	r25, Y+51	; 0x33
    354a:	82 30       	cpi	r24, 0x02	; 2
    354c:	91 05       	cpc	r25, r1
    354e:	61 f0       	breq	.+24     	; 0x3568 <MainSystemOptions+0xb8>
    3550:	2a a9       	ldd	r18, Y+50	; 0x32
    3552:	3b a9       	ldd	r19, Y+51	; 0x33
    3554:	23 30       	cpi	r18, 0x03	; 3
    3556:	31 05       	cpc	r19, r1
    3558:	09 f0       	breq	.+2      	; 0x355c <MainSystemOptions+0xac>
    355a:	4d c1       	rjmp	.+666    	; 0x37f6 <MainSystemOptions+0x346>
				/* Step 3 part 4: In case correct user The door system will be performed */
				case CORRECT_PASSWORD:
					/* Step 3 part 5: This function will appear Unlocking, waiting, Locking */
					CorrectReceivedState();
    355c:	0e 94 1f 1a 	call	0x343e	; 0x343e <CorrectReceivedState>
					/* This will insure the trail_flag retain the default trials of the system */
					trial_flag = 3;
    3560:	83 e0       	ldi	r24, 0x03	; 3
    3562:	80 93 1a 01 	sts	0x011A, r24
    3566:	47 c1       	rjmp	.+654    	; 0x37f6 <MainSystemOptions+0x346>
				/* Step 5 part 1: This case will handle incorrect input from the user as
				 * First trial ( First entering wrong password in the system ) the flag will be decrement by -1 as the default value
				 * of the flag is 3 therefore the remaining trails is 2 and so on ...
				 *  */
				case INCORRECT_PASSWORD:
					LCD_clearScreen();
    3568:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
					LCD_displayStringRowColumn(0, 1, "Wrong Password");
    356c:	2d ef       	ldi	r18, 0xFD	; 253
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	80 e0       	ldi	r24, 0x00	; 0
    3572:	61 e0       	ldi	r22, 0x01	; 1
    3574:	a9 01       	movw	r20, r18
    3576:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
    357a:	80 e0       	ldi	r24, 0x00	; 0
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	aa ef       	ldi	r26, 0xFA	; 250
    3580:	b3 e4       	ldi	r27, 0x43	; 67
    3582:	8f a3       	std	Y+39, r24	; 0x27
    3584:	98 a7       	std	Y+40, r25	; 0x28
    3586:	a9 a7       	std	Y+41, r26	; 0x29
    3588:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    358a:	6f a1       	ldd	r22, Y+39	; 0x27
    358c:	78 a5       	ldd	r23, Y+40	; 0x28
    358e:	89 a5       	ldd	r24, Y+41	; 0x29
    3590:	9a a5       	ldd	r25, Y+42	; 0x2a
    3592:	20 e0       	ldi	r18, 0x00	; 0
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	4a ef       	ldi	r20, 0xFA	; 250
    3598:	54 e4       	ldi	r21, 0x44	; 68
    359a:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    359e:	dc 01       	movw	r26, r24
    35a0:	cb 01       	movw	r24, r22
    35a2:	8b a3       	std	Y+35, r24	; 0x23
    35a4:	9c a3       	std	Y+36, r25	; 0x24
    35a6:	ad a3       	std	Y+37, r26	; 0x25
    35a8:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    35aa:	6b a1       	ldd	r22, Y+35	; 0x23
    35ac:	7c a1       	ldd	r23, Y+36	; 0x24
    35ae:	8d a1       	ldd	r24, Y+37	; 0x25
    35b0:	9e a1       	ldd	r25, Y+38	; 0x26
    35b2:	20 e0       	ldi	r18, 0x00	; 0
    35b4:	30 e0       	ldi	r19, 0x00	; 0
    35b6:	40 e8       	ldi	r20, 0x80	; 128
    35b8:	5f e3       	ldi	r21, 0x3F	; 63
    35ba:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    35be:	88 23       	and	r24, r24
    35c0:	2c f4       	brge	.+10     	; 0x35cc <MainSystemOptions+0x11c>
		__ticks = 1;
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	9a a3       	std	Y+34, r25	; 0x22
    35c8:	89 a3       	std	Y+33, r24	; 0x21
    35ca:	3f c0       	rjmp	.+126    	; 0x364a <MainSystemOptions+0x19a>
	else if (__tmp > 65535)
    35cc:	6b a1       	ldd	r22, Y+35	; 0x23
    35ce:	7c a1       	ldd	r23, Y+36	; 0x24
    35d0:	8d a1       	ldd	r24, Y+37	; 0x25
    35d2:	9e a1       	ldd	r25, Y+38	; 0x26
    35d4:	20 e0       	ldi	r18, 0x00	; 0
    35d6:	3f ef       	ldi	r19, 0xFF	; 255
    35d8:	4f e7       	ldi	r20, 0x7F	; 127
    35da:	57 e4       	ldi	r21, 0x47	; 71
    35dc:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    35e0:	18 16       	cp	r1, r24
    35e2:	4c f5       	brge	.+82     	; 0x3636 <MainSystemOptions+0x186>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35e4:	6f a1       	ldd	r22, Y+39	; 0x27
    35e6:	78 a5       	ldd	r23, Y+40	; 0x28
    35e8:	89 a5       	ldd	r24, Y+41	; 0x29
    35ea:	9a a5       	ldd	r25, Y+42	; 0x2a
    35ec:	20 e0       	ldi	r18, 0x00	; 0
    35ee:	30 e0       	ldi	r19, 0x00	; 0
    35f0:	40 e2       	ldi	r20, 0x20	; 32
    35f2:	51 e4       	ldi	r21, 0x41	; 65
    35f4:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    35f8:	dc 01       	movw	r26, r24
    35fa:	cb 01       	movw	r24, r22
    35fc:	bc 01       	movw	r22, r24
    35fe:	cd 01       	movw	r24, r26
    3600:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    3604:	dc 01       	movw	r26, r24
    3606:	cb 01       	movw	r24, r22
    3608:	9a a3       	std	Y+34, r25	; 0x22
    360a:	89 a3       	std	Y+33, r24	; 0x21
    360c:	0f c0       	rjmp	.+30     	; 0x362c <MainSystemOptions+0x17c>
    360e:	88 ec       	ldi	r24, 0xC8	; 200
    3610:	90 e0       	ldi	r25, 0x00	; 0
    3612:	98 a3       	std	Y+32, r25	; 0x20
    3614:	8f 8f       	std	Y+31, r24	; 0x1f
    3616:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3618:	98 a1       	ldd	r25, Y+32	; 0x20
    361a:	01 97       	sbiw	r24, 0x01	; 1
    361c:	f1 f7       	brne	.-4      	; 0x361a <MainSystemOptions+0x16a>
    361e:	98 a3       	std	Y+32, r25	; 0x20
    3620:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3622:	89 a1       	ldd	r24, Y+33	; 0x21
    3624:	9a a1       	ldd	r25, Y+34	; 0x22
    3626:	01 97       	sbiw	r24, 0x01	; 1
    3628:	9a a3       	std	Y+34, r25	; 0x22
    362a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    362c:	89 a1       	ldd	r24, Y+33	; 0x21
    362e:	9a a1       	ldd	r25, Y+34	; 0x22
    3630:	00 97       	sbiw	r24, 0x00	; 0
    3632:	69 f7       	brne	.-38     	; 0x360e <MainSystemOptions+0x15e>
    3634:	14 c0       	rjmp	.+40     	; 0x365e <MainSystemOptions+0x1ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3636:	6b a1       	ldd	r22, Y+35	; 0x23
    3638:	7c a1       	ldd	r23, Y+36	; 0x24
    363a:	8d a1       	ldd	r24, Y+37	; 0x25
    363c:	9e a1       	ldd	r25, Y+38	; 0x26
    363e:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    3642:	dc 01       	movw	r26, r24
    3644:	cb 01       	movw	r24, r22
    3646:	9a a3       	std	Y+34, r25	; 0x22
    3648:	89 a3       	std	Y+33, r24	; 0x21
    364a:	89 a1       	ldd	r24, Y+33	; 0x21
    364c:	9a a1       	ldd	r25, Y+34	; 0x22
    364e:	9e 8f       	std	Y+30, r25	; 0x1e
    3650:	8d 8f       	std	Y+29, r24	; 0x1d
    3652:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3654:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3656:	01 97       	sbiw	r24, 0x01	; 1
    3658:	f1 f7       	brne	.-4      	; 0x3656 <MainSystemOptions+0x1a6>
    365a:	9e 8f       	std	Y+30, r25	; 0x1e
    365c:	8d 8f       	std	Y+29, r24	; 0x1d
					_delay_ms(KEY_PRESSED_DELAY);
					trial_flag--;
    365e:	80 91 1a 01 	lds	r24, 0x011A
    3662:	81 50       	subi	r24, 0x01	; 1
    3664:	80 93 1a 01 	sts	0x011A, r24
					/* After three trials failed*/
					if(trial_flag == 0){
    3668:	80 91 1a 01 	lds	r24, 0x011A
    366c:	88 23       	and	r24, r24
    366e:	09 f0       	breq	.+2      	; 0x3672 <MainSystemOptions+0x1c2>
    3670:	c2 c0       	rjmp	.+388    	; 0x37f6 <MainSystemOptions+0x346>
						LCD_clearScreen();
    3672:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
						/* An error msg will be displayed at the same time the buzzer will be on for 60 seconds*/
						LCD_displayStringRowColumn(0, 5, "ERROR");
    3676:	2c e0       	ldi	r18, 0x0C	; 12
    3678:	31 e0       	ldi	r19, 0x01	; 1
    367a:	80 e0       	ldi	r24, 0x00	; 0
    367c:	65 e0       	ldi	r22, 0x05	; 5
    367e:	a9 01       	movw	r20, r18
    3680:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
						timer1_delay(BUZZER_SECONDS);
    3684:	8c e3       	ldi	r24, 0x3C	; 60
    3686:	0e 94 31 15 	call	0x2a62	; 0x2a62 <timer1_delay>
    368a:	b5 c0       	rjmp	.+362    	; 0x37f6 <MainSystemOptions+0x346>
				}
				break;
				/* Step 4 part 1 : Receive state of the password in case ( - ) */
			case '-':
				/* Receive state of the password */
				UART_sendByte(CHANGE_PASSWORD_STATE);
    368c:	89 e0       	ldi	r24, 0x09	; 9
    368e:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>

				/* Step 4 part 2: Enter the saved password you have entered in the first step and send via UART*/
				EnterPassword(password);
    3692:	8e a5       	ldd	r24, Y+46	; 0x2e
    3694:	9f a5       	ldd	r25, Y+47	; 0x2f
    3696:	0e 94 76 15 	call	0x2aec	; 0x2aec <EnterPassword>
				SendPassword(password);
    369a:	8e a5       	ldd	r24, Y+46	; 0x2e
    369c:	9f a5       	ldd	r25, Y+47	; 0x2f
    369e:	0e 94 73 19 	call	0x32e6	; 0x32e6 <SendPassword>

				/* Receive state of the password */
				UART_sendByte(DOOR_STATE);
    36a2:	84 e0       	ldi	r24, 0x04	; 4
    36a4:	0e 94 a1 06 	call	0xd42	; 0xd42 <UART_sendByte>
				stateReceivedByteMinus= UART_recieveByte();
    36a8:	0e 94 b8 06 	call	0xd70	; 0xd70 <UART_recieveByte>
    36ac:	8b a7       	std	Y+43, r24	; 0x2b

				/* According to received state what will be shown */
				switch (stateReceivedByteMinus) {
    36ae:	8b a5       	ldd	r24, Y+43	; 0x2b
    36b0:	28 2f       	mov	r18, r24
    36b2:	30 e0       	ldi	r19, 0x00	; 0
    36b4:	39 ab       	std	Y+49, r19	; 0x31
    36b6:	28 ab       	std	Y+48, r18	; 0x30
    36b8:	88 a9       	ldd	r24, Y+48	; 0x30
    36ba:	99 a9       	ldd	r25, Y+49	; 0x31
    36bc:	82 30       	cpi	r24, 0x02	; 2
    36be:	91 05       	cpc	r25, r1
    36c0:	51 f0       	breq	.+20     	; 0x36d6 <MainSystemOptions+0x226>
    36c2:	28 a9       	ldd	r18, Y+48	; 0x30
    36c4:	39 a9       	ldd	r19, Y+49	; 0x31
    36c6:	23 30       	cpi	r18, 0x03	; 3
    36c8:	31 05       	cpc	r19, r1
    36ca:	09 f0       	breq	.+2      	; 0x36ce <MainSystemOptions+0x21e>
    36cc:	94 c0       	rjmp	.+296    	; 0x37f6 <MainSystemOptions+0x346>
				/* Step 4 part 3: In case user enter the right password the user will be directed to first step by breaking the two while loops */
				case CORRECT_PASSWORD:
					/* This will insure the trail_flag retain the default trials of the system */
					trial_flag = 3;
    36ce:	83 e0       	ldi	r24, 0x03	; 3
    36d0:	80 93 1a 01 	sts	0x011A, r24
    36d4:	90 c0       	rjmp	.+288    	; 0x37f6 <MainSystemOptions+0x346>
					/* Step 5 part 1: This case will handle incorrect input from the user as
				     * First trial ( First entering wrong password in the system ) the flag will be decrement by -1 as the default value
					 * of the flag is 3 therefore the remaining trails is 2 and so on ...
					 **/
				case INCORRECT_PASSWORD:
					LCD_clearScreen();
    36d6:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
					LCD_displayStringRowColumn(0, 1, "Wrong Password");
    36da:	2d ef       	ldi	r18, 0xFD	; 253
    36dc:	30 e0       	ldi	r19, 0x00	; 0
    36de:	80 e0       	ldi	r24, 0x00	; 0
    36e0:	61 e0       	ldi	r22, 0x01	; 1
    36e2:	a9 01       	movw	r20, r18
    36e4:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
    36e8:	80 e0       	ldi	r24, 0x00	; 0
    36ea:	90 e0       	ldi	r25, 0x00	; 0
    36ec:	aa ef       	ldi	r26, 0xFA	; 250
    36ee:	b3 e4       	ldi	r27, 0x43	; 67
    36f0:	89 8f       	std	Y+25, r24	; 0x19
    36f2:	9a 8f       	std	Y+26, r25	; 0x1a
    36f4:	ab 8f       	std	Y+27, r26	; 0x1b
    36f6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36f8:	69 8d       	ldd	r22, Y+25	; 0x19
    36fa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    36fc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    36fe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3700:	20 e0       	ldi	r18, 0x00	; 0
    3702:	30 e0       	ldi	r19, 0x00	; 0
    3704:	4a ef       	ldi	r20, 0xFA	; 250
    3706:	54 e4       	ldi	r21, 0x44	; 68
    3708:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    370c:	dc 01       	movw	r26, r24
    370e:	cb 01       	movw	r24, r22
    3710:	8d 8b       	std	Y+21, r24	; 0x15
    3712:	9e 8b       	std	Y+22, r25	; 0x16
    3714:	af 8b       	std	Y+23, r26	; 0x17
    3716:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3718:	6d 89       	ldd	r22, Y+21	; 0x15
    371a:	7e 89       	ldd	r23, Y+22	; 0x16
    371c:	8f 89       	ldd	r24, Y+23	; 0x17
    371e:	98 8d       	ldd	r25, Y+24	; 0x18
    3720:	20 e0       	ldi	r18, 0x00	; 0
    3722:	30 e0       	ldi	r19, 0x00	; 0
    3724:	40 e8       	ldi	r20, 0x80	; 128
    3726:	5f e3       	ldi	r21, 0x3F	; 63
    3728:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    372c:	88 23       	and	r24, r24
    372e:	2c f4       	brge	.+10     	; 0x373a <MainSystemOptions+0x28a>
		__ticks = 1;
    3730:	81 e0       	ldi	r24, 0x01	; 1
    3732:	90 e0       	ldi	r25, 0x00	; 0
    3734:	9c 8b       	std	Y+20, r25	; 0x14
    3736:	8b 8b       	std	Y+19, r24	; 0x13
    3738:	3f c0       	rjmp	.+126    	; 0x37b8 <MainSystemOptions+0x308>
	else if (__tmp > 65535)
    373a:	6d 89       	ldd	r22, Y+21	; 0x15
    373c:	7e 89       	ldd	r23, Y+22	; 0x16
    373e:	8f 89       	ldd	r24, Y+23	; 0x17
    3740:	98 8d       	ldd	r25, Y+24	; 0x18
    3742:	20 e0       	ldi	r18, 0x00	; 0
    3744:	3f ef       	ldi	r19, 0xFF	; 255
    3746:	4f e7       	ldi	r20, 0x7F	; 127
    3748:	57 e4       	ldi	r21, 0x47	; 71
    374a:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    374e:	18 16       	cp	r1, r24
    3750:	4c f5       	brge	.+82     	; 0x37a4 <MainSystemOptions+0x2f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3752:	69 8d       	ldd	r22, Y+25	; 0x19
    3754:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3756:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3758:	9c 8d       	ldd	r25, Y+28	; 0x1c
    375a:	20 e0       	ldi	r18, 0x00	; 0
    375c:	30 e0       	ldi	r19, 0x00	; 0
    375e:	40 e2       	ldi	r20, 0x20	; 32
    3760:	51 e4       	ldi	r21, 0x41	; 65
    3762:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3766:	dc 01       	movw	r26, r24
    3768:	cb 01       	movw	r24, r22
    376a:	bc 01       	movw	r22, r24
    376c:	cd 01       	movw	r24, r26
    376e:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    3772:	dc 01       	movw	r26, r24
    3774:	cb 01       	movw	r24, r22
    3776:	9c 8b       	std	Y+20, r25	; 0x14
    3778:	8b 8b       	std	Y+19, r24	; 0x13
    377a:	0f c0       	rjmp	.+30     	; 0x379a <MainSystemOptions+0x2ea>
    377c:	88 ec       	ldi	r24, 0xC8	; 200
    377e:	90 e0       	ldi	r25, 0x00	; 0
    3780:	9a 8b       	std	Y+18, r25	; 0x12
    3782:	89 8b       	std	Y+17, r24	; 0x11
    3784:	89 89       	ldd	r24, Y+17	; 0x11
    3786:	9a 89       	ldd	r25, Y+18	; 0x12
    3788:	01 97       	sbiw	r24, 0x01	; 1
    378a:	f1 f7       	brne	.-4      	; 0x3788 <MainSystemOptions+0x2d8>
    378c:	9a 8b       	std	Y+18, r25	; 0x12
    378e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3790:	8b 89       	ldd	r24, Y+19	; 0x13
    3792:	9c 89       	ldd	r25, Y+20	; 0x14
    3794:	01 97       	sbiw	r24, 0x01	; 1
    3796:	9c 8b       	std	Y+20, r25	; 0x14
    3798:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    379a:	8b 89       	ldd	r24, Y+19	; 0x13
    379c:	9c 89       	ldd	r25, Y+20	; 0x14
    379e:	00 97       	sbiw	r24, 0x00	; 0
    37a0:	69 f7       	brne	.-38     	; 0x377c <MainSystemOptions+0x2cc>
    37a2:	14 c0       	rjmp	.+40     	; 0x37cc <MainSystemOptions+0x31c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37a4:	6d 89       	ldd	r22, Y+21	; 0x15
    37a6:	7e 89       	ldd	r23, Y+22	; 0x16
    37a8:	8f 89       	ldd	r24, Y+23	; 0x17
    37aa:	98 8d       	ldd	r25, Y+24	; 0x18
    37ac:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    37b0:	dc 01       	movw	r26, r24
    37b2:	cb 01       	movw	r24, r22
    37b4:	9c 8b       	std	Y+20, r25	; 0x14
    37b6:	8b 8b       	std	Y+19, r24	; 0x13
    37b8:	8b 89       	ldd	r24, Y+19	; 0x13
    37ba:	9c 89       	ldd	r25, Y+20	; 0x14
    37bc:	98 8b       	std	Y+16, r25	; 0x10
    37be:	8f 87       	std	Y+15, r24	; 0x0f
    37c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    37c2:	98 89       	ldd	r25, Y+16	; 0x10
    37c4:	01 97       	sbiw	r24, 0x01	; 1
    37c6:	f1 f7       	brne	.-4      	; 0x37c4 <MainSystemOptions+0x314>
    37c8:	98 8b       	std	Y+16, r25	; 0x10
    37ca:	8f 87       	std	Y+15, r24	; 0x0f
					_delay_ms(KEY_PRESSED_DELAY);
					trial_flag--;
    37cc:	80 91 1a 01 	lds	r24, 0x011A
    37d0:	81 50       	subi	r24, 0x01	; 1
    37d2:	80 93 1a 01 	sts	0x011A, r24
					if(trial_flag == 0){
    37d6:	80 91 1a 01 	lds	r24, 0x011A
    37da:	88 23       	and	r24, r24
    37dc:	61 f4       	brne	.+24     	; 0x37f6 <MainSystemOptions+0x346>
						/* After three trials failed*/
						LCD_clearScreen();
    37de:	0e 94 a0 10 	call	0x2140	; 0x2140 <LCD_clearScreen>
						/* An error msg will be displayed at the same time the buzzer will be on for 60 seconds*/
						LCD_displayStringRowColumn(0, 5, "ERROR");
    37e2:	2c e0       	ldi	r18, 0x0C	; 12
    37e4:	31 e0       	ldi	r19, 0x01	; 1
    37e6:	80 e0       	ldi	r24, 0x00	; 0
    37e8:	65 e0       	ldi	r22, 0x05	; 5
    37ea:	a9 01       	movw	r20, r18
    37ec:	0e 94 36 10 	call	0x206c	; 0x206c <LCD_displayStringRowColumn>
						timer1_delay(BUZZER_SECONDS);
    37f0:	8c e3       	ldi	r24, 0x3C	; 60
    37f2:	0e 94 31 15 	call	0x2a62	; 0x2a62 <timer1_delay>
					}
					break;
				}
				break;
			}
			if (stateReceivedBytePlus == CORRECT_PASSWORD || stateReceivedByteMinus == CORRECT_PASSWORD || trial_flag == 0 ) {
    37f6:	8c a5       	ldd	r24, Y+44	; 0x2c
    37f8:	83 30       	cpi	r24, 0x03	; 3
    37fa:	39 f0       	breq	.+14     	; 0x380a <MainSystemOptions+0x35a>
    37fc:	8b a5       	ldd	r24, Y+43	; 0x2b
    37fe:	83 30       	cpi	r24, 0x03	; 3
    3800:	21 f0       	breq	.+8      	; 0x380a <MainSystemOptions+0x35a>
    3802:	80 91 1a 01 	lds	r24, 0x011A
    3806:	88 23       	and	r24, r24
    3808:	21 f4       	brne	.+8      	; 0x3812 <MainSystemOptions+0x362>
				trial_flag = 3;
    380a:	83 e0       	ldi	r24, 0x03	; 3
    380c:	80 93 1a 01 	sts	0x011A, r24
    3810:	05 c0       	rjmp	.+10     	; 0x381c <MainSystemOptions+0x36c>
		/* Step 3 part 1: + or - for main system options*/
		key = KEYPAD_getPressedKey();

		/* Wait until MC2 is ready to receive the string */
		while (UART_recieveByte() != CHOOSEN_OPTION ) {}
		while( trial_flag > 0 ) { /* This while loop will insure the system will leave its state in case the user entered wrong password it
    3812:	80 91 1a 01 	lds	r24, 0x011A
    3816:	88 23       	and	r24, r24
    3818:	09 f0       	breq	.+2      	; 0x381c <MainSystemOptions+0x36c>
    381a:	6e ce       	rjmp	.-804    	; 0x34f8 <MainSystemOptions+0x48>
			if (stateReceivedBytePlus == CORRECT_PASSWORD || stateReceivedByteMinus == CORRECT_PASSWORD || trial_flag == 0 ) {
				trial_flag = 3;
				break; /* Break out of the while (1) loop this will be directed to step 3 which is + : open door and - : change pass */
			}
		}
		if (stateReceivedByteMinus == CORRECT_PASSWORD) {
    381c:	8b a5       	ldd	r24, Y+43	; 0x2b
    381e:	83 30       	cpi	r24, 0x03	; 3
    3820:	09 f4       	brne	.+2      	; 0x3824 <MainSystemOptions+0x374>
    3822:	73 c0       	rjmp	.+230    	; 0x390a <MainSystemOptions+0x45a>
			break;  /* Break out of the while (1) loop this will be to step 1 which is enter password: and re-enter password */
    3824:	80 e0       	ldi	r24, 0x00	; 0
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	a6 e9       	ldi	r26, 0x96	; 150
    382a:	b3 e4       	ldi	r27, 0x43	; 67
    382c:	8b 87       	std	Y+11, r24	; 0x0b
    382e:	9c 87       	std	Y+12, r25	; 0x0c
    3830:	ad 87       	std	Y+13, r26	; 0x0d
    3832:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3834:	6b 85       	ldd	r22, Y+11	; 0x0b
    3836:	7c 85       	ldd	r23, Y+12	; 0x0c
    3838:	8d 85       	ldd	r24, Y+13	; 0x0d
    383a:	9e 85       	ldd	r25, Y+14	; 0x0e
    383c:	20 e0       	ldi	r18, 0x00	; 0
    383e:	30 e0       	ldi	r19, 0x00	; 0
    3840:	4a ef       	ldi	r20, 0xFA	; 250
    3842:	54 e4       	ldi	r21, 0x44	; 68
    3844:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    3848:	dc 01       	movw	r26, r24
    384a:	cb 01       	movw	r24, r22
    384c:	8f 83       	std	Y+7, r24	; 0x07
    384e:	98 87       	std	Y+8, r25	; 0x08
    3850:	a9 87       	std	Y+9, r26	; 0x09
    3852:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3854:	6f 81       	ldd	r22, Y+7	; 0x07
    3856:	78 85       	ldd	r23, Y+8	; 0x08
    3858:	89 85       	ldd	r24, Y+9	; 0x09
    385a:	9a 85       	ldd	r25, Y+10	; 0x0a
    385c:	20 e0       	ldi	r18, 0x00	; 0
    385e:	30 e0       	ldi	r19, 0x00	; 0
    3860:	40 e8       	ldi	r20, 0x80	; 128
    3862:	5f e3       	ldi	r21, 0x3F	; 63
    3864:	0e 94 f6 03 	call	0x7ec	; 0x7ec <__ltsf2>
    3868:	88 23       	and	r24, r24
    386a:	2c f4       	brge	.+10     	; 0x3876 <MainSystemOptions+0x3c6>
		__ticks = 1;
    386c:	81 e0       	ldi	r24, 0x01	; 1
    386e:	90 e0       	ldi	r25, 0x00	; 0
    3870:	9e 83       	std	Y+6, r25	; 0x06
    3872:	8d 83       	std	Y+5, r24	; 0x05
    3874:	3f c0       	rjmp	.+126    	; 0x38f4 <MainSystemOptions+0x444>
	else if (__tmp > 65535)
    3876:	6f 81       	ldd	r22, Y+7	; 0x07
    3878:	78 85       	ldd	r23, Y+8	; 0x08
    387a:	89 85       	ldd	r24, Y+9	; 0x09
    387c:	9a 85       	ldd	r25, Y+10	; 0x0a
    387e:	20 e0       	ldi	r18, 0x00	; 0
    3880:	3f ef       	ldi	r19, 0xFF	; 255
    3882:	4f e7       	ldi	r20, 0x7F	; 127
    3884:	57 e4       	ldi	r21, 0x47	; 71
    3886:	0e 94 96 03 	call	0x72c	; 0x72c <__gtsf2>
    388a:	18 16       	cp	r1, r24
    388c:	4c f5       	brge	.+82     	; 0x38e0 <MainSystemOptions+0x430>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    388e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3890:	7c 85       	ldd	r23, Y+12	; 0x0c
    3892:	8d 85       	ldd	r24, Y+13	; 0x0d
    3894:	9e 85       	ldd	r25, Y+14	; 0x0e
    3896:	20 e0       	ldi	r18, 0x00	; 0
    3898:	30 e0       	ldi	r19, 0x00	; 0
    389a:	40 e2       	ldi	r20, 0x20	; 32
    389c:	51 e4       	ldi	r21, 0x41	; 65
    389e:	0e 94 9c 02 	call	0x538	; 0x538 <__mulsf3>
    38a2:	dc 01       	movw	r26, r24
    38a4:	cb 01       	movw	r24, r22
    38a6:	bc 01       	movw	r22, r24
    38a8:	cd 01       	movw	r24, r26
    38aa:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    38ae:	dc 01       	movw	r26, r24
    38b0:	cb 01       	movw	r24, r22
    38b2:	9e 83       	std	Y+6, r25	; 0x06
    38b4:	8d 83       	std	Y+5, r24	; 0x05
    38b6:	0f c0       	rjmp	.+30     	; 0x38d6 <MainSystemOptions+0x426>
    38b8:	88 ec       	ldi	r24, 0xC8	; 200
    38ba:	90 e0       	ldi	r25, 0x00	; 0
    38bc:	9c 83       	std	Y+4, r25	; 0x04
    38be:	8b 83       	std	Y+3, r24	; 0x03
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	01 97       	sbiw	r24, 0x01	; 1
    38c6:	f1 f7       	brne	.-4      	; 0x38c4 <MainSystemOptions+0x414>
    38c8:	9c 83       	std	Y+4, r25	; 0x04
    38ca:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38cc:	8d 81       	ldd	r24, Y+5	; 0x05
    38ce:	9e 81       	ldd	r25, Y+6	; 0x06
    38d0:	01 97       	sbiw	r24, 0x01	; 1
    38d2:	9e 83       	std	Y+6, r25	; 0x06
    38d4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38d6:	8d 81       	ldd	r24, Y+5	; 0x05
    38d8:	9e 81       	ldd	r25, Y+6	; 0x06
    38da:	00 97       	sbiw	r24, 0x00	; 0
    38dc:	69 f7       	brne	.-38     	; 0x38b8 <MainSystemOptions+0x408>
    38de:	f4 cd       	rjmp	.-1048   	; 0x34c8 <MainSystemOptions+0x18>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38e0:	6f 81       	ldd	r22, Y+7	; 0x07
    38e2:	78 85       	ldd	r23, Y+8	; 0x08
    38e4:	89 85       	ldd	r24, Y+9	; 0x09
    38e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    38e8:	0e 94 c6 00 	call	0x18c	; 0x18c <__fixunssfsi>
    38ec:	dc 01       	movw	r26, r24
    38ee:	cb 01       	movw	r24, r22
    38f0:	9e 83       	std	Y+6, r25	; 0x06
    38f2:	8d 83       	std	Y+5, r24	; 0x05
    38f4:	8d 81       	ldd	r24, Y+5	; 0x05
    38f6:	9e 81       	ldd	r25, Y+6	; 0x06
    38f8:	9a 83       	std	Y+2, r25	; 0x02
    38fa:	89 83       	std	Y+1, r24	; 0x01
    38fc:	89 81       	ldd	r24, Y+1	; 0x01
    38fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3900:	01 97       	sbiw	r24, 0x01	; 1
    3902:	f1 f7       	brne	.-4      	; 0x3900 <MainSystemOptions+0x450>
    3904:	9a 83       	std	Y+2, r25	; 0x02
    3906:	89 83       	std	Y+1, r24	; 0x01
    3908:	df cd       	rjmp	.-1090   	; 0x34c8 <MainSystemOptions+0x18>
		}
		_delay_ms(MEDIUM_DELAY);
	}
}
    390a:	e5 96       	adiw	r28, 0x35	; 53
    390c:	0f b6       	in	r0, 0x3f	; 63
    390e:	f8 94       	cli
    3910:	de bf       	out	0x3e, r29	; 62
    3912:	0f be       	out	0x3f, r0	; 63
    3914:	cd bf       	out	0x3d, r28	; 61
    3916:	cf 91       	pop	r28
    3918:	df 91       	pop	r29
    391a:	08 95       	ret

0000391c <__udivmodsi4>:
    391c:	a1 e2       	ldi	r26, 0x21	; 33
    391e:	1a 2e       	mov	r1, r26
    3920:	aa 1b       	sub	r26, r26
    3922:	bb 1b       	sub	r27, r27
    3924:	fd 01       	movw	r30, r26
    3926:	0d c0       	rjmp	.+26     	; 0x3942 <__udivmodsi4_ep>

00003928 <__udivmodsi4_loop>:
    3928:	aa 1f       	adc	r26, r26
    392a:	bb 1f       	adc	r27, r27
    392c:	ee 1f       	adc	r30, r30
    392e:	ff 1f       	adc	r31, r31
    3930:	a2 17       	cp	r26, r18
    3932:	b3 07       	cpc	r27, r19
    3934:	e4 07       	cpc	r30, r20
    3936:	f5 07       	cpc	r31, r21
    3938:	20 f0       	brcs	.+8      	; 0x3942 <__udivmodsi4_ep>
    393a:	a2 1b       	sub	r26, r18
    393c:	b3 0b       	sbc	r27, r19
    393e:	e4 0b       	sbc	r30, r20
    3940:	f5 0b       	sbc	r31, r21

00003942 <__udivmodsi4_ep>:
    3942:	66 1f       	adc	r22, r22
    3944:	77 1f       	adc	r23, r23
    3946:	88 1f       	adc	r24, r24
    3948:	99 1f       	adc	r25, r25
    394a:	1a 94       	dec	r1
    394c:	69 f7       	brne	.-38     	; 0x3928 <__udivmodsi4_loop>
    394e:	60 95       	com	r22
    3950:	70 95       	com	r23
    3952:	80 95       	com	r24
    3954:	90 95       	com	r25
    3956:	9b 01       	movw	r18, r22
    3958:	ac 01       	movw	r20, r24
    395a:	bd 01       	movw	r22, r26
    395c:	cf 01       	movw	r24, r30
    395e:	08 95       	ret

00003960 <__prologue_saves__>:
    3960:	2f 92       	push	r2
    3962:	3f 92       	push	r3
    3964:	4f 92       	push	r4
    3966:	5f 92       	push	r5
    3968:	6f 92       	push	r6
    396a:	7f 92       	push	r7
    396c:	8f 92       	push	r8
    396e:	9f 92       	push	r9
    3970:	af 92       	push	r10
    3972:	bf 92       	push	r11
    3974:	cf 92       	push	r12
    3976:	df 92       	push	r13
    3978:	ef 92       	push	r14
    397a:	ff 92       	push	r15
    397c:	0f 93       	push	r16
    397e:	1f 93       	push	r17
    3980:	cf 93       	push	r28
    3982:	df 93       	push	r29
    3984:	cd b7       	in	r28, 0x3d	; 61
    3986:	de b7       	in	r29, 0x3e	; 62
    3988:	ca 1b       	sub	r28, r26
    398a:	db 0b       	sbc	r29, r27
    398c:	0f b6       	in	r0, 0x3f	; 63
    398e:	f8 94       	cli
    3990:	de bf       	out	0x3e, r29	; 62
    3992:	0f be       	out	0x3f, r0	; 63
    3994:	cd bf       	out	0x3d, r28	; 61
    3996:	09 94       	ijmp

00003998 <__epilogue_restores__>:
    3998:	2a 88       	ldd	r2, Y+18	; 0x12
    399a:	39 88       	ldd	r3, Y+17	; 0x11
    399c:	48 88       	ldd	r4, Y+16	; 0x10
    399e:	5f 84       	ldd	r5, Y+15	; 0x0f
    39a0:	6e 84       	ldd	r6, Y+14	; 0x0e
    39a2:	7d 84       	ldd	r7, Y+13	; 0x0d
    39a4:	8c 84       	ldd	r8, Y+12	; 0x0c
    39a6:	9b 84       	ldd	r9, Y+11	; 0x0b
    39a8:	aa 84       	ldd	r10, Y+10	; 0x0a
    39aa:	b9 84       	ldd	r11, Y+9	; 0x09
    39ac:	c8 84       	ldd	r12, Y+8	; 0x08
    39ae:	df 80       	ldd	r13, Y+7	; 0x07
    39b0:	ee 80       	ldd	r14, Y+6	; 0x06
    39b2:	fd 80       	ldd	r15, Y+5	; 0x05
    39b4:	0c 81       	ldd	r16, Y+4	; 0x04
    39b6:	1b 81       	ldd	r17, Y+3	; 0x03
    39b8:	aa 81       	ldd	r26, Y+2	; 0x02
    39ba:	b9 81       	ldd	r27, Y+1	; 0x01
    39bc:	ce 0f       	add	r28, r30
    39be:	d1 1d       	adc	r29, r1
    39c0:	0f b6       	in	r0, 0x3f	; 63
    39c2:	f8 94       	cli
    39c4:	de bf       	out	0x3e, r29	; 62
    39c6:	0f be       	out	0x3f, r0	; 63
    39c8:	cd bf       	out	0x3d, r28	; 61
    39ca:	ed 01       	movw	r28, r26
    39cc:	08 95       	ret

000039ce <dtostrf>:
    39ce:	ef 92       	push	r14
    39d0:	ff 92       	push	r15
    39d2:	0f 93       	push	r16
    39d4:	1f 93       	push	r17
    39d6:	f2 2f       	mov	r31, r18
    39d8:	f0 2e       	mov	r15, r16
    39da:	47 fd       	sbrc	r20, 7
    39dc:	02 c0       	rjmp	.+4      	; 0x39e2 <dtostrf+0x14>
    39de:	e4 e0       	ldi	r30, 0x04	; 4
    39e0:	01 c0       	rjmp	.+2      	; 0x39e4 <dtostrf+0x16>
    39e2:	e4 e1       	ldi	r30, 0x14	; 20
    39e4:	24 2f       	mov	r18, r20
    39e6:	33 27       	eor	r19, r19
    39e8:	27 fd       	sbrc	r18, 7
    39ea:	30 95       	com	r19
    39ec:	37 ff       	sbrs	r19, 7
    39ee:	03 c0       	rjmp	.+6      	; 0x39f6 <dtostrf+0x28>
    39f0:	30 95       	com	r19
    39f2:	21 95       	neg	r18
    39f4:	3f 4f       	sbci	r19, 0xFF	; 255
    39f6:	4f 2d       	mov	r20, r15
    39f8:	51 2f       	mov	r21, r17
    39fa:	0f 2f       	mov	r16, r31
    39fc:	ee 2e       	mov	r14, r30
    39fe:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <dtoa_prf>
    3a02:	8f 2d       	mov	r24, r15
    3a04:	91 2f       	mov	r25, r17
    3a06:	1f 91       	pop	r17
    3a08:	0f 91       	pop	r16
    3a0a:	ff 90       	pop	r15
    3a0c:	ef 90       	pop	r14
    3a0e:	08 95       	ret

00003a10 <itoa>:
    3a10:	fb 01       	movw	r30, r22
    3a12:	9f 01       	movw	r18, r30
    3a14:	e8 94       	clt
    3a16:	42 30       	cpi	r20, 0x02	; 2
    3a18:	c4 f0       	brlt	.+48     	; 0x3a4a <itoa+0x3a>
    3a1a:	45 32       	cpi	r20, 0x25	; 37
    3a1c:	b4 f4       	brge	.+44     	; 0x3a4a <itoa+0x3a>
    3a1e:	4a 30       	cpi	r20, 0x0A	; 10
    3a20:	29 f4       	brne	.+10     	; 0x3a2c <itoa+0x1c>
    3a22:	97 fb       	bst	r25, 7
    3a24:	1e f4       	brtc	.+6      	; 0x3a2c <itoa+0x1c>
    3a26:	90 95       	com	r25
    3a28:	81 95       	neg	r24
    3a2a:	9f 4f       	sbci	r25, 0xFF	; 255
    3a2c:	64 2f       	mov	r22, r20
    3a2e:	77 27       	eor	r23, r23
    3a30:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <__udivmodhi4>
    3a34:	80 5d       	subi	r24, 0xD0	; 208
    3a36:	8a 33       	cpi	r24, 0x3A	; 58
    3a38:	0c f0       	brlt	.+2      	; 0x3a3c <itoa+0x2c>
    3a3a:	89 5d       	subi	r24, 0xD9	; 217
    3a3c:	81 93       	st	Z+, r24
    3a3e:	cb 01       	movw	r24, r22
    3a40:	00 97       	sbiw	r24, 0x00	; 0
    3a42:	a1 f7       	brne	.-24     	; 0x3a2c <itoa+0x1c>
    3a44:	16 f4       	brtc	.+4      	; 0x3a4a <itoa+0x3a>
    3a46:	5d e2       	ldi	r21, 0x2D	; 45
    3a48:	51 93       	st	Z+, r21
    3a4a:	10 82       	st	Z, r1
    3a4c:	c9 01       	movw	r24, r18
    3a4e:	0c 94 63 1f 	jmp	0x3ec6	; 0x3ec6 <strrev>

00003a52 <dtoa_prf>:
    3a52:	a9 e0       	ldi	r26, 0x09	; 9
    3a54:	b0 e0       	ldi	r27, 0x00	; 0
    3a56:	ef e2       	ldi	r30, 0x2F	; 47
    3a58:	fd e1       	ldi	r31, 0x1D	; 29
    3a5a:	0c 94 b4 1c 	jmp	0x3968	; 0x3968 <__prologue_saves__+0x8>
    3a5e:	6a 01       	movw	r12, r20
    3a60:	12 2f       	mov	r17, r18
    3a62:	a0 2e       	mov	r10, r16
    3a64:	be 2c       	mov	r11, r14
    3a66:	2b e3       	ldi	r18, 0x3B	; 59
    3a68:	20 17       	cp	r18, r16
    3a6a:	18 f4       	brcc	.+6      	; 0x3a72 <dtoa_prf+0x20>
    3a6c:	2c e3       	ldi	r18, 0x3C	; 60
    3a6e:	92 2e       	mov	r9, r18
    3a70:	02 c0       	rjmp	.+4      	; 0x3a76 <dtoa_prf+0x24>
    3a72:	90 2e       	mov	r9, r16
    3a74:	93 94       	inc	r9
    3a76:	ae 01       	movw	r20, r28
    3a78:	4f 5f       	subi	r20, 0xFF	; 255
    3a7a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a7c:	27 e0       	ldi	r18, 0x07	; 7
    3a7e:	09 2d       	mov	r16, r9
    3a80:	0e 94 8b 1e 	call	0x3d16	; 0x3d16 <__ftoa_engine>
    3a84:	bc 01       	movw	r22, r24
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	e8 2e       	mov	r14, r24
    3a8a:	ff 24       	eor	r15, r15
    3a8c:	c7 01       	movw	r24, r14
    3a8e:	89 70       	andi	r24, 0x09	; 9
    3a90:	90 70       	andi	r25, 0x00	; 0
    3a92:	01 97       	sbiw	r24, 0x01	; 1
    3a94:	11 f4       	brne	.+4      	; 0x3a9a <dtoa_prf+0x48>
    3a96:	ad e2       	ldi	r26, 0x2D	; 45
    3a98:	09 c0       	rjmp	.+18     	; 0x3aac <dtoa_prf+0x5a>
    3a9a:	b1 fe       	sbrs	r11, 1
    3a9c:	02 c0       	rjmp	.+4      	; 0x3aa2 <dtoa_prf+0x50>
    3a9e:	ab e2       	ldi	r26, 0x2B	; 43
    3aa0:	05 c0       	rjmp	.+10     	; 0x3aac <dtoa_prf+0x5a>
    3aa2:	b0 fc       	sbrc	r11, 0
    3aa4:	02 c0       	rjmp	.+4      	; 0x3aaa <dtoa_prf+0x58>
    3aa6:	a0 e0       	ldi	r26, 0x00	; 0
    3aa8:	01 c0       	rjmp	.+2      	; 0x3aac <dtoa_prf+0x5a>
    3aaa:	a0 e2       	ldi	r26, 0x20	; 32
    3aac:	e3 fe       	sbrs	r14, 3
    3aae:	3b c0       	rjmp	.+118    	; 0x3b26 <dtoa_prf+0xd4>
    3ab0:	aa 23       	and	r26, r26
    3ab2:	11 f4       	brne	.+4      	; 0x3ab8 <dtoa_prf+0x66>
    3ab4:	23 e0       	ldi	r18, 0x03	; 3
    3ab6:	01 c0       	rjmp	.+2      	; 0x3aba <dtoa_prf+0x68>
    3ab8:	24 e0       	ldi	r18, 0x04	; 4
    3aba:	21 17       	cp	r18, r17
    3abc:	10 f0       	brcs	.+4      	; 0x3ac2 <dtoa_prf+0x70>
    3abe:	20 e0       	ldi	r18, 0x00	; 0
    3ac0:	02 c0       	rjmp	.+4      	; 0x3ac6 <dtoa_prf+0x74>
    3ac2:	12 1b       	sub	r17, r18
    3ac4:	21 2f       	mov	r18, r17
    3ac6:	eb 2c       	mov	r14, r11
    3ac8:	b4 fe       	sbrs	r11, 4
    3aca:	02 c0       	rjmp	.+4      	; 0x3ad0 <dtoa_prf+0x7e>
    3acc:	32 2f       	mov	r19, r18
    3ace:	0a c0       	rjmp	.+20     	; 0x3ae4 <dtoa_prf+0x92>
    3ad0:	f6 01       	movw	r30, r12
    3ad2:	32 2f       	mov	r19, r18
    3ad4:	80 e2       	ldi	r24, 0x20	; 32
    3ad6:	02 c0       	rjmp	.+4      	; 0x3adc <dtoa_prf+0x8a>
    3ad8:	81 93       	st	Z+, r24
    3ada:	31 50       	subi	r19, 0x01	; 1
    3adc:	33 23       	and	r19, r19
    3ade:	e1 f7       	brne	.-8      	; 0x3ad8 <dtoa_prf+0x86>
    3ae0:	c2 0e       	add	r12, r18
    3ae2:	d1 1c       	adc	r13, r1
    3ae4:	aa 23       	and	r26, r26
    3ae6:	19 f0       	breq	.+6      	; 0x3aee <dtoa_prf+0x9c>
    3ae8:	f6 01       	movw	r30, r12
    3aea:	a1 93       	st	Z+, r26
    3aec:	6f 01       	movw	r12, r30
    3aee:	f6 01       	movw	r30, r12
    3af0:	31 96       	adiw	r30, 0x01	; 1
    3af2:	e2 fe       	sbrs	r14, 2
    3af4:	05 c0       	rjmp	.+10     	; 0x3b00 <dtoa_prf+0xae>
    3af6:	9e e4       	ldi	r25, 0x4E	; 78
    3af8:	d6 01       	movw	r26, r12
    3afa:	9c 93       	st	X, r25
    3afc:	81 e4       	ldi	r24, 0x41	; 65
    3afe:	04 c0       	rjmp	.+8      	; 0x3b08 <dtoa_prf+0xb6>
    3b00:	9e e6       	ldi	r25, 0x6E	; 110
    3b02:	d6 01       	movw	r26, r12
    3b04:	9c 93       	st	X, r25
    3b06:	81 e6       	ldi	r24, 0x61	; 97
    3b08:	11 96       	adiw	r26, 0x01	; 1
    3b0a:	8c 93       	st	X, r24
    3b0c:	91 83       	std	Z+1, r25	; 0x01
    3b0e:	32 96       	adiw	r30, 0x02	; 2
    3b10:	df 01       	movw	r26, r30
    3b12:	83 2f       	mov	r24, r19
    3b14:	90 e2       	ldi	r25, 0x20	; 32
    3b16:	02 c0       	rjmp	.+4      	; 0x3b1c <dtoa_prf+0xca>
    3b18:	9d 93       	st	X+, r25
    3b1a:	81 50       	subi	r24, 0x01	; 1
    3b1c:	88 23       	and	r24, r24
    3b1e:	e1 f7       	brne	.-8      	; 0x3b18 <dtoa_prf+0xc6>
    3b20:	e3 0f       	add	r30, r19
    3b22:	f1 1d       	adc	r31, r1
    3b24:	40 c0       	rjmp	.+128    	; 0x3ba6 <dtoa_prf+0x154>
    3b26:	e2 fe       	sbrs	r14, 2
    3b28:	42 c0       	rjmp	.+132    	; 0x3bae <dtoa_prf+0x15c>
    3b2a:	aa 23       	and	r26, r26
    3b2c:	11 f4       	brne	.+4      	; 0x3b32 <dtoa_prf+0xe0>
    3b2e:	23 e0       	ldi	r18, 0x03	; 3
    3b30:	01 c0       	rjmp	.+2      	; 0x3b34 <dtoa_prf+0xe2>
    3b32:	24 e0       	ldi	r18, 0x04	; 4
    3b34:	21 17       	cp	r18, r17
    3b36:	10 f0       	brcs	.+4      	; 0x3b3c <dtoa_prf+0xea>
    3b38:	20 e0       	ldi	r18, 0x00	; 0
    3b3a:	02 c0       	rjmp	.+4      	; 0x3b40 <dtoa_prf+0xee>
    3b3c:	12 1b       	sub	r17, r18
    3b3e:	21 2f       	mov	r18, r17
    3b40:	eb 2c       	mov	r14, r11
    3b42:	b4 fe       	sbrs	r11, 4
    3b44:	02 c0       	rjmp	.+4      	; 0x3b4a <dtoa_prf+0xf8>
    3b46:	92 2f       	mov	r25, r18
    3b48:	0a c0       	rjmp	.+20     	; 0x3b5e <dtoa_prf+0x10c>
    3b4a:	f6 01       	movw	r30, r12
    3b4c:	92 2f       	mov	r25, r18
    3b4e:	80 e2       	ldi	r24, 0x20	; 32
    3b50:	02 c0       	rjmp	.+4      	; 0x3b56 <dtoa_prf+0x104>
    3b52:	81 93       	st	Z+, r24
    3b54:	91 50       	subi	r25, 0x01	; 1
    3b56:	99 23       	and	r25, r25
    3b58:	e1 f7       	brne	.-8      	; 0x3b52 <dtoa_prf+0x100>
    3b5a:	c2 0e       	add	r12, r18
    3b5c:	d1 1c       	adc	r13, r1
    3b5e:	aa 23       	and	r26, r26
    3b60:	19 f0       	breq	.+6      	; 0x3b68 <dtoa_prf+0x116>
    3b62:	f6 01       	movw	r30, r12
    3b64:	a1 93       	st	Z+, r26
    3b66:	6f 01       	movw	r12, r30
    3b68:	f6 01       	movw	r30, r12
    3b6a:	31 96       	adiw	r30, 0x01	; 1
    3b6c:	e2 fe       	sbrs	r14, 2
    3b6e:	08 c0       	rjmp	.+16     	; 0x3b80 <dtoa_prf+0x12e>
    3b70:	89 e4       	ldi	r24, 0x49	; 73
    3b72:	d6 01       	movw	r26, r12
    3b74:	8c 93       	st	X, r24
    3b76:	8e e4       	ldi	r24, 0x4E	; 78
    3b78:	11 96       	adiw	r26, 0x01	; 1
    3b7a:	8c 93       	st	X, r24
    3b7c:	86 e4       	ldi	r24, 0x46	; 70
    3b7e:	07 c0       	rjmp	.+14     	; 0x3b8e <dtoa_prf+0x13c>
    3b80:	89 e6       	ldi	r24, 0x69	; 105
    3b82:	d6 01       	movw	r26, r12
    3b84:	8c 93       	st	X, r24
    3b86:	8e e6       	ldi	r24, 0x6E	; 110
    3b88:	11 96       	adiw	r26, 0x01	; 1
    3b8a:	8c 93       	st	X, r24
    3b8c:	86 e6       	ldi	r24, 0x66	; 102
    3b8e:	81 83       	std	Z+1, r24	; 0x01
    3b90:	32 96       	adiw	r30, 0x02	; 2
    3b92:	df 01       	movw	r26, r30
    3b94:	89 2f       	mov	r24, r25
    3b96:	20 e2       	ldi	r18, 0x20	; 32
    3b98:	02 c0       	rjmp	.+4      	; 0x3b9e <dtoa_prf+0x14c>
    3b9a:	2d 93       	st	X+, r18
    3b9c:	81 50       	subi	r24, 0x01	; 1
    3b9e:	88 23       	and	r24, r24
    3ba0:	e1 f7       	brne	.-8      	; 0x3b9a <dtoa_prf+0x148>
    3ba2:	e9 0f       	add	r30, r25
    3ba4:	f1 1d       	adc	r31, r1
    3ba6:	10 82       	st	Z, r1
    3ba8:	2e ef       	ldi	r18, 0xFE	; 254
    3baa:	3f ef       	ldi	r19, 0xFF	; 255
    3bac:	af c0       	rjmp	.+350    	; 0x3d0c <dtoa_prf+0x2ba>
    3bae:	16 16       	cp	r1, r22
    3bb0:	17 06       	cpc	r1, r23
    3bb2:	1c f0       	brlt	.+6      	; 0x3bba <dtoa_prf+0x168>
    3bb4:	41 e0       	ldi	r20, 0x01	; 1
    3bb6:	50 e0       	ldi	r21, 0x00	; 0
    3bb8:	03 c0       	rjmp	.+6      	; 0x3bc0 <dtoa_prf+0x16e>
    3bba:	ab 01       	movw	r20, r22
    3bbc:	4f 5f       	subi	r20, 0xFF	; 255
    3bbe:	5f 4f       	sbci	r21, 0xFF	; 255
    3bc0:	aa 20       	and	r10, r10
    3bc2:	19 f4       	brne	.+6      	; 0x3bca <dtoa_prf+0x178>
    3bc4:	80 e0       	ldi	r24, 0x00	; 0
    3bc6:	90 e0       	ldi	r25, 0x00	; 0
    3bc8:	03 c0       	rjmp	.+6      	; 0x3bd0 <dtoa_prf+0x17e>
    3bca:	8a 2d       	mov	r24, r10
    3bcc:	90 e0       	ldi	r25, 0x00	; 0
    3bce:	01 96       	adiw	r24, 0x01	; 1
    3bd0:	20 e0       	ldi	r18, 0x00	; 0
    3bd2:	30 e0       	ldi	r19, 0x00	; 0
    3bd4:	aa 23       	and	r26, r26
    3bd6:	11 f0       	breq	.+4      	; 0x3bdc <dtoa_prf+0x18a>
    3bd8:	21 e0       	ldi	r18, 0x01	; 1
    3bda:	30 e0       	ldi	r19, 0x00	; 0
    3bdc:	24 0f       	add	r18, r20
    3bde:	35 1f       	adc	r19, r21
    3be0:	28 0f       	add	r18, r24
    3be2:	39 1f       	adc	r19, r25
    3be4:	81 2f       	mov	r24, r17
    3be6:	90 e0       	ldi	r25, 0x00	; 0
    3be8:	28 17       	cp	r18, r24
    3bea:	39 07       	cpc	r19, r25
    3bec:	14 f0       	brlt	.+4      	; 0x3bf2 <dtoa_prf+0x1a0>
    3bee:	20 e0       	ldi	r18, 0x00	; 0
    3bf0:	02 c0       	rjmp	.+4      	; 0x3bf6 <dtoa_prf+0x1a4>
    3bf2:	12 1b       	sub	r17, r18
    3bf4:	21 2f       	mov	r18, r17
    3bf6:	4b 2d       	mov	r20, r11
    3bf8:	50 e0       	ldi	r21, 0x00	; 0
    3bfa:	ca 01       	movw	r24, r20
    3bfc:	80 71       	andi	r24, 0x10	; 16
    3bfe:	90 70       	andi	r25, 0x00	; 0
    3c00:	b4 fc       	sbrc	r11, 4
    3c02:	0d c0       	rjmp	.+26     	; 0x3c1e <dtoa_prf+0x1cc>
    3c04:	b3 fc       	sbrc	r11, 3
    3c06:	0b c0       	rjmp	.+22     	; 0x3c1e <dtoa_prf+0x1cc>
    3c08:	f6 01       	movw	r30, r12
    3c0a:	32 2f       	mov	r19, r18
    3c0c:	40 e2       	ldi	r20, 0x20	; 32
    3c0e:	02 c0       	rjmp	.+4      	; 0x3c14 <dtoa_prf+0x1c2>
    3c10:	41 93       	st	Z+, r20
    3c12:	31 50       	subi	r19, 0x01	; 1
    3c14:	33 23       	and	r19, r19
    3c16:	e1 f7       	brne	.-8      	; 0x3c10 <dtoa_prf+0x1be>
    3c18:	c2 0e       	add	r12, r18
    3c1a:	d1 1c       	adc	r13, r1
    3c1c:	01 c0       	rjmp	.+2      	; 0x3c20 <dtoa_prf+0x1ce>
    3c1e:	32 2f       	mov	r19, r18
    3c20:	aa 23       	and	r26, r26
    3c22:	19 f0       	breq	.+6      	; 0x3c2a <dtoa_prf+0x1d8>
    3c24:	f6 01       	movw	r30, r12
    3c26:	a1 93       	st	Z+, r26
    3c28:	6f 01       	movw	r12, r30
    3c2a:	89 2b       	or	r24, r25
    3c2c:	11 f0       	breq	.+4      	; 0x3c32 <dtoa_prf+0x1e0>
    3c2e:	13 2f       	mov	r17, r19
    3c30:	0a c0       	rjmp	.+20     	; 0x3c46 <dtoa_prf+0x1f4>
    3c32:	f6 01       	movw	r30, r12
    3c34:	13 2f       	mov	r17, r19
    3c36:	80 e3       	ldi	r24, 0x30	; 48
    3c38:	02 c0       	rjmp	.+4      	; 0x3c3e <dtoa_prf+0x1ec>
    3c3a:	81 93       	st	Z+, r24
    3c3c:	11 50       	subi	r17, 0x01	; 1
    3c3e:	11 23       	and	r17, r17
    3c40:	e1 f7       	brne	.-8      	; 0x3c3a <dtoa_prf+0x1e8>
    3c42:	c3 0e       	add	r12, r19
    3c44:	d1 1c       	adc	r13, r1
    3c46:	09 2d       	mov	r16, r9
    3c48:	06 0f       	add	r16, r22
    3c4a:	ba 80       	ldd	r11, Y+2	; 0x02
    3c4c:	90 e1       	ldi	r25, 0x10	; 16
    3c4e:	89 2e       	mov	r8, r25
    3c50:	91 2c       	mov	r9, r1
    3c52:	8e 20       	and	r8, r14
    3c54:	9f 20       	and	r9, r15
    3c56:	e4 fe       	sbrs	r14, 4
    3c58:	04 c0       	rjmp	.+8      	; 0x3c62 <dtoa_prf+0x210>
    3c5a:	f1 e3       	ldi	r31, 0x31	; 49
    3c5c:	bf 16       	cp	r11, r31
    3c5e:	09 f4       	brne	.+2      	; 0x3c62 <dtoa_prf+0x210>
    3c60:	01 50       	subi	r16, 0x01	; 1
    3c62:	10 16       	cp	r1, r16
    3c64:	14 f0       	brlt	.+4      	; 0x3c6a <dtoa_prf+0x218>
    3c66:	01 e0       	ldi	r16, 0x01	; 1
    3c68:	03 c0       	rjmp	.+6      	; 0x3c70 <dtoa_prf+0x21e>
    3c6a:	09 30       	cpi	r16, 0x09	; 9
    3c6c:	08 f0       	brcs	.+2      	; 0x3c70 <dtoa_prf+0x21e>
    3c6e:	08 e0       	ldi	r16, 0x08	; 8
    3c70:	9b 01       	movw	r18, r22
    3c72:	77 ff       	sbrs	r23, 7
    3c74:	02 c0       	rjmp	.+4      	; 0x3c7a <dtoa_prf+0x228>
    3c76:	20 e0       	ldi	r18, 0x00	; 0
    3c78:	30 e0       	ldi	r19, 0x00	; 0
    3c7a:	cb 01       	movw	r24, r22
    3c7c:	01 96       	adiw	r24, 0x01	; 1
    3c7e:	82 1b       	sub	r24, r18
    3c80:	93 0b       	sbc	r25, r19
    3c82:	fe 01       	movw	r30, r28
    3c84:	31 96       	adiw	r30, 0x01	; 1
    3c86:	e8 0f       	add	r30, r24
    3c88:	f9 1f       	adc	r31, r25
    3c8a:	8e e2       	ldi	r24, 0x2E	; 46
    3c8c:	f8 2e       	mov	r15, r24
    3c8e:	3b 01       	movw	r6, r22
    3c90:	60 1a       	sub	r6, r16
    3c92:	71 08       	sbc	r7, r1
    3c94:	8a 2d       	mov	r24, r10
    3c96:	90 e0       	ldi	r25, 0x00	; 0
    3c98:	44 27       	eor	r20, r20
    3c9a:	55 27       	eor	r21, r21
    3c9c:	48 1b       	sub	r20, r24
    3c9e:	59 0b       	sbc	r21, r25
    3ca0:	8f ef       	ldi	r24, 0xFF	; 255
    3ca2:	2f 3f       	cpi	r18, 0xFF	; 255
    3ca4:	38 07       	cpc	r19, r24
    3ca6:	19 f4       	brne	.+6      	; 0x3cae <dtoa_prf+0x25c>
    3ca8:	d6 01       	movw	r26, r12
    3caa:	fd 92       	st	X+, r15
    3cac:	6d 01       	movw	r12, r26
    3cae:	62 17       	cp	r22, r18
    3cb0:	73 07       	cpc	r23, r19
    3cb2:	2c f0       	brlt	.+10     	; 0x3cbe <dtoa_prf+0x26c>
    3cb4:	62 16       	cp	r6, r18
    3cb6:	73 06       	cpc	r7, r19
    3cb8:	14 f4       	brge	.+4      	; 0x3cbe <dtoa_prf+0x26c>
    3cba:	80 81       	ld	r24, Z
    3cbc:	01 c0       	rjmp	.+2      	; 0x3cc0 <dtoa_prf+0x26e>
    3cbe:	80 e3       	ldi	r24, 0x30	; 48
    3cc0:	21 50       	subi	r18, 0x01	; 1
    3cc2:	30 40       	sbci	r19, 0x00	; 0
    3cc4:	31 96       	adiw	r30, 0x01	; 1
    3cc6:	24 17       	cp	r18, r20
    3cc8:	35 07       	cpc	r19, r21
    3cca:	24 f0       	brlt	.+8      	; 0x3cd4 <dtoa_prf+0x282>
    3ccc:	d6 01       	movw	r26, r12
    3cce:	8d 93       	st	X+, r24
    3cd0:	6d 01       	movw	r12, r26
    3cd2:	e6 cf       	rjmp	.-52     	; 0x3ca0 <dtoa_prf+0x24e>
    3cd4:	26 17       	cp	r18, r22
    3cd6:	37 07       	cpc	r19, r23
    3cd8:	49 f4       	brne	.+18     	; 0x3cec <dtoa_prf+0x29a>
    3cda:	b5 e3       	ldi	r27, 0x35	; 53
    3cdc:	bb 15       	cp	r27, r11
    3cde:	28 f0       	brcs	.+10     	; 0x3cea <dtoa_prf+0x298>
    3ce0:	bb 16       	cp	r11, r27
    3ce2:	21 f4       	brne	.+8      	; 0x3cec <dtoa_prf+0x29a>
    3ce4:	81 14       	cp	r8, r1
    3ce6:	91 04       	cpc	r9, r1
    3ce8:	09 f4       	brne	.+2      	; 0x3cec <dtoa_prf+0x29a>
    3cea:	81 e3       	ldi	r24, 0x31	; 49
    3cec:	f6 01       	movw	r30, r12
    3cee:	81 93       	st	Z+, r24
    3cf0:	d6 01       	movw	r26, r12
    3cf2:	81 2f       	mov	r24, r17
    3cf4:	90 e2       	ldi	r25, 0x20	; 32
    3cf6:	02 c0       	rjmp	.+4      	; 0x3cfc <dtoa_prf+0x2aa>
    3cf8:	9c 93       	st	X, r25
    3cfa:	81 50       	subi	r24, 0x01	; 1
    3cfc:	11 96       	adiw	r26, 0x01	; 1
    3cfe:	88 23       	and	r24, r24
    3d00:	d9 f7       	brne	.-10     	; 0x3cf8 <dtoa_prf+0x2a6>
    3d02:	e1 0f       	add	r30, r17
    3d04:	f1 1d       	adc	r31, r1
    3d06:	10 82       	st	Z, r1
    3d08:	20 e0       	ldi	r18, 0x00	; 0
    3d0a:	30 e0       	ldi	r19, 0x00	; 0
    3d0c:	c9 01       	movw	r24, r18
    3d0e:	29 96       	adiw	r28, 0x09	; 9
    3d10:	ee e0       	ldi	r30, 0x0E	; 14
    3d12:	0c 94 d0 1c 	jmp	0x39a0	; 0x39a0 <__epilogue_restores__+0x8>

00003d16 <__ftoa_engine>:
    3d16:	28 30       	cpi	r18, 0x08	; 8
    3d18:	08 f0       	brcs	.+2      	; 0x3d1c <__ftoa_engine+0x6>
    3d1a:	27 e0       	ldi	r18, 0x07	; 7
    3d1c:	33 27       	eor	r19, r19
    3d1e:	da 01       	movw	r26, r20
    3d20:	99 0f       	add	r25, r25
    3d22:	31 1d       	adc	r19, r1
    3d24:	87 fd       	sbrc	r24, 7
    3d26:	91 60       	ori	r25, 0x01	; 1
    3d28:	00 96       	adiw	r24, 0x00	; 0
    3d2a:	61 05       	cpc	r22, r1
    3d2c:	71 05       	cpc	r23, r1
    3d2e:	39 f4       	brne	.+14     	; 0x3d3e <__ftoa_engine+0x28>
    3d30:	32 60       	ori	r19, 0x02	; 2
    3d32:	2e 5f       	subi	r18, 0xFE	; 254
    3d34:	3d 93       	st	X+, r19
    3d36:	30 e3       	ldi	r19, 0x30	; 48
    3d38:	2a 95       	dec	r18
    3d3a:	e1 f7       	brne	.-8      	; 0x3d34 <__ftoa_engine+0x1e>
    3d3c:	08 95       	ret
    3d3e:	9f 3f       	cpi	r25, 0xFF	; 255
    3d40:	30 f0       	brcs	.+12     	; 0x3d4e <__ftoa_engine+0x38>
    3d42:	80 38       	cpi	r24, 0x80	; 128
    3d44:	71 05       	cpc	r23, r1
    3d46:	61 05       	cpc	r22, r1
    3d48:	09 f0       	breq	.+2      	; 0x3d4c <__ftoa_engine+0x36>
    3d4a:	3c 5f       	subi	r19, 0xFC	; 252
    3d4c:	3c 5f       	subi	r19, 0xFC	; 252
    3d4e:	3d 93       	st	X+, r19
    3d50:	91 30       	cpi	r25, 0x01	; 1
    3d52:	08 f0       	brcs	.+2      	; 0x3d56 <__ftoa_engine+0x40>
    3d54:	80 68       	ori	r24, 0x80	; 128
    3d56:	91 1d       	adc	r25, r1
    3d58:	df 93       	push	r29
    3d5a:	cf 93       	push	r28
    3d5c:	1f 93       	push	r17
    3d5e:	0f 93       	push	r16
    3d60:	ff 92       	push	r15
    3d62:	ef 92       	push	r14
    3d64:	19 2f       	mov	r17, r25
    3d66:	98 7f       	andi	r25, 0xF8	; 248
    3d68:	96 95       	lsr	r25
    3d6a:	e9 2f       	mov	r30, r25
    3d6c:	96 95       	lsr	r25
    3d6e:	96 95       	lsr	r25
    3d70:	e9 0f       	add	r30, r25
    3d72:	ff 27       	eor	r31, r31
    3d74:	e2 55       	subi	r30, 0x52	; 82
    3d76:	ff 4f       	sbci	r31, 0xFF	; 255
    3d78:	99 27       	eor	r25, r25
    3d7a:	33 27       	eor	r19, r19
    3d7c:	ee 24       	eor	r14, r14
    3d7e:	ff 24       	eor	r15, r15
    3d80:	a7 01       	movw	r20, r14
    3d82:	e7 01       	movw	r28, r14
    3d84:	05 90       	lpm	r0, Z+
    3d86:	08 94       	sec
    3d88:	07 94       	ror	r0
    3d8a:	28 f4       	brcc	.+10     	; 0x3d96 <__ftoa_engine+0x80>
    3d8c:	36 0f       	add	r19, r22
    3d8e:	e7 1e       	adc	r14, r23
    3d90:	f8 1e       	adc	r15, r24
    3d92:	49 1f       	adc	r20, r25
    3d94:	51 1d       	adc	r21, r1
    3d96:	66 0f       	add	r22, r22
    3d98:	77 1f       	adc	r23, r23
    3d9a:	88 1f       	adc	r24, r24
    3d9c:	99 1f       	adc	r25, r25
    3d9e:	06 94       	lsr	r0
    3da0:	a1 f7       	brne	.-24     	; 0x3d8a <__ftoa_engine+0x74>
    3da2:	05 90       	lpm	r0, Z+
    3da4:	07 94       	ror	r0
    3da6:	28 f4       	brcc	.+10     	; 0x3db2 <__ftoa_engine+0x9c>
    3da8:	e7 0e       	add	r14, r23
    3daa:	f8 1e       	adc	r15, r24
    3dac:	49 1f       	adc	r20, r25
    3dae:	56 1f       	adc	r21, r22
    3db0:	c1 1d       	adc	r28, r1
    3db2:	77 0f       	add	r23, r23
    3db4:	88 1f       	adc	r24, r24
    3db6:	99 1f       	adc	r25, r25
    3db8:	66 1f       	adc	r22, r22
    3dba:	06 94       	lsr	r0
    3dbc:	a1 f7       	brne	.-24     	; 0x3da6 <__ftoa_engine+0x90>
    3dbe:	05 90       	lpm	r0, Z+
    3dc0:	07 94       	ror	r0
    3dc2:	28 f4       	brcc	.+10     	; 0x3dce <__ftoa_engine+0xb8>
    3dc4:	f8 0e       	add	r15, r24
    3dc6:	49 1f       	adc	r20, r25
    3dc8:	56 1f       	adc	r21, r22
    3dca:	c7 1f       	adc	r28, r23
    3dcc:	d1 1d       	adc	r29, r1
    3dce:	88 0f       	add	r24, r24
    3dd0:	99 1f       	adc	r25, r25
    3dd2:	66 1f       	adc	r22, r22
    3dd4:	77 1f       	adc	r23, r23
    3dd6:	06 94       	lsr	r0
    3dd8:	a1 f7       	brne	.-24     	; 0x3dc2 <__ftoa_engine+0xac>
    3dda:	05 90       	lpm	r0, Z+
    3ddc:	07 94       	ror	r0
    3dde:	20 f4       	brcc	.+8      	; 0x3de8 <__ftoa_engine+0xd2>
    3de0:	49 0f       	add	r20, r25
    3de2:	56 1f       	adc	r21, r22
    3de4:	c7 1f       	adc	r28, r23
    3de6:	d8 1f       	adc	r29, r24
    3de8:	99 0f       	add	r25, r25
    3dea:	66 1f       	adc	r22, r22
    3dec:	77 1f       	adc	r23, r23
    3dee:	88 1f       	adc	r24, r24
    3df0:	06 94       	lsr	r0
    3df2:	a9 f7       	brne	.-22     	; 0x3dde <__ftoa_engine+0xc8>
    3df4:	84 91       	lpm	r24, Z+
    3df6:	10 95       	com	r17
    3df8:	17 70       	andi	r17, 0x07	; 7
    3dfa:	41 f0       	breq	.+16     	; 0x3e0c <__ftoa_engine+0xf6>
    3dfc:	d6 95       	lsr	r29
    3dfe:	c7 95       	ror	r28
    3e00:	57 95       	ror	r21
    3e02:	47 95       	ror	r20
    3e04:	f7 94       	ror	r15
    3e06:	e7 94       	ror	r14
    3e08:	1a 95       	dec	r17
    3e0a:	c1 f7       	brne	.-16     	; 0x3dfc <__ftoa_engine+0xe6>
    3e0c:	e4 e5       	ldi	r30, 0x54	; 84
    3e0e:	f0 e0       	ldi	r31, 0x00	; 0
    3e10:	68 94       	set
    3e12:	15 90       	lpm	r1, Z+
    3e14:	15 91       	lpm	r17, Z+
    3e16:	35 91       	lpm	r19, Z+
    3e18:	65 91       	lpm	r22, Z+
    3e1a:	95 91       	lpm	r25, Z+
    3e1c:	05 90       	lpm	r0, Z+
    3e1e:	7f e2       	ldi	r23, 0x2F	; 47
    3e20:	73 95       	inc	r23
    3e22:	e1 18       	sub	r14, r1
    3e24:	f1 0a       	sbc	r15, r17
    3e26:	43 0b       	sbc	r20, r19
    3e28:	56 0b       	sbc	r21, r22
    3e2a:	c9 0b       	sbc	r28, r25
    3e2c:	d0 09       	sbc	r29, r0
    3e2e:	c0 f7       	brcc	.-16     	; 0x3e20 <__ftoa_engine+0x10a>
    3e30:	e1 0c       	add	r14, r1
    3e32:	f1 1e       	adc	r15, r17
    3e34:	43 1f       	adc	r20, r19
    3e36:	56 1f       	adc	r21, r22
    3e38:	c9 1f       	adc	r28, r25
    3e3a:	d0 1d       	adc	r29, r0
    3e3c:	7e f4       	brtc	.+30     	; 0x3e5c <__ftoa_engine+0x146>
    3e3e:	70 33       	cpi	r23, 0x30	; 48
    3e40:	11 f4       	brne	.+4      	; 0x3e46 <__ftoa_engine+0x130>
    3e42:	8a 95       	dec	r24
    3e44:	e6 cf       	rjmp	.-52     	; 0x3e12 <__ftoa_engine+0xfc>
    3e46:	e8 94       	clt
    3e48:	01 50       	subi	r16, 0x01	; 1
    3e4a:	30 f0       	brcs	.+12     	; 0x3e58 <__ftoa_engine+0x142>
    3e4c:	08 0f       	add	r16, r24
    3e4e:	0a f4       	brpl	.+2      	; 0x3e52 <__ftoa_engine+0x13c>
    3e50:	00 27       	eor	r16, r16
    3e52:	02 17       	cp	r16, r18
    3e54:	08 f4       	brcc	.+2      	; 0x3e58 <__ftoa_engine+0x142>
    3e56:	20 2f       	mov	r18, r16
    3e58:	23 95       	inc	r18
    3e5a:	02 2f       	mov	r16, r18
    3e5c:	7a 33       	cpi	r23, 0x3A	; 58
    3e5e:	28 f0       	brcs	.+10     	; 0x3e6a <__ftoa_engine+0x154>
    3e60:	79 e3       	ldi	r23, 0x39	; 57
    3e62:	7d 93       	st	X+, r23
    3e64:	2a 95       	dec	r18
    3e66:	e9 f7       	brne	.-6      	; 0x3e62 <__ftoa_engine+0x14c>
    3e68:	10 c0       	rjmp	.+32     	; 0x3e8a <__ftoa_engine+0x174>
    3e6a:	7d 93       	st	X+, r23
    3e6c:	2a 95       	dec	r18
    3e6e:	89 f6       	brne	.-94     	; 0x3e12 <__ftoa_engine+0xfc>
    3e70:	06 94       	lsr	r0
    3e72:	97 95       	ror	r25
    3e74:	67 95       	ror	r22
    3e76:	37 95       	ror	r19
    3e78:	17 95       	ror	r17
    3e7a:	17 94       	ror	r1
    3e7c:	e1 18       	sub	r14, r1
    3e7e:	f1 0a       	sbc	r15, r17
    3e80:	43 0b       	sbc	r20, r19
    3e82:	56 0b       	sbc	r21, r22
    3e84:	c9 0b       	sbc	r28, r25
    3e86:	d0 09       	sbc	r29, r0
    3e88:	98 f0       	brcs	.+38     	; 0x3eb0 <__ftoa_engine+0x19a>
    3e8a:	23 95       	inc	r18
    3e8c:	7e 91       	ld	r23, -X
    3e8e:	73 95       	inc	r23
    3e90:	7a 33       	cpi	r23, 0x3A	; 58
    3e92:	08 f0       	brcs	.+2      	; 0x3e96 <__ftoa_engine+0x180>
    3e94:	70 e3       	ldi	r23, 0x30	; 48
    3e96:	7c 93       	st	X, r23
    3e98:	20 13       	cpse	r18, r16
    3e9a:	b8 f7       	brcc	.-18     	; 0x3e8a <__ftoa_engine+0x174>
    3e9c:	7e 91       	ld	r23, -X
    3e9e:	70 61       	ori	r23, 0x10	; 16
    3ea0:	7d 93       	st	X+, r23
    3ea2:	30 f0       	brcs	.+12     	; 0x3eb0 <__ftoa_engine+0x19a>
    3ea4:	83 95       	inc	r24
    3ea6:	71 e3       	ldi	r23, 0x31	; 49
    3ea8:	7d 93       	st	X+, r23
    3eaa:	70 e3       	ldi	r23, 0x30	; 48
    3eac:	2a 95       	dec	r18
    3eae:	e1 f7       	brne	.-8      	; 0x3ea8 <__ftoa_engine+0x192>
    3eb0:	11 24       	eor	r1, r1
    3eb2:	ef 90       	pop	r14
    3eb4:	ff 90       	pop	r15
    3eb6:	0f 91       	pop	r16
    3eb8:	1f 91       	pop	r17
    3eba:	cf 91       	pop	r28
    3ebc:	df 91       	pop	r29
    3ebe:	99 27       	eor	r25, r25
    3ec0:	87 fd       	sbrc	r24, 7
    3ec2:	90 95       	com	r25
    3ec4:	08 95       	ret

00003ec6 <strrev>:
    3ec6:	dc 01       	movw	r26, r24
    3ec8:	fc 01       	movw	r30, r24
    3eca:	67 2f       	mov	r22, r23
    3ecc:	71 91       	ld	r23, Z+
    3ece:	77 23       	and	r23, r23
    3ed0:	e1 f7       	brne	.-8      	; 0x3eca <strrev+0x4>
    3ed2:	32 97       	sbiw	r30, 0x02	; 2
    3ed4:	04 c0       	rjmp	.+8      	; 0x3ede <strrev+0x18>
    3ed6:	7c 91       	ld	r23, X
    3ed8:	6d 93       	st	X+, r22
    3eda:	70 83       	st	Z, r23
    3edc:	62 91       	ld	r22, -Z
    3ede:	ae 17       	cp	r26, r30
    3ee0:	bf 07       	cpc	r27, r31
    3ee2:	c8 f3       	brcs	.-14     	; 0x3ed6 <strrev+0x10>
    3ee4:	08 95       	ret

00003ee6 <__udivmodhi4>:
    3ee6:	aa 1b       	sub	r26, r26
    3ee8:	bb 1b       	sub	r27, r27
    3eea:	51 e1       	ldi	r21, 0x11	; 17
    3eec:	07 c0       	rjmp	.+14     	; 0x3efc <__udivmodhi4_ep>

00003eee <__udivmodhi4_loop>:
    3eee:	aa 1f       	adc	r26, r26
    3ef0:	bb 1f       	adc	r27, r27
    3ef2:	a6 17       	cp	r26, r22
    3ef4:	b7 07       	cpc	r27, r23
    3ef6:	10 f0       	brcs	.+4      	; 0x3efc <__udivmodhi4_ep>
    3ef8:	a6 1b       	sub	r26, r22
    3efa:	b7 0b       	sbc	r27, r23

00003efc <__udivmodhi4_ep>:
    3efc:	88 1f       	adc	r24, r24
    3efe:	99 1f       	adc	r25, r25
    3f00:	5a 95       	dec	r21
    3f02:	a9 f7       	brne	.-22     	; 0x3eee <__udivmodhi4_loop>
    3f04:	80 95       	com	r24
    3f06:	90 95       	com	r25
    3f08:	bc 01       	movw	r22, r24
    3f0a:	cd 01       	movw	r24, r26
    3f0c:	08 95       	ret

00003f0e <_exit>:
    3f0e:	f8 94       	cli

00003f10 <__stop_program>:
    3f10:	ff cf       	rjmp	.-2      	; 0x3f10 <__stop_program>
